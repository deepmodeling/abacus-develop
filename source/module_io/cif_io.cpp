#include <iostream>
#include <fstream>
#include <cmath>
#include <algorithm>
#include "module_base/formatter.h"
#include "module_io/cif_io.h"

double deg2rad(double deg)
{
    return deg * M_PI / 180.0;
}
double rad2deg(double rad)
{
    return rad * 180.0 / M_PI;
}
// general
void vec_to_abc_angles(const double* vec, double* abc_angles);
void abc_angles_to_vec(const double* abc_angles, double* vec);
double vec_to_volume(const double* vec);
double abc_angles_to_volume(const double* abc_angles);
// cif specific requirements
void chem_formula(const int natom,
                  const std::string* atom_site_labels,
                  std::string& sum,
                  std::string& structural);

// interface to ABACUS UnitCell impl.
void unpack_ucell(const UnitCell& ucell,    // because ucell is too heavy...
                  std::vector<double> veca,
                  std::vector<double> vecb,
                  std::vector<double> vecc,
                  int& natom,
                  std::vector<std::string> atom_site_labels,
                  std::vector<double> atom_site_fract_coords);
                  
void to_cif(const std::string& fcif,
            const double* abc_angles,
            const int natom,
            const std::string* atom_site_labels, // the one without numbers
            const double* atom_site_fract_coords,
            const std::string& title = "# generated by ABACUS",
            const std::string& data_tag = "data_?",
            const double* atom_site_occups = nullptr, // may be this will be useful after impementation of VCA?
            const std::string& cell_formula_units_z = "1");

void chem_formula(const int natom, 
                  const std::string* atom_site_labels,
                  std::string& sum,
                  std::string& structural)
{
    std::vector<std::string> kinds;
    std::vector<std::string> labels(natom);
    std::copy(atom_site_labels, atom_site_labels + natom, labels.begin());
    for (int i = 0; i < natom; ++i)
    {
        if (std::find(kinds.begin(), kinds.end(), labels[i]) == kinds.end())
        {
            kinds.push_back(labels[i]);
        }
    }
    std::vector<size_t> counts(kinds.size());
    std::transform(kinds.begin(), kinds.end(), counts.begin(), [&labels](const std::string& kind) {
        return std::count(labels.begin(), labels.end(), kind);
    });
    for (size_t i = 0; i < kinds.size(); ++i)
    {
        sum += kinds[i];
        structural += kinds[i];
        if (counts[i] > 1)
        {
            sum += std::to_string(counts[i]);
        }
    }
}

void vec_to_abc_angles(const double* vec, double* abc_angles)
{
    const std::vector<double> a = {vec[0], vec[1], vec[2]};
    const std::vector<double> b = {vec[3], vec[4], vec[5]};
    const std::vector<double> c = {vec[6], vec[7], vec[8]};
    const double anorm = std::sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
    const double bnorm = std::sqrt(b[0] * b[0] + b[1] * b[1] + b[2] * b[2]);
    const double cnorm = std::sqrt(c[0] * c[0] + c[1] * c[1] + c[2] * c[2]);
    const double alpha = std::acos((b[0] * c[0] + b[1] * c[1] + b[2] * c[2]) / (bnorm * cnorm));
    const double beta = std::acos((a[0] * c[0] + a[1] * c[1] + a[2] * c[2]) / (anorm * cnorm));
    const double gamma = std::acos((a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) / (anorm * bnorm));
    abc_angles[0] = anorm;
    abc_angles[1] = bnorm;
    abc_angles[2] = cnorm;
    abc_angles[3] = rad2deg(alpha);
    abc_angles[4] = rad2deg(beta);
    abc_angles[5] = rad2deg(gamma);
}
void abc_angles_to_vec(const double* abc_angles, double* vec)
{
    const double a = abc_angles[0];
    const double b = abc_angles[1];
    const double c = abc_angles[2];
    const double alpha = abc_angles[3];
    const double beta = abc_angles[4];
    const double gamma = abc_angles[5];
    vec[0] = a;
    vec[1] = 0.0;
    vec[2] = 0.0;
    vec[3] = b * std::cos(deg2rad(gamma));
    vec[4] = b * std::sin(deg2rad(gamma));
    vec[5] = 0.0;
    vec[6] = c * std::cos(deg2rad(beta));
    vec[7] = c * (std::cos(deg2rad(alpha)) - std::cos(deg2rad(beta)) * std::cos(deg2rad(gamma))) / std::sin(deg2rad(gamma));
    vec[8] = std::sqrt(c * c - vec[6] * vec[6] - vec[7] * vec[7]);
}
double vec_to_volume(const double* vec)
{
    // vector's mixed product
    return vec[0] * (vec[4] * vec[8] - vec[5] * vec[7]) - vec[1] * (vec[3] * vec[8] - vec[5] * vec[6]) + vec[2] * (vec[3] * vec[7] - vec[4] * vec[6]);
}
double abc_angles_to_volume(const double* abc_angles)
{
    std::vector<double> vec(9);
    abc_angles_to_vec(abc_angles, vec.data());
    return vec_to_volume(vec.data());
}

void unpack_ucell(const UnitCell& ucell,
                  std::vector<double> veca,
                  std::vector<double> vecb,
                  std::vector<double> vecc,
                  int& natom,
                  std::vector<std::string> atom_site_labels,
                  std::vector<double> atom_site_fract_coords)
{
    const double bohr2angstrom = 0.52917721067;
    const double lat0 = ucell.lat.lat0;
    veca.resize(3);
    vecb.resize(3);
    vecc.resize(3);
    veca[0] = ucell.a1.x;
    veca[1] = ucell.a1.y;
    veca[2] = ucell.a1.z;
    vecb[0] = ucell.a2.x;
    vecb[1] = ucell.a2.y;
    vecb[2] = ucell.a2.z;
    vecc[0] = ucell.a3.x;
    vecc[1] = ucell.a3.y;
    vecc[2] = ucell.a3.z;
    std::for_each(veca.begin(), veca.end(), [lat0, bohr2angstrom](double& x) { x *= lat0 * bohr2angstrom; });
    std::for_each(vecb.begin(), vecb.end(), [lat0, bohr2angstrom](double& x) { x *= lat0 * bohr2angstrom; });
    std::for_each(vecc.begin(), vecc.end(), [lat0, bohr2angstrom](double& x) { x *= lat0 * bohr2angstrom; });
    natom = ucell.nat;
    atom_site_labels.resize(natom);
    atom_site_fract_coords.resize(3 * natom);
    for (int i = 0; i < natom; ++i)
    {
        atom_site_labels[i] = ucell.atoms[ucell.iat2it[i]].ncpp.psd; // this is purely the element symbol
        atom_site_fract_coords[3 * i] = ucell.atoms[ucell.iat2it[i]].taud[ucell.iat2ia[i]].x;
        atom_site_fract_coords[3 * i + 1] = ucell.atoms[ucell.iat2it[i]].taud[ucell.iat2ia[i]].y;
        atom_site_fract_coords[3 * i + 2] = ucell.atoms[ucell.iat2it[i]].taud[ucell.iat2ia[i]].z;
    }
}

void to_cif(const std::string& fcif,
            const double* abc_angles,
            const int natom,
            const std::string* atom_site_labels,
            const double* atom_site_fract_coords,
            const std::string& title,
            const std::string& data_tag,
            const double* atom_site_occups,
            const std::string& cell_formula_units_z)
{
    std::ofstream ofs(fcif);
    if (!ofs)
    {
        std::cerr << "Error: failed to open file " << fcif << std::endl;
        return;
    }
    ofs << title << std::endl;
    ofs << data_tag << std::endl;
    ofs << "_symmetry_space_group_name_H-M   'P 1'" << std::endl;
    ofs << "_cell_length_a   " << abc_angles[0] << std::endl;
    ofs << "_cell_length_b   " << abc_angles[1] << std::endl;
    ofs << "_cell_length_c   " << abc_angles[2] << std::endl;
    ofs << "_cell_angle_alpha   " << abc_angles[3] << std::endl;
    ofs << "_cell_angle_beta   " << abc_angles[4] << std::endl;
    ofs << "_cell_angle_gamma   " << abc_angles[5] << std::endl;
    ofs << "_symmetry_Int_Tables_number   1" << std::endl;
    std::string chem_sum, chem_structural;
    chem_formula(natom, atom_site_labels, chem_sum, chem_structural);
    ofs << "_chemical_formula_structural   " << chem_structural << std::endl;
    ofs << "_chemical_formula_sum   " << chem_sum << std::endl;
    ofs << "_cell_volume   " << abc_angles_to_volume(abc_angles) << std::endl;
    ofs << "_cell_formula_units_Z   " << cell_formula_units_z << std::endl;
    ofs << "loop_" << std::endl;
    ofs << " _symmetry_equiv_pos_site_id" << std::endl;
    ofs << " _symmetry_equiv_pos_as_xyz" << std::endl;
    ofs << "  1  'x, y, z'" << std::endl;
    ofs << "loop_" << std::endl;
    ofs << " _atom_site_type_symbol" << std::endl;
    ofs << " _atom_site_label" << std::endl;
    ofs << " _atom_site_symmetry_multiplicity" << std::endl;
    ofs << " _atom_site_fract_x" << std::endl;
    ofs << " _atom_site_fract_y" << std::endl;
    ofs << " _atom_site_fract_z" << std::endl;
    ofs << " _atom_site_occupancy" << std::endl;
    std::vector<double> occups(natom, 1.0);
    if (atom_site_occups != nullptr)
    {// overwrite the default occupancies
        std::copy(atom_site_occups, atom_site_occups + natom, occups.begin());
    }
    // then output atomic information with format: %3s%4s%3d%12.8f%12.8f%12.8f%3d
    FmtCore fmt("%3s%4s%3d%12.8f%12.8f%12.8f%3d");
    int j = 0;
    std::string numbered_label;
    std::string cache;
    for (int i = 0; i < natom; ++i)
    {
        const std::string label = atom_site_labels[i];
        numbered_label = label + std::to_string(i);
        cache = fmt.format(label.c_str(), numbered_label.c_str(), 1, 
        atom_site_fract_coords[j], atom_site_fract_coords[j + 1], atom_site_fract_coords[j + 2], occups[i]);
        ofs << cache << std::endl;
        j += 3;
    }
    ofs << std::endl;
    ofs.close();
}
