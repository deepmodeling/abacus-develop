#include "module_cell/unitcell.h"
#include <string>
#include <vector>

/**
 * @file cif_io.h
 * @brief This file contains the implementation of the functions for reading and writing CIF files.
 * 
 * Due to the space group and point group symmetry information are not always present, 
 * here will assume only P1 and C1 symmetry are present in the CIF file.
 * 
 * A typical CIF file with no symmetry (P1 and C1) is presented below, downloaded from
 * materials project: https://materialsproject.org/
 * 
 * # generated using pymatgen
 * data_C
 * _symmetry_space_group_name_H-M   'P 1'
 * _cell_length_a   2.46772428
 * _cell_length_b   2.46772428
 * _cell_length_c   8.68503800
 * _cell_angle_alpha   90.00000000
 * _cell_angle_beta   90.00000000
 * _cell_angle_gamma   120.00000758
 * _symmetry_Int_Tables_number   1
 * _chemical_formula_structural   C
 * _chemical_formula_sum   C4
 * _cell_volume   45.80317575
 * _cell_formula_units_Z   4
 * loop_
 *  _symmetry_equiv_pos_site_id
 *  _symmetry_equiv_pos_as_xyz
 *   1  'x, y, z'
 * loop_
 *  _atom_site_type_symbol
 *  _atom_site_label
 *  _atom_site_symmetry_multiplicity
 *  _atom_site_fract_x
 *  _atom_site_fract_y
 *  _atom_site_fract_z
 *  _atom_site_occupancy
 *   C  C0  1  0.00000000  0.00000000  0.75000000  1
 *   C  C1  1  0.00000000  0.00000000  0.25000000  1
 *   C  C2  1  0.33333300  0.66666700  0.75000000  1
 *   C  C3  1  0.66666700  0.33333300  0.25000000  1
 *
 */
namespace ModuleIO
{
    class CifParser
    {
        public:
            CifParser() = delete; // I cannot understand why there should be a default constructor
            CifParser(const std::string& fcif) {}
            ~CifParser() {} // actually do not need to do anything...
            // some utils
            // general
            static void vec_to_abc_angles(const double* vec, double* abc_angles);
            static void abc_angles_to_vec(const double* abc_angles, double* vec);
            static double vec_to_volume(const double* vec);
            static double abc_angles_to_volume(const double* abc_angles);
            static double deg2rad(double deg) { return deg * M_PI / 180.0; }
            static double rad2deg(double rad) { return rad * 180.0 / M_PI; }
            static void to_cif(const std::string& fcif,
                               const double* abc_angles,
                               const int natom,
                               const std::string* atom_site_labels, // the one without numbers
                               const double* atom_site_fract_coords,
                               const std::string& title = "# generated by ABACUS",
                               const std::string& data_tag = "data_?",
                               const double* atom_site_occups = nullptr, // may be this will be useful after impementation of VCA?
                               const std::string& cell_formula_units_z = "1");
            // the version with both spacegroup symmetry and point group symmetry ready
            // not for now, because it is too complicated. However it is a walk-around
            // way to fix issue #4998
            // static void to_cif();
            static void to_cif(const std::string& fcif,
                               const UnitCell& ucell,
                               const std::string& title = "# generated by ABACUS",
                               const std::string& data_tag = "data_?");
            static void from_cif(const std::string& fcif,
                                 std::map<std::string, std::vector<std::string>>& out);
        // private:
            // not needed to be exposed
            static void _build_chem_formula(const int natom,
                                            const std::string* atom_site_labels,
                                            std::string& sum,
                                            std::string& structural);
            // interface to ABACUS UnitCell impl.
            static void _unpack_ucell(const UnitCell& ucell,    // because ucell is too heavy...
                                      std::vector<double>& veca,
                                      std::vector<double>& vecb,
                                      std::vector<double>& vecc,
                                      int& natom,
                                      std::vector<std::string>& atom_site_labels,
                                      std::vector<double>& atom_site_fract_coords);

            static std::vector<std::string> _split_loop_block(const std::string& block);
            static std::map<std::string, std::vector<std::string>> _build_block_data(const std::vector<std::string>& block);
        
        private:
            std::map<std::string, std::vector<std::string>> raw_;
    };
} // namespace ModuleIO
