#ifndef MODULE_IO_CIF_IO_H
#define MODULE_IO_CIF_IO_H
#include "module_cell/unitcell.h"
#include <string>
#include <vector>
#include <map>

namespace ModuleIO
{
/**
 * @file cif_io.h
 * @brief This file contains the implementation of the functions for reading and writing CIF files.
 * 
 * Due to the space group and point group symmetry information are not always present, 
 * here will assume system only has P1 and C1 symmetry.
 * 
 * A typical CIF file with no symmetry (P1 and C1) is presented below, downloaded from
 * materials project: https://materialsproject.org/
 * 
 * # generated using pymatgen
 * data_C
 * _symmetry_space_group_name_H-M   'P 1'
 * _cell_length_a   2.46772428
 * _cell_length_b   2.46772428
 * _cell_length_c   8.68503800
 * _cell_angle_alpha   90.00000000
 * _cell_angle_beta   90.00000000
 * _cell_angle_gamma   120.00000758
 * _symmetry_Int_Tables_number   1
 * _chemical_formula_structural   C
 * _chemical_formula_sum   C4
 * _cell_volume   45.80317575
 * _cell_formula_units_Z   4
 * loop_
 *  _symmetry_equiv_pos_site_id
 *  _symmetry_equiv_pos_as_xyz
 *   1  'x, y, z'
 * loop_
 *  _atom_site_type_symbol
 *  _atom_site_label
 *  _atom_site_symmetry_multiplicity
 *  _atom_site_fract_x
 *  _atom_site_fract_y
 *  _atom_site_fract_z
 *  _atom_site_occupancy
 *   C  C0  1  0.00000000  0.00000000  0.75000000  1
 *   C  C1  1  0.00000000  0.00000000  0.25000000  1
 *   C  C2  1  0.33333300  0.66666700  0.75000000  1
 *   C  C3  1  0.66666700  0.33333300  0.25000000  1
 *
 * For cif file from COD, which always contains experimental information and even SHELX
 * single-crystal refinement information, is much more complicated.
 * see https://www.crystallography.net/cod/ for more information.
 * 
 * Design of this "class"
 * see implementation of CifParser in pymatgen package.
 * 
 * Usage of this "class"
 * 1. Read CIF file and store the information in a map.
 * std::map<std::string, std::vector<std::string>> cif_info;
 * ModuleIO::CifParser::from_cif("test.cif", cif_info);
 * Information of the cif file can be accessed by the key, for example:
 * get all the atom coordinates by:
 * std::vector<std::string> atom_site_fract_coords = cif_info["_atom_site_fract_x"];
 * ... and so for y and z components.
 * One should note that for some cif files, the number will be in the format like
 * "0.00000000(1)", which means the uncertainty of the number is 1 in the last digit.
 * In this case, user should be careful to convert the string to double by its own.
 * 
 * However, the formal structure read-in from cif to assign values to the UnitCell instance
 * is not implemented yet. This is because the cif file does not have pseudopotential and
 * numerical orbital information, this needs further careful design.
 * 
 * 2. Write CIF file with the given information.
 * ModuleIO::CifParser::to_cif("test.cif", ...);
 * For detailed usage, see the static methods in the class. A to-be-deprecated usage is
 * simple as:
 * ModuleIO::CifParser cif("test.cif", ucell);
 * , where ucell is an instance of UnitCell. This usage is not encouraged.
 * 
 * Pythonization information:
 * 1. function to_cif
 * it is recommended to pythonize the 2nd overload of this function, the 3rd one will be
 * deprecated in the future.
 * 2. function from_cif
 * this function can be directly pythonized.
 */
    class CifParser
    {
        public:
            CifParser() = delete; // I cannot see any necessity to have a default constructor
            CifParser(const std::string& fcif); // read the cif file and store the information
            ~CifParser() {} // actually do not need to do anything explicitly

            /**
             * @brief Print the CIF file from the given information.
             * 
             * @param fcif the output cif file name
             * @param abc_angles cell A B C angles in the form of [a, b, c, alpha, beta, gamma]
             * @param natom the number of atoms
             * @param atom_site_labels the atom site labels in the form of [atom1, atom2, ...]
             * @param atom_site_fract_coords the fractional coordinates of the atoms in the form of [x1, y1, z1, x2, y2, z2, ...]
             * @param title the title of the CIF file
             * @param data_tag the data tag of the CIF file
             * @param atom_site_occups the occupancies of the atoms in the form of [occup1, occup2, ...]
             * @param cell_formula_units_z the cell formula units Z
             */
            static void to_cif(const std::string& fcif,
                               const double* abc_angles,
                               const int natom,
                               const std::string* atom_site_labels, // the one without numbers
                               const double* atom_site_fract_coords,
                               const std::string& title = "# generated by ABACUS",
                               const std::string& data_tag = "data_?",
                               const double* atom_site_occups = nullptr, // may be this will be useful after impementation of VCA?
                               const std::string& cell_formula_units_z = "1");
            /**
             * @brief A Pybind wrapper for the static method to_cif.
             * 
             * @param fcif the output cif file name
             * @param abc_angles cell A B C angles in the form of [a, b, c, alpha, beta, gamma]
             * @param atom_site_labels the atom site labels in the form of [atom1, atom2, ...]
             * @param atom_site_fract_coords the fractional coordinates of the atoms in the form of [x1, y1, z1, x2, y2, z2, ...]
             * @param title the title of the CIF file
             * @param data_tag the data tag of the CIF file
             * @param atom_site_occups the occupancies of the atoms in the form of [occup1, occup2, ...]
             * @param cell_formula_units_z the cell formula units Z
             */
            static void to_cif(const std::string& fcif,
                               const std::vector<double>& abc_angles,
                               const std::vector<std::string>& atom_site_labels, // the one without numbers
                               const std::vector<double>& atom_site_fract_coords,
                               const std::string& title = "# generated by ABACUS",
                               const std::string& data_tag = "data_?",
                               const std::vector<double>& atom_site_occups = {}, // may be this will be useful after impementation of VCA?
                               const std::string& cell_formula_units_z = "1");
            // the version with both spacegroup symmetry and point group symmetry ready
            // not for now, because it is too complicated. However it is a walk-around
            // way to fix issue #4998
            // static void to_cif();

            /**
             * @brief Write CIF file with the whole UnitCell instance
             * 
             * @param fcif the output cif file name
             * @param ucell the input UnitCell instance
             * @param title the title of the CIF file
             * @param data_tag the data tag of the CIF file
             */
            static void to_cif(const std::string& fcif,
                               const UnitCell& ucell,
                               const std::string& title = "# generated by ABACUS",
                               const std::string& data_tag = "data_?");
            /**
             * @brief Read the CIF file and store the information in the map.
             * 
             * @param fcif the input cif file name
             * @param out the output map containing the information
             */
            static void from_cif(const std::string& fcif,
                                 std::map<std::string, std::vector<std::string>>& out);

            /**
             * @brief get information by key from the stored information of cif file. However, due to
             * the keys vary from different cif files, there are uncertainties in the return value.
             * In principle, however, there are still some common keys, such as "data_tag", "title", 
             * "_cell_length_a", "_cell_length_b", "_cell_length_c", "_cell_angle_alpha", "_cell_angle_beta",
             * "_cell_angle_gamma", "_cell_volume", and the atom site information, which can be accessed
             * with the key "atom_site_label", "atom_site_fract_x", "atom_site_fract_y", "atom_site_fract_z",
             * "atom_site_occupancy".
             * 
             * @param key the key to search
             * @return std::vector<std::string>, if the key is not found, an empty vector will be returned 
             */
            std::vector<std::string> get(const std::string& key);

        private:
            // interface to ABACUS UnitCell impl.
            static void _unpack_ucell(const UnitCell& ucell,    // because ucell is too heavy...
                                      std::vector<double>& veca,
                                      std::vector<double>& vecb,
                                      std::vector<double>& vecc,
                                      int& natom,
                                      std::vector<std::string>& atom_site_labels,
                                      std::vector<double>& atom_site_fract_coords);

            // stores the information of the cif file
            std::map<std::string, std::vector<std::string>> raw_;
    };
} // namespace ModuleIO
#endif // MODULE_IO_CIF_IO_H