driver.cpp:    this->reading();
driver.cpp:    this->atomic_world();
driver.cpp:    this->driver_run();
driver.h:     * This function calls "this->reading()", "this->atomic_world()" in order.
driver.h:     * This function calls "this->driver_run()" to do calculation,
module_base/assoc_laguerre.cpp:        L[i] = this->value(n, l, s[i]);
module_base/assoc_laguerre.cpp:        y[i] = this->value(n, l, x[i]);
module_base/assoc_laguerre.cpp:        double first = (2*n_ - 1 + a_ - x)/n_ * this->associate_laguerre(n-1, x, a);
module_base/assoc_laguerre.cpp:        double second = (n_ + a_ - 1)/n_ * this->associate_laguerre(n-2, x, a);
module_base/assoc_laguerre.cpp:        return n * this->factorial(n-1);
module_base/assoc_laguerre.cpp:        static_cast<double>(this->factorial(n_ + k_)) / 
module_base/assoc_laguerre.cpp:        static_cast<double>(this->factorial(n_ - iq)) / 
module_base/assoc_laguerre.cpp:        static_cast<double>(this->factorial(k_ + iq)) / 
module_base/assoc_laguerre.cpp:        static_cast<double>(this->factorial(iq));
module_base/complexarray.cpp:	init(this->getSize());
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	this->init(size);
module_base/complexarray.cpp:	this->zero_out();
module_base/complexarray.cpp:	this->freemem();
module_base/complexarray.cpp:	this->init(size);
module_base/complexarray.cpp:	this->bound1 = cd.bound1;
module_base/complexarray.cpp:	this->bound2 = cd.bound2;
module_base/complexarray.cpp:	this->bound3 = cd.bound3;
module_base/complexarray.cpp:	this->bound4 = cd.bound4;
module_base/complexarray.cpp:	delete [] this->ptr;
module_base/complexarray.cpp:	this->ptr   =cd.ptr;	cd.ptr   =nullptr;
module_base/complexarray.cpp:	this->bound1=cd.bound1;	cd.bound1=0;
module_base/complexarray.cpp:	this->bound2=cd.bound2;	cd.bound2=0;
module_base/complexarray.cpp:	this->bound3=cd.bound3;	cd.bound3=0;
module_base/complexarray.cpp:	this->bound4=cd.bound4;	cd.bound4=0;
module_base/complexarray.cpp:	delete [] this->ptr;
module_base/complexarray.cpp:	this->ptr   =cd.ptr;	cd.ptr   =nullptr;
module_base/complexarray.cpp:	this->bound1=cd.bound1;	cd.bound1=0;
module_base/complexarray.cpp:	this->bound2=cd.bound2;	cd.bound2=0;
module_base/complexarray.cpp:	this->bound3=cd.bound3;	cd.bound3=0;
module_base/complexarray.cpp:	this->bound4=cd.bound4;	cd.bound4=0;
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size1 = this->getSize();
module_base/complexarray.cpp:	const int b11 = this->getBound1();
module_base/complexarray.cpp:	const int b12 = this->getBound2();
module_base/complexarray.cpp:	const int b13 = this->getBound3();
module_base/complexarray.cpp:	const int b14 = this->getBound4();
module_base/complexarray.cpp:    	for ( int i = 0;i <size1;++i) {if (this->ptr[i] != cd2.ptr[i]) {return false;} }
module_base/complexarray.cpp:	const int size1 = this->getSize();
module_base/complexarray.cpp:	const int b11 = this->getBound1();
module_base/complexarray.cpp:	const int b12 = this->getBound2();
module_base/complexarray.cpp:	const int b13 = this->getBound3();
module_base/complexarray.cpp:	const int b14 = this->getBound4();
module_base/complexarray.cpp:    	for ( int i = 0;i <size1;++i) {if (this->ptr[i] != cd2.ptr[i]) {return true;} }
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexarray.cpp:	const int size = this->getSize();
module_base/complexmatrix.cpp:	this->create(m.nr, m.nc, false);
module_base/complexmatrix.cpp:	for (int i = 0;i < this->size;i++) c[i] *= s;
module_base/complexmatrix.cpp:	for(int i=0; i<size; i++) this->c[i] += m.c[i];
module_base/complexmatrix.cpp:	for(int i=0; i<size; i++) this->c[i] -= m.c[i];
module_base/complexmatrix.cpp:	for( int i=0; i<this->size; ++i) m.c[i] = c[i].real();
module_base/complexmatrix.cpp:	for( int ir=0; ir!=this->nr; ++ir )
module_base/complexmatrix.cpp:		for( int ic=0; ic!=this->nc; ++ic )
module_base/complexmatrix.cpp:	for(int i=0;i<this->nr;i++)
module_base/complexmatrix.cpp:		for(int j=0;j<this->nc;j++)
module_base/formatter_contextfmt.cpp:    this->p_phys_fmt_ = new formatter::PhysicalFmt("none", &(this->fmt_));
module_base/formatter_contextfmt.cpp:    this->disable_title();
module_base/formatter_contextfmt.cpp:    delete this->p_phys_fmt_;
module_base/formatter_contextfmt.cpp:    int iterative = this->iterative_;
module_base/formatter_contextfmt.cpp:    if (strcmp(context.c_str(), this->context_.c_str()) == 0) {
module_base/formatter_contextfmt.cpp:        this->iterative_ = iterative;
module_base/formatter_contextfmt.cpp:    this->reset();
module_base/formatter_contextfmt.cpp:    this->context_ = context;
module_base/formatter_contextfmt.cpp:    auto it = this->predefined_phys_fmt.find(context);
module_base/formatter_contextfmt.cpp:    if (it != this->predefined_phys_fmt.end()) {
module_base/formatter_contextfmt.cpp:        this->known_context_ = true;
module_base/formatter_contextfmt.cpp:            this->phys_fmt_.push_back(fmt);
module_base/formatter_contextfmt.cpp:            this->ncol_++;
module_base/formatter_contextfmt.cpp:            if (this->iterative_ >= 1) {
module_base/formatter_contextfmt.cpp:                this->enable_title();
module_base/formatter_contextfmt.cpp:                this->disable_title();
module_base/formatter_contextfmt.cpp:            this->enable_title();
module_base/formatter_contextfmt.cpp:            this->only_title();
module_base/formatter_contextfmt.cpp:        this->known_context_ = false;
module_base/formatter_contextfmt.cpp:    this->reset();
module_base/formatter_contextfmt.cpp:    this->context_ = "";
module_base/formatter_contextfmt.cpp:    this->ncol_ = ncol;
module_base/formatter_contextfmt.cpp:    for (int icol = 0; icol < this->ncol_; ++icol) {
module_base/formatter_contextfmt.cpp:        this->nrows_.push_back(nrows[icol]);
module_base/formatter_contextfmt.cpp:        this->phys_fmt_.push_back(phys_fmt[icol]);
module_base/formatter_contextfmt.cpp:    this->set_context(context);
module_base/formatter_contextfmt.cpp:    this->ncol_ = ncol;
module_base/formatter_contextfmt.cpp:        this->nrows_.push_back(nrows[i]);
module_base/formatter_contextfmt.cpp:    this->reset();
module_base/formatter_contextfmt.cpp:    this->context_ = "";
module_base/formatter_contextfmt.cpp:    this->ncol_ = phys_fmt.size();
module_base/formatter_contextfmt.cpp:    for (int icol = 0; icol < this->ncol_; ++icol) {
module_base/formatter_contextfmt.cpp:        this->phys_fmt_.push_back(phys_fmt[icol]);
module_base/formatter_contextfmt.cpp:    if (this->title_switch_%2 == 0) {
module_base/formatter_contextfmt.cpp:        this->cache_title_ = value;  
module_base/formatter_contextfmt.cpp:        if (this->known_context_) {
module_base/formatter_contextfmt.cpp:            this->p_phys_fmt_->set_context(this->phys_fmt_[this->icol_]);
module_base/formatter_contextfmt.cpp:            this->p_phys_fmt_->set_context("none");
module_base/formatter_contextfmt.cpp:        Table::add_col(this->cache_title_, (std::vector<std::string>){this->fmt_.format(value)});
module_base/formatter_contextfmt.cpp:        this->icol_++;
module_base/formatter_contextfmt.cpp:        this->fmt_.reset();
module_base/formatter_contextfmt.cpp:        this->title_switch_ += 2;
module_base/formatter_contextfmt.cpp:        this->title_switch_++;
module_base/formatter_contextfmt.cpp:    //this->context_ = "";
module_base/formatter_contextfmt.cpp:    this->phys_fmt_.clear();
module_base/formatter_contextfmt.cpp:    this->default_phys_fmt_ = "energy";
module_base/formatter_contextfmt.cpp:    this->cache_title_ = "";
module_base/formatter_contextfmt.cpp:    this->with_title_ = true;
module_base/formatter_contextfmt.cpp:    this->ncol_ = 0;
module_base/formatter_contextfmt.cpp:    this->icol_ = 0;
module_base/formatter_contextfmt.cpp:    this->nrows_.clear();
module_base/formatter_contextfmt.cpp:    this->iterative_ = 0;
module_base/formatter_contextfmt.cpp:    this->fmt_.reset();
module_base/formatter_contextfmt.cpp:    this->title_switch_ = 0;
module_base/formatter_contextfmt.cpp:    this->known_context_ = false;
module_base/formatter_contextfmt.cpp:    this->disable_title(); // do what constructor does
module_base/formatter_contextfmt.cpp:    this->reset();
module_base/formatter_contextfmt.cpp:    this->set_context(this->context_);
module_base/formatter_contextfmt.cpp:    if (this->iterative_ == 1)
module_base/formatter_contextfmt.cpp:        this->iterative_ += 1;
module_base/formatter_contextfmt.cpp:    else if (this->iterative_ > 1)
module_base/formatter_contextfmt.cpp:        this->iterative_ += 1;
module_base/formatter_contextfmt.cpp:    std::string str = this->print_table();
module_base/formatter_contextfmt.cpp:    this->context_refresh();
module_base/formatter_contextfmt.cpp:    std::cout << "context: " << this->context_ << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "known_context: " << this->known_context_ << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "ncol: " << this->ncol_ << std::endl;
module_base/formatter_contextfmt.cpp:    for (auto n : this->nrows_) {
module_base/formatter_contextfmt.cpp:    for (auto fmt : this->phys_fmt_) {
module_base/formatter_contextfmt.cpp:    std::cout << "cache_title: " << this->cache_title_ << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "icol: " << this->icol_ << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "title_switch: " << this->title_switch_ << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "iterative: " << this->iterative_ << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "width: " << this->fmt_.get_width() << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "precision: " << this->fmt_.get_precision() << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "fillChar: " << this->fmt_.get_fillChar() << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "fixed: " << this->fmt_.get_fixed() << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "right: " << this->fmt_.get_right() << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "error: " << this->fmt_.get_error() << std::endl;
module_base/formatter_contextfmt.cpp:    std::cout << "p_phys_fmt: " << this->p_phys_fmt_ << std::endl;
module_base/formatter_contextfmt.h:            /// @param context context name, see this->predefined_phys_fmt
module_base/formatter_contextfmt.h:            /// @param context context name, see this->predefined_phys_fmt
module_base/formatter_contextfmt.h:                if (this->title_switch_%2 == 0) {
module_base/formatter_contextfmt.h:                    this->cache_title_ = std::to_string(value);
module_base/formatter_contextfmt.h:                    if (this->known_context_) {
module_base/formatter_contextfmt.h:                        this->p_phys_fmt_->set_context(this->phys_fmt_[this->icol_]);
module_base/formatter_contextfmt.h:                        this->p_phys_fmt_->set_context(this->default_phys_fmt_);
module_base/formatter_contextfmt.h:                    Table::add_col(this->cache_title_, (std::vector<std::string>){this->fmt_.format(value)});
module_base/formatter_contextfmt.h:                    this->cache_title_ = "";
module_base/formatter_contextfmt.h:                    this->fmt_.reset();
module_base/formatter_contextfmt.h:                    this->icol_++;
module_base/formatter_contextfmt.h:                    this->title_switch_ += 2;
module_base/formatter_contextfmt.h:                    this->title_switch_++;
module_base/formatter_contextfmt.h:                if (this->known_context_) {
module_base/formatter_contextfmt.h:                    this->p_phys_fmt_->set_context(this->phys_fmt_[this->icol_]);
module_base/formatter_contextfmt.h:                else if (this->icol_ < this->phys_fmt_.size()) {
module_base/formatter_contextfmt.h:                    this->p_phys_fmt_->set_context(this->phys_fmt_[this->icol_]);
module_base/formatter_contextfmt.h:                    this->p_phys_fmt_->set_context(this->default_phys_fmt_);
module_base/formatter_contextfmt.h:                    value_.push_back(this->fmt_.format(v));
module_base/formatter_contextfmt.h:                Table::add_col(this->cache_title_, value_);
module_base/formatter_contextfmt.h:                this->cache_title_ = "";
module_base/formatter_contextfmt.h:                this->fmt_.reset();
module_base/formatter_contextfmt.h:                this->icol_++;
module_base/formatter_contextfmt.h:                this->title_switch_++;
module_base/formatter_contextfmt.h:                if (this->known_context_) {
module_base/formatter_contextfmt.h:                    this->p_phys_fmt_->set_context(this->phys_fmt_[this->icol_]);
module_base/formatter_contextfmt.h:                else if (this->icol_ < this->phys_fmt_.size()) {
module_base/formatter_contextfmt.h:                    this->p_phys_fmt_->set_context(this->phys_fmt_[this->icol_]);
module_base/formatter_contextfmt.h:                    this->p_phys_fmt_->set_context(this->default_phys_fmt_);
module_base/formatter_contextfmt.h:                for (int i = 0; i < this->nrows_[this->icol_]; ++i) {
module_base/formatter_contextfmt.h:                    value_.push_back(this->fmt_.format(value[i]));
module_base/formatter_contextfmt.h:                Table::add_col(this->cache_title_, value_);
module_base/formatter_contextfmt.h:                this->cache_title_ = "";
module_base/formatter_contextfmt.h:                this->fmt_.reset();
module_base/formatter_contextfmt.h:                this->icol_++;
module_base/formatter_contextfmt.h:                this->title_switch_++;
module_base/formatter_contextfmt.h:            void enable_title() { Table::set_mode(0); this->set_title_switch(0); }
module_base/formatter_contextfmt.h:            void disable_title() { Table::set_mode(1); this->set_title_switch(1); }
module_base/formatter_contextfmt.h:            void only_title() { Table::set_mode(-1); this->set_title_switch(0); }
module_base/formatter_physfmt.cpp:        this->p_formatter_ = p_formatter;
module_base/formatter_physfmt.cpp:        this->decorator_mode_ = true;
module_base/formatter_physfmt.cpp:        this->p_formatter_ = new Fmt();
module_base/formatter_physfmt.cpp:    this->adjust_formatter();
module_base/formatter_physfmt.cpp:    if (this->p_formatter_ != nullptr && !this->decorator_mode_) {
module_base/formatter_physfmt.cpp:        delete this->p_formatter_;
module_base/formatter_physfmt.cpp:        this->p_formatter_ = nullptr;
module_base/formatter_physfmt.cpp:    auto context = this->context_.c_str();
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(2); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(4); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(8); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(6); this->p_formatter_->set_precision(1);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(6); this->p_formatter_->set_precision(2);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(6); this->p_formatter_->set_precision(4);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(8); this->p_formatter_->set_precision(4);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(false);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(6); this->p_formatter_->set_precision(4);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left); this->p_formatter_->set_error(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(10); this->p_formatter_->set_precision(2);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(12); this->p_formatter_->set_precision(8);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(16); this->p_formatter_->set_precision(10);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(20); this->p_formatter_->set_precision(10);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(4); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(10); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(20); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(30); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(' '); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(width); this->p_formatter_->set_precision(decisive_length);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(fillchar); this->p_formatter_->set_fixed(!scientific);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_width(width); this->p_formatter_->set_precision(0);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_fillChar(fillchar); this->p_formatter_->set_fixed(true);
module_base/formatter_physfmt.cpp:        this->p_formatter_->set_right(!left);
module_base/formatter_physfmt.cpp:    this->adjust_formatter();
module_base/formatter_physfmt.cpp:    this->p_formatter_ = p_formatter;
module_base/formatter_physfmt.cpp:    this->decorator_mode_ = true;
module_base/formatter_table.cpp:    this->ncol_++;
module_base/formatter_table.cpp:    this->titles_.push_back(new_title);
module_base/formatter_table.cpp:    this->data_.push_back(new_col);
module_base/formatter_table.cpp:    return this->ncol_-1;
module_base/formatter_table.cpp:    this->col_widths_.clear();
module_base/formatter_table.cpp:    for (int icol = 0; icol < this->ncol_; ++icol) {
module_base/formatter_table.cpp:        int s1 = this->titles_[icol].size();
module_base/formatter_table.cpp:        for (auto row : this->data_[icol]) {
module_base/formatter_table.cpp:                this->col_widths_.push_back(s1);
module_base/formatter_table.cpp:                this->col_widths_.push_back(s2);
module_base/formatter_table.cpp:    this->col_max_width_ = max_width;
module_base/formatter_table.cpp:    for (int icol = 0; icol < this->ncol_; ++icol) {
module_base/formatter_table.cpp:            this->col_widths_.push_back(max_width);
module_base/formatter_table.cpp:            this->total_width_ += max_width;
module_base/formatter_table.cpp:            this->total_width_ += this->col_widths_[icol];
module_base/formatter_table.cpp:            if (this->col_max_width_ < this->col_widths_[icol]) {
module_base/formatter_table.cpp:                this->col_max_width_ = this->col_widths_[icol];
module_base/formatter_table.cpp:    this->total_width_ += this->ncol_+1; // add the width of the delimiters
module_base/formatter_table.cpp:    for (int icol = 0; icol < this->ncol_; ++icol) {
module_base/formatter_table.cpp:        int s = this->titles_[icol].size();
module_base/formatter_table.cpp:        int n = this->col_widths_[icol];
module_base/formatter_table.cpp:        title += this->titles_[icol];
module_base/formatter_table.cpp:        this->titles_[icol] = title;
module_base/formatter_table.cpp:    this->mode_ = 0;
module_base/formatter_table.cpp:    this->overall_title = "";
module_base/formatter_table.cpp:    this->ncol_ = 0;
module_base/formatter_table.cpp:    this->col_delimiter_ = ' ';
module_base/formatter_table.cpp:    this->frame_switches_ = {1, 1, 0, 0};
module_base/formatter_table.cpp:    this->frame_delimiters_ = {'-', '-', '|', '|'};
module_base/formatter_table.cpp:    this->frame_mid_switch_ = 1;
module_base/formatter_table.cpp:    this->frame_mid_delimiter_ = '-';
module_base/formatter_table.cpp:    this->flexible_width_ = true;
module_base/formatter_table.cpp:    this->col_max_width_ = 0;
module_base/formatter_table.cpp:    this->total_width_ = 0;
module_base/formatter_table.cpp:    this->title_position_ = 0;
module_base/formatter_table.cpp:    this->clean();
module_base/formatter_table.cpp:    this->titles_.clear();
module_base/formatter_table.cpp:    this->col_widths_.clear();
module_base/formatter_table.cpp:    this->data_.clear();
module_base/formatter_table.cpp:    this->adjust_col_width();
module_base/formatter_table.cpp:    if (this->title_position_ == 0) {
module_base/formatter_table.cpp:        this->centerize_title();
module_base/formatter_table.cpp:    int nrow_max = this->data_[0].size();
module_base/formatter_table.cpp:    int ncol = this->ncol_;
module_base/formatter_table.cpp:        int s = this->data_[icol].size();
module_base/formatter_table.cpp:    if (this->mode_ != 1) {
module_base/formatter_table.cpp:        if (this->overall_title.size() > 0) {
module_base/formatter_table.cpp:            ss << this->overall_title << std::endl;
module_base/formatter_table.cpp:        if (this->frame_switches_[0]) {
module_base/formatter_table.cpp:            for (int iw = 0; iw < this->total_width_; ++iw) {
module_base/formatter_table.cpp:                ss << this->frame_delimiters_[0];
module_base/formatter_table.cpp:        if (this->frame_switches_[2]) {
module_base/formatter_table.cpp:            ss << this->frame_delimiters_[2];
module_base/formatter_table.cpp:            ss << std::setw(this->col_widths_[icol]) 
module_base/formatter_table.cpp:            if(this->title_position_ <= 0) {
module_base/formatter_table.cpp:            ss << this->titles_[icol];
module_base/formatter_table.cpp:                ss << this->col_delimiter_;
module_base/formatter_table.cpp:        if (this->frame_switches_[3]) {
module_base/formatter_table.cpp:            ss << this->frame_delimiters_[3];
module_base/formatter_table.cpp:        if (this->frame_mid_switch_) {
module_base/formatter_table.cpp:            for (int iw = 0; iw < this->total_width_; ++iw) {
module_base/formatter_table.cpp:                ss << this->frame_mid_delimiter_;
module_base/formatter_table.cpp:    if (this->mode_ >= 0) {
module_base/formatter_table.cpp:            if (this->frame_switches_[2]) {
module_base/formatter_table.cpp:                ss << this->frame_delimiters_[2];
module_base/formatter_table.cpp:                    ss << std::setw(this->col_widths_[icol]) 
module_base/formatter_table.cpp:                    << this->data_[icol][irow];
module_base/formatter_table.cpp:                    ss << std::setw(this->col_widths_[icol]) 
module_base/formatter_table.cpp:                    ss << this->col_delimiter_;
module_base/formatter_table.cpp:            if (this->frame_switches_[3]) {
module_base/formatter_table.cpp:                ss << this->frame_delimiters_[3];
module_base/formatter_table.cpp:    if (this->mode_ == 0) {
module_base/formatter_table.cpp:        if (this->frame_switches_[1]) {
module_base/formatter_table.cpp:            for (int iw = 0; iw < this->total_width_; ++iw) {
module_base/formatter_table.cpp:                ss << this->frame_delimiters_[1];
module_base/formatter_table.cpp:    this->reset();
module_base/gram_schmidt_orth-inl.h:		this->radial_2 = Mathzone::Pointwise_Product( radial, radial );
module_base/gram_schmidt_orth-inl.h:	switch( this->coordinate )
module_base/intarray.cpp:	assert( this->size == right.size );
module_base/inverse_matrix.cpp:	this->dim = dim_in;
module_base/inverse_matrix.cpp:	this->e = new double[dim];
module_base/inverse_matrix.cpp:	this->lwork = 2*dim;
module_base/inverse_matrix.cpp:	this->work2 = new std::complex<double>[lwork];
module_base/inverse_matrix.cpp:	this->rwork = new double[3*dim-2];
module_base/inverse_matrix.cpp:	this->info = 0;
module_base/inverse_matrix.cpp:	this->A.create(dim, dim);
module_base/inverse_matrix.cpp:	this->EA.create(dim, dim);
module_base/inverse_matrix.cpp:	this->allocate = true;
module_base/inverse_matrix.cpp:	this->A = Sin;
module_base/inverse_matrix.cpp:    LapackConnector::zheev('V', 'U', dim, this->A, dim, e, work2, lwork, rwork, &info);
module_base/inverse_matrix.cpp:			EA(i,j)= conj( this->A(j,i) ) / e[i] ;
module_base/inverse_matrix.cpp:    Sout = this->A * this->EA;
module_base/math_bspline.cpp:        this->xi = xiin;
module_base/math_bspline.cpp:        this->Dx = Dxin;
module_base/math_bspline.cpp:        this->norder = norderin;
module_base/math_bspline.cpp:        delete[] bezier; bezier = new double [this->norder+1];
module_base/math_bspline.cpp:        return this->bezier[n];
module_base/math_bspline.cpp:                this->bezier[n] = ((x + n*this->Dx - this->xi)*this->bezier[n] + 
module_base/math_bspline.cpp:                (this->xi + (k-n+1)*Dx - x)*this->bezier[n-1])/(k*this->Dx);
module_base/math_bspline.cpp:            this->bezier[0] = (x - this->xi)*this->bezier[0] / (k*this->Dx);
module_base/math_chebyshev.cpp:    fftw_execute(this->coef_plan);
module_base/math_chebyshev.cpp:    fftwf_execute(this->coef_plan);
module_base/math_chebyshev.cpp:    this->norder = norder_in;
module_base/math_chebyshev.cpp:    if(this->norder < 1)
module_base/math_chebyshev_def.h:    std::complex<REAL> *pcoef = (std::complex<REAL> *)this->fftw.ccoef;
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun)((REAL) cos((i+0.5)*ModuleBase::TWO_PI/norder2));
module_base/math_chebyshev_def.h:    //this->fftw.dcoef --FFT--> fftw.pcoef
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun)(cos(i*ModuleBase::TWO_PI/norder2));
module_base/math_chebyshev_def.h:    //this->fftw.dcoef --FFT--> fftw.pcoef
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:     std::complex<REAL> *pcoef = ( std::complex<REAL> *)this->fftw.ccoef;
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun)(cos((i+0.5)*ModuleBase::TWO_PI/norder2)).real();
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun)(cos((i+0.5)*ModuleBase::TWO_PI/norder2)).imag();
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun)(cos(i*ModuleBase::TWO_PI/norder2)).real();
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun)(cos(i*ModuleBase::TWO_PI/norder2)).imag();
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:     std::complex<REAL> *pcoef = ( std::complex<REAL> *)this->fftw.ccoef;
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun1)(cos((i+0.5)*ModuleBase::TWO_PI/norder2));
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun2)(cos((i+0.5)*ModuleBase::TWO_PI/norder2));
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun1)(cos(i*ModuleBase::TWO_PI/norder2));
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:        this->fftw.dcoef[i]=(ptr->*fun2)(cos(i*ModuleBase::TWO_PI/norder2));
module_base/math_chebyshev_def.h:    this->fftw.execute_fftw();
module_base/math_chebyshev_def.h:    polytrace[0] = this->ddot_real(wavein,wavein,N,LDA,m);
module_base/math_chebyshev_def.h:    polytrace[1] = this->ddot_real(wavein,arrayn,N,LDA,m);
module_base/math_chebyshev_def.h:        polytrace[ior] = this->ddot_real(wavein,arraynp1,N,LDA,m);   
module_base/math_chebyshev_def.h:    sum1=this->ddot_real(arrayn_1,arrayn_1,N);
module_base/math_chebyshev_def.h:    sum2=this->ddot_real(arrayn_1,arrayn,N);
module_base/math_chebyshev_def.h:    sum1=this->ddot_real(arrayn,arrayn,N);
module_base/math_chebyshev_def.h:    sum2=this->ddot_real(arrayn,arraynp1,N);
module_base/math_lebedev_laikov.cpp:    this->degree = degree;
module_base/matrix-inl.h:		if(flag_zero)	this->zero_out();
module_base/matrix-inl.h:	this->create( m_in.nr, m_in.nc, false );
module_base/matrix.cpp:		if(flag_zero)	this->zero_out();
module_base/matrix.cpp:	this->create( m_in.nr, m_in.nc, false );
module_base/matrix.cpp:	if(flag_zero) this-> zero_out();
module_base/matrix.cpp:	for( int ir=0; ir!=this->nr; ++ir )
module_base/matrix.cpp:		for( int ic=0; ic!=this->nc; ++ic )
module_base/matrix3.cpp:	double d = this->Det();
module_base/module_container/ATen/core/tensor.cpp:                    this->data<T_>(), other.data<T_>(), this->NumElements()))
module_base/module_container/ATen/core/tensor.cpp:    TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.cpp:            kernels::set_memory<T_, DEVICE_>()(this->data<T_>(), 0, this->NumElements()))
module_base/module_container/ATen/core/tensor.cpp:        int dim_ = static_cast<int>(this->NumElements() / (-num));
module_base/module_container/ATen/core/tensor.cpp:        if (dim_ < 1 || -dim_ * num != this->NumElements()) {
module_base/module_container/ATen/core/tensor.cpp:        if (num != this->NumElements()) {
module_base/module_container/ATen/core/tensor.cpp:    this->shape_ = shape;
module_base/module_container/ATen/core/tensor.cpp:    REQUIRES_OK(output.CopyFrom(*this, this->shape()), "Invalid shaped operation.")
module_base/module_container/ATen/core/tensor.cpp:    Tensor output(this->data_type_, this->device_, output_shape);
module_base/module_container/ATen/core/tensor.cpp:        TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.cpp:                               output.data<T_>(), this->data<T_>() + start[0], size[0]))
module_base/module_container/ATen/core/tensor.cpp:            TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.cpp:                                   output.data<T_>() + offset_out, this->data<T_>() + offset, size[1]))
module_base/module_container/ATen/core/tensor.cpp:                TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.cpp:                                       output.data<T_>() + offset_out, this->data<T_>() + offset, size[1]))
module_base/module_container/ATen/core/tensor.cpp:    REQUIRES_OK(buffer_->OwnsMemory() || this->NumElements() == 0,
module_base/module_container/ATen/core/tensor.cpp:        this->buffer_ = new TensorBuffer(GetAllocator(device_), new_shape.NumElements() * SizeOfType(data_type_));
module_base/module_container/ATen/core/tensor.cpp:    this->device_ = other.device_;
module_base/module_container/ATen/core/tensor.cpp:    this->data_type_ = other.data_type_;
module_base/module_container/ATen/core/tensor.cpp:    this->shape_ = other.shape_;
module_base/module_container/ATen/core/tensor.cpp:    this->buffer_ = new TensorBuffer(GetAllocator(device_), shape_.NumElements() * SizeOfType(data_type_));
module_base/module_container/ATen/core/tensor.cpp:    TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.cpp:                   this->data<T_>(), other.data<T_>(), this->NumElements()))
module_base/module_container/ATen/core/tensor.cpp:    this->device_ = other.device_;
module_base/module_container/ATen/core/tensor.cpp:    this->data_type_ = other.data_type_;
module_base/module_container/ATen/core/tensor.cpp:    this->shape_ = other.shape_;
module_base/module_container/ATen/core/tensor.cpp:    this->buffer_ = other.buffer_;
module_base/module_container/ATen/core/tensor.cpp:    if (this->data_type_ != other.data_type_ ||
module_base/module_container/ATen/core/tensor.cpp:        this->device_ != other.device_ ||
module_base/module_container/ATen/core/tensor.cpp:        this->shape_ != other.shape_) 
module_base/module_container/ATen/core/tensor.cpp:    if (this->device_ != DeviceType::CpuDevice) {
module_base/module_container/ATen/core/tensor.cpp:        Tensor tmpA = this->to_device<DEVICE_CPU>();
module_base/module_container/ATen/core/tensor.cpp:    TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.cpp:                   result = std::equal(this->data<T_>(), this->data<T_>() + this->NumElements(), other.data<T_>(), element_compare<T_, sizeof(GetTypeReal<T_>::type)>))
module_base/module_container/ATen/core/tensor.cpp:    REQUIRES_OK(this->data_type_ == rhs.data_type_ 
module_base/module_container/ATen/core/tensor.cpp:        && this->device_ == rhs.device_)
module_base/module_container/ATen/core/tensor.cpp:    if (this->shape_ == rhs.shape_) {
module_base/module_container/ATen/core/tensor.cpp:                        this->data<T_>(), rhs.data<T_>(), this->NumElements()))
module_base/module_container/ATen/core/tensor.cpp:                        this->data<T_>(), rhs.data<T_>(), this->shape().dims(), rhs.shape().dims()))
module_base/module_container/ATen/core/tensor.cpp:    TensorShape output_shape = this->shape_;
module_base/module_container/ATen/core/tensor.cpp:    auto data_ = reinterpret_cast<char*>(this->data()) + index * shape_.strides()[0] * SizeOfType(this->data_type_);
module_base/module_container/ATen/core/tensor.cpp:    return TensorMap(data_, this->data_type_, this->device_, output_shape);
module_base/module_container/ATen/core/tensor.h:        TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.h:                this->data<T>(), values.begin(), this->NumElements()))
module_base/module_container/ATen/core/tensor.h:        if (this->device_ == DeviceTypeToEnum<DEVICE>::value) {
module_base/module_container/ATen/core/tensor.h:        Tensor output(this->data_type_, DeviceTypeToEnum<DEVICE>::value, this->shape_);
module_base/module_container/ATen/core/tensor.h:        TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.h:                           output.data<T_>(), this->data<T_>(), this->NumElements()))
module_base/module_container/ATen/core/tensor.h:     *      in the destination tensor (`this->shape_.num_elements()`). If this condition is not met, the function
module_base/module_container/ATen/core/tensor.h:            num_elements = this->NumElements();
module_base/module_container/ATen/core/tensor.h:        REQUIRES_OK(this->shape_.NumElements() >= num_elements,
module_base/module_container/ATen/core/tensor.h:        TEMPLATE_CZ_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.h:                           this->data<T_>(), data, num_elements))
module_base/module_container/ATen/core/tensor.h:        Tensor output(DataTypeToEnum<T>::value, this->device_, this->shape_);
module_base/module_container/ATen/core/tensor.h:        TEMPLATE_CZ_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.h:                           output.data<T>(), this->data<T_>(), this->NumElements()))
module_base/module_container/ATen/core/tensor.h:        REQUIRES_OK(this->shape_.ndim() == N, 
module_base/module_container/ATen/core/tensor.h:        return TensorAccessor<T, N, index_t>(this->data<T>(), this->shape_.dims().data(), this->shape_.strides().data());
module_base/module_container/ATen/core/tensor.h:        return this->NumElements() > 0;
module_base/module_container/ATen/core/tensor.h:        TEMPLATE_ALL_2(this->data_type_, this->device_,
module_base/module_container/ATen/core/tensor.h:            kernels::set_memory<T, DEVICE_>()(this->data<T>(), value, this->NumElements()))
module_base/module_container/ATen/core/tensor_accessor.h:        return TensorAccessor<T, N - 1, index_t, PtrTraits>(this->data_ + idx * this->strides_[0], this->sizes_ + 1, this->strides_ + 1);
module_base/module_container/ATen/core/tensor_accessor.h:        return TensorAccessor<T, N - 1, index_t, PtrTraits>(this->data_ + idx * this->strides_[0], this->sizes_ + 1, this->strides_ + 1);
module_base/module_container/ATen/core/tensor_accessor.h:        return this->data_[idx * this->strides_[0]];
module_base/module_container/ATen/core/tensor_accessor.h:        return this->data_[idx * this->strides_[0]];
module_base/module_container/ATen/core/tensor_buffer.cpp:    if (this->OwnsMemory() && data_ != nullptr) {
module_base/module_container/ATen/core/tensor_buffer.cpp:bool TensorBuffer::OwnsMemory() const { return this->owns_memory_; }
module_base/module_container/ATen/core/tensor_buffer.cpp:    void* new_data = this->alloc_->allocate(size);
module_base/module_container/ATen/core/tensor_buffer.cpp:    if (this->OwnsMemory()) {
module_base/module_container/ATen/core/tensor_buffer.cpp:        this->alloc_->free(data_);
module_base/module_container/ATen/core/tensor_buffer.cpp:    this->data_ = new_data;
module_base/module_container/ATen/core/tensor_buffer.cpp:    this->owns_memory_ = true;
module_base/module_container/ATen/core/tensor_buffer.cpp:    if (this->OwnsMemory()) {
module_base/module_container/ATen/core/tensor_buffer.cpp:        this->alloc_->free(data_);
module_base/module_container/ATen/core/tensor_buffer.cpp:    delete this->alloc_;
module_base/module_container/ATen/core/tensor_buffer.cpp:        this->alloc_ = new base::core::CPUAllocator();
module_base/module_container/ATen/core/tensor_buffer.cpp:        this->alloc_ = new base::core::GPUAllocator();
module_base/module_container/ATen/core/tensor_buffer.cpp:    this->data_ = this->alloc_->allocate(other.GetAllocatedBytes());
module_base/module_container/ATen/core/tensor_buffer.cpp:    this->owns_memory_ = true;
module_base/module_container/ATen/core/tensor_buffer.cpp:    if (this->OwnsMemory()) {
module_base/module_container/ATen/core/tensor_buffer.cpp:        this->alloc_->free(data_);
module_base/module_container/ATen/core/tensor_buffer.cpp:    delete this->alloc_;
module_base/module_container/ATen/core/tensor_buffer.cpp:    this->alloc_ = other.alloc_;
module_base/module_container/ATen/core/tensor_buffer.cpp:    this->data_ = other.data_;
module_base/module_container/ATen/core/tensor_buffer.cpp:    this->owns_memory_ = other.owns_memory_;
module_base/module_container/ATen/core/tensor_map.cpp:    this->shape_ = shape;
module_base/module_container/ATen/core/tensor_map.cpp:    if(this->buffer_ != nullptr)
module_base/module_container/ATen/core/tensor_map.cpp:        this->buffer_->unref();
module_base/module_container/ATen/core/tensor_map.cpp:    this->buffer_ = new TensorBuffer(data);
module_base/module_container/ATen/core/tensor_map.cpp:    this->shape_ = shape;
module_base/module_container/ATen/core/tensor_map.cpp:    if(this->buffer_ != nullptr)
module_base/module_container/ATen/core/tensor_map.cpp:        this->buffer_->unref();
module_base/module_container/ATen/core/tensor_map.cpp:    this->buffer_ = new TensorBuffer(data);
module_base/module_container/ATen/core/tensor_map.cpp:    this->shape_ = other.shape();
module_base/module_container/ATen/core/tensor_map.cpp:    if(this->buffer_ != nullptr)
module_base/module_container/ATen/core/tensor_map.cpp:        this->buffer_->unref();
module_base/module_container/ATen/core/tensor_map.cpp:    this->buffer_ = new TensorBuffer(data);
module_base/module_container/ATen/core/tensor_shape.cpp:    for (int i = 0; i < this->ndim(); ++i) {
module_base/module_container/ATen/core/tensor_shape.cpp:    return this->ndim() ? num_elements : 0;
module_base/module_container/base/core/cpu_allocator.cpp:    this->allocated_size_ = size;
module_base/module_container/base/core/cpu_allocator.cpp:    this->allocated_size_ = size;
module_base/module_container/base/core/cpu_allocator.cpp:    this->allocated_size_ = 0;
module_base/module_container/base/core/gpu_allocator.cpp:    this->allocated_size_ = size;
module_base/module_container/base/core/gpu_allocator.cpp:    this->allocated_size_ = size;
module_base/module_container/base/core/gpu_allocator.cpp:    this->allocated_size_ = 0;
module_base/module_container/base/core/refcount.h:        if (this->get() == nullptr) {
module_base/module_container/base/core/refcount.h:        this->get()->ref();
module_base/module_container/base/core/refcount.h:        return std::unique_ptr<T, ref_count_deleter>(this->get());
module_base/module_mixing/broyden_mixing.cpp:        this->ndim_cal_dF = std::min(this->ndim_cal_dF + 1, this->mixing_ndim);
module_base/module_mixing/broyden_mixing.cpp:        start_dF = (this->start_dF + 1) % this->mixing_ndim;
module_base/module_mixing/broyden_mixing.h:        this->mixing_ndim = mixing_ndim;
module_base/module_mixing/broyden_mixing.h:        this->data_ndim = mixing_ndim + 1;
module_base/module_mixing/broyden_mixing.h:        this->coef = std::vector<double>(mixing_ndim + 1);
module_base/module_mixing/broyden_mixing.h:        this->beta = ModuleBase::matrix(mixing_ndim, mixing_ndim, true);
module_base/module_mixing/broyden_mixing.h:        this->mixing_beta = mixing_beta;
module_base/module_mixing/broyden_mixing.h:        this->ndim_cal_dF = 0;
module_base/module_mixing/broyden_mixing.h:        this->start_dF = -1;
module_base/module_mixing/broyden_mixing.h:        this->address = nullptr;
module_base/module_mixing/broyden_mixing.h:        this->tem_push_data(mdata, data_in, data_out, screen, mix, need_calcoef);
module_base/module_mixing/broyden_mixing.h:        this->tem_push_data(mdata, data_in, data_out, screen, mix, need_calcoef);
module_base/module_mixing/mixing.cpp:    this->push_data(
module_base/module_mixing/mixing.cpp:                out[i] = in[i] + this->mixing_beta * sres[i];
module_base/module_mixing/mixing.cpp:    this->push_data(
module_base/module_mixing/mixing.cpp:                out[i] = in[i] + this->mixing_beta * sres[i];
module_base/module_mixing/mixing_data.cpp:    this->ndim_tot = ndim;
module_base/module_mixing/mixing_data.cpp:    this->length = length;
module_base/module_mixing/mixing_data.cpp:        this->data = malloc(ndim * length * type_size);
module_base/module_mixing/mixing_data.cpp:    if (this->data != nullptr)
module_base/module_mixing/mixing_data.cpp:        free(this->data);
module_base/module_mixing/mixing_data.cpp:    this->ndim_tot = ndim;
module_base/module_mixing/mixing_data.cpp:    this->length = length;
module_base/module_mixing/mixing_data.cpp:    if (this->data != nullptr)
module_base/module_mixing/mixing_data.cpp:        free(this->data);
module_base/module_mixing/mixing_data.cpp:        this->data = malloc(ndim * length * type_size);
module_base/module_mixing/mixing_data.cpp:    this->start = -1;
module_base/module_mixing/mixing_data.cpp:    this->ndim_use = 0;
module_base/module_mixing/mixing_data.cpp:    this->ndim_history = 0;
module_base/module_mixing/mixing_data.h:        this->start = (this->start + 1) % this->ndim_tot;
module_base/module_mixing/mixing_data.h:        this->ndim_use = std::min(this->ndim_use + 1, this->ndim_tot);
module_base/module_mixing/mixing_data.h:        ++this->ndim_history;
module_base/module_mixing/mixing_data.h:        FPTYPE* FP_startdata = static_cast<FPTYPE*>(this->data) + this->start * this->length;
module_base/module_mixing/mixing_data.h:        this->ndim_use = 0;
module_base/module_mixing/mixing_data.h:        this->ndim_history = 0;
module_base/module_mixing/mixing_data.h:        this->start = -1;
module_base/module_mixing/mixing_data.h:        return (n + this->start + ndim_tot) % ndim_tot;
module_base/module_mixing/mixing_data.h:    // the start index for vector: start = this->index_move(0)
module_base/module_mixing/plain_mixing.cpp:            data_new[ig] = data_in[ig] + this->mixing_beta * (data_out[ig] - data_in[ig]);
module_base/module_mixing/plain_mixing.cpp:            data_new[i] = data_in[i] + this->mixing_beta * F_tmp[i];
module_base/module_mixing/plain_mixing.h:        this->coef = std::vector<double>(1, 1.0);
module_base/module_mixing/plain_mixing.h:        this->mixing_beta = mixing_beta;
module_base/module_mixing/plain_mixing.h:        this->tem_push_data(mdata, data_in, data_out, screen, mix, need_calcoef);
module_base/module_mixing/plain_mixing.h:        this->tem_push_data(mdata, data_in, data_out, screen, mix, need_calcoef);
module_base/module_mixing/plain_mixing.h:        this->simple_mix(data_new, data_in, data_out, length, screen);
module_base/module_mixing/plain_mixing.h:        this->simple_mix(data_new, data_in, data_out, length, screen);
module_base/module_mixing/pulay_mixing.cpp:        start_F = (this->start_F + 1) % this->mixing_ndim;
module_base/module_mixing/pulay_mixing.h:        this->mixing_ndim = mixing_ndim;
module_base/module_mixing/pulay_mixing.h:        this->data_ndim = mixing_ndim;
module_base/module_mixing/pulay_mixing.h:        this->coef = std::vector<double>(mixing_ndim);
module_base/module_mixing/pulay_mixing.h:        this->beta = ModuleBase::matrix(mixing_ndim, mixing_ndim, true);
module_base/module_mixing/pulay_mixing.h:        this->mixing_beta = mixing_beta;
module_base/module_mixing/pulay_mixing.h:        this->start_F = 0;
module_base/module_mixing/pulay_mixing.h:        this->address = nullptr;
module_base/module_mixing/pulay_mixing.h:        this->tem_push_data(mdata, data_in, data_out, screen, mix, need_calcoef);
module_base/module_mixing/pulay_mixing.h:        this->tem_push_data(mdata, data_in, data_out, screen, mix, need_calcoef);
module_base/module_mixing/test/mixing_test.cpp:        delete this->mixing;
module_base/module_mixing/test/mixing_test.cpp:            this->mixing = new Base_Mixing::Broyden_Mixing(this->mixing_ndim, this->mixing_beta);
module_base/module_mixing/test/mixing_test.cpp:            this->mixing = new Base_Mixing::Pulay_Mixing(this->mixing_ndim, this->mixing_beta);
module_base/module_mixing/test/mixing_test.cpp:            this->mixing = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_base/module_mixing/test/mixing_test.cpp:        delete this->mixing;
module_base/module_mixing/test/mixing_test.cpp:        this->mixing = nullptr;
module_base/module_mixing/test/mixing_test.cpp:        this->mixing->init_mixing_data(xdata, 3, sizeof(FPTYPE));
module_base/module_mixing/test/mixing_test.cpp:        this->niter = 0;
module_base/module_mixing/test/mixing_test.cpp:            residual = this->inner_product_mock(delta_x.data(), delta_x.data());
module_base/module_mixing/test/mixing_test.cpp:                this->mixing->push_data(
module_base/module_mixing/test/mixing_test.cpp:                    this->xdata,
module_base/module_mixing/test/mixing_test.cpp:                this->mixing->push_data(this->xdata, x_in, x_out, screen, true);
module_base/module_mixing/test/mixing_test.cpp:            this->mixing->cal_coef(this->xdata, inner_product);
module_base/module_mixing/test/mixing_test.cpp:            this->mixing->mix_data(this->xdata, x_in);
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->reset();
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->init_mixing_data(testdata, 3, sizeof(double));
module_base/module_mixing/test/mixing_test.cpp:    EXPECT_EXIT(this->mixing->push_data(testdata, x_in.data(), x_out.data(), nullptr, true),
module_base/module_mixing/test/mixing_test.cpp:    EXPECT_EXIT(this->mixing->cal_coef(testdata, ext_inner_product_mock), ::testing::ExitedWithCode(0), "");
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->reset();
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->init_mixing_data(testdata, 3, sizeof(double));
module_base/module_mixing/test/mixing_test.cpp:    EXPECT_EXIT(this->mixing->push_data(testdata, x_in.data(), x_out.data(), nullptr, true),
module_base/module_mixing/test/mixing_test.cpp:    EXPECT_EXIT(this->mixing->cal_coef(testdata, ext_inner_product_mock), ::testing::ExitedWithCode(0), "");
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->reset();
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->push_data(this->xdata, x_in.data(), x_out.data(), nullptr, true);
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->mix_data(this->xdata, x_tmp.data());
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->push_data(this->xdata, xc_in.data(), xc_out.data(), nullptr, true);
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->mix_data(this->xdata, xc_tmp.data());
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->reset();
module_base/module_mixing/test/mixing_test.cpp:    this->mixing = new Base_Mixing::Broyden_Mixing(2, 0.7);
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->init_mixing_data(nodata, 0, sizeof(double));
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->push_data(nodata, (double*)nullptr, (double*)nullptr, nullptr, false);
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->push_data(nodata, (double*)nullptr, (double*)nullptr, nullptr, false);
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->mix_data(nodata, (double*)nullptr);
module_base/module_mixing/test/mixing_test.cpp:    this->mixing->mix_data(nodata, (std::complex<double>*)nullptr);
module_base/opt_CG.cpp:    delete[] this->pb_;
module_base/opt_CG.cpp:    delete[] this->pdirect_old_;
module_base/opt_CG.cpp:    delete[] this->pgradient_old_;
module_base/opt_CG.cpp:    if (this->pb_ != nullptr)
module_base/opt_CG.cpp:        delete[] this->pb_;
module_base/opt_CG.cpp:    this->pb_ = new double[this->nx_];
module_base/opt_CG.cpp:    for (int i = 0; i < this->nx_; ++i)
module_base/opt_CG.cpp:        this->pb_[i] = pinp_b[i];
module_base/opt_CG.cpp:    this->nx_ = nx;
module_base/opt_CG.cpp:    delete[] this->pdirect_old_;
module_base/opt_CG.cpp:    delete[] this->pgradient_old_;
module_base/opt_CG.cpp:    this->pdirect_old_ = new double[this->nx_];
module_base/opt_CG.cpp:    this->pgradient_old_ = new double[this->nx_];
module_base/opt_CG.cpp:    ModuleBase::GlobalFunc::ZEROS(this->pdirect_old_, this->nx_);
module_base/opt_CG.cpp:    ModuleBase::GlobalFunc::ZEROS(this->pgradient_old_, this->nx_);
module_base/opt_CG.cpp:    this->dV_ = dV;
module_base/opt_CG.cpp:    this->iter_ = 0;
module_base/opt_CG.cpp:    this->alpha_ = 0.;
module_base/opt_CG.cpp:    this->beta_ = 0.;
module_base/opt_CG.cpp:        this->allocate(nx_new);
module_base/opt_CG.cpp:        ModuleBase::GlobalFunc::ZEROS(this->pdirect_old_, this->nx_);
module_base/opt_CG.cpp:        ModuleBase::GlobalFunc::ZEROS(this->pgradient_old_, this->nx_);
module_base/opt_CG.cpp:        this->init_b(pinp_b);
module_base/opt_CG.cpp:        this->stantard_CGdirect(pgradient, rdirect);
module_base/opt_CG.cpp:        if (this->iter_ == 0) // if iter == 0, d = -g
module_base/opt_CG.cpp:            for (int i = 0; i < this->nx_; ++i)
module_base/opt_CG.cpp:                this->pgradient_old_[i] = pgradient[i];
module_base/opt_CG.cpp:                this->pdirect_old_[i] = rdirect[i];
module_base/opt_CG.cpp:                this->PR_beta(pgradient);
module_base/opt_CG.cpp:                this->HZ_beta(pgradient);
module_base/opt_CG.cpp:            for (int i = 0; i < this->nx_; ++i)
module_base/opt_CG.cpp:                rdirect[i] = -pgradient[i] + this->beta_ * this->pdirect_old_[i];
module_base/opt_CG.cpp:                this->pgradient_old_[i] = pgradient[i];
module_base/opt_CG.cpp:                this->pdirect_old_[i] = rdirect[i];
module_base/opt_CG.cpp:        this->iter_++;
module_base/opt_CG.cpp:    double dAd = this->inner_product(pdirect, pAd, this->nx_);
module_base/opt_CG.cpp:        this->alpha_ = 0;
module_base/opt_CG.cpp:        if (this->iter_ == 1)
module_base/opt_CG.cpp:    this->alpha_ = this->gg_ / dAd;
module_base/opt_CG.cpp:    return this->alpha_;
module_base/opt_CG.cpp:    if (this->iter_ == 0)
module_base/opt_CG.cpp:        for (int i = 0; i < this->nx_; ++i)
module_base/opt_CG.cpp:            this->pgradient_old_[i] = -this->pb_[i];
module_base/opt_CG.cpp:            rdirect[i] = this->pb_[i];
module_base/opt_CG.cpp:            this->pdirect_old_[i] = this->pb_[i];
module_base/opt_CG.cpp:        std::vector<double> temp_gradient(this->nx_);
module_base/opt_CG.cpp:        for (int i = 0; i < this->nx_; ++i)
module_base/opt_CG.cpp:            temp_gradient[i] = this->pgradient_old_[i] + this->alpha_ * pAd[i];
module_base/opt_CG.cpp:        this->beta_ = this->inner_product(temp_gradient.data(), temp_gradient.data(), this->nx_) / this->gg_;
module_base/opt_CG.cpp:        Parallel_Reduce::reduce_all(this->beta_);
module_base/opt_CG.cpp:        for (int i = 0; i < this->nx_; ++i)
module_base/opt_CG.cpp:            this->pgradient_old_[i] = temp_gradient[i];
module_base/opt_CG.cpp:            rdirect[i] = -this->pgradient_old_[i] + this->beta_ * this->pdirect_old_[i];
module_base/opt_CG.cpp:            this->pdirect_old_[i] = rdirect[i];
module_base/opt_CG.cpp:    this->gg_ = this->inner_product(this->pgradient_old_, this->pgradient_old_, this->nx_);
module_base/opt_CG.cpp:    Parallel_Reduce::reduce_all(this->gg_);
module_base/opt_CG.cpp:    this->iter_++;
module_base/opt_CG.cpp:    temp_beta = this->inner_product(pgradient, pgradient, this->nx_);
module_base/opt_CG.cpp:    temp_beta -= this->inner_product(pgradient, this->pgradient_old_, this->nx_);
module_base/opt_CG.cpp:    double gg_old = this->inner_product(this->pgradient_old_, this->pgradient_old_, this->nx_);
module_base/opt_CG.cpp:    // temp_beta /= this->inner_product(this->pgradient_old_, this->pgradient_old_, this->nx_);
module_base/opt_CG.cpp:    this->beta_ = std::max(0., temp_beta);
module_base/opt_CG.cpp:    double* y = new double[this->nx_];
module_base/opt_CG.cpp:    for (int i = 0; i < this->nx_; ++i)
module_base/opt_CG.cpp:        y[i] = pgradient[i] - this->pgradient_old_[i];
module_base/opt_CG.cpp:    double py = this->inner_product(this->pdirect_old_, y, this->nx_);
module_base/opt_CG.cpp:    double yy = this->inner_product(y, y, this->nx_);
module_base/opt_CG.cpp:    double pg = this->inner_product(this->pdirect_old_, pgradient, this->nx_);
module_base/opt_CG.cpp:    double yg = this->inner_product(y, pgradient, this->nx_);
module_base/opt_CG.cpp:    double pp = this->inner_product(this->pdirect_old_, this->pdirect_old_, this->nx_);
module_base/opt_CG.cpp:    double gg = this->inner_product(this->pgradient_old_, this->pgradient_old_, this->nx_);
module_base/opt_CG.cpp:    double temp_eta = -1 / (sqrt(pp) * std::min(this->eta_, sqrt(gg)));
module_base/opt_CG.cpp:    this->beta_ = std::max(temp_beta, temp_eta);
module_base/opt_CG.h:        return sqrt(this->gg_);
module_base/opt_CG.h:        return this->iter_;
module_base/opt_CG.h:        innerproduct *= this->dV_;
module_base/opt_DCsrch.cpp:           this->ftol_,
module_base/opt_DCsrch.cpp:           this->gtol_,
module_base/opt_DCsrch.cpp:           this->xtol_,
module_base/opt_DCsrch.cpp:           this->stpmin_,
module_base/opt_DCsrch.cpp:           this->stpmax_,
module_base/opt_DCsrch.cpp:           this->isave_,
module_base/opt_DCsrch.cpp:           this->dsave_);
module_base/opt_DCsrch.h:        this->isave_ = new int[3];
module_base/opt_DCsrch.h:        this->dsave_ = new double[14];
module_base/opt_DCsrch.h:        delete[] this->isave_;
module_base/opt_DCsrch.h:        delete[] this->dsave_;
module_base/opt_DCsrch.h:        this->ftol_ = ftol;
module_base/opt_DCsrch.h:        this->gtol_ = gtol;
module_base/opt_DCsrch.h:        this->xtol_ = xtol;
module_base/opt_DCsrch.h:        this->stpmin_ = stpmin;
module_base/opt_DCsrch.h:        this->stpmax_ = stpmax;
module_base/opt_TN.hpp:        this->mach_prec_ = std::numeric_limits<double>::epsilon(); // get machine precise
module_base/opt_TN.hpp:        this->nx_ = nx;
module_base/opt_TN.hpp:        this->cg_.allocate(this->nx_);
module_base/opt_TN.hpp:        this->dV_ = dV;
module_base/opt_TN.hpp:        this->cg_.set_para(this->dV_);
module_base/opt_TN.hpp:        this->iter_ = 0;
module_base/opt_TN.hpp:            this->nx_ = nx_new;
module_base/opt_TN.hpp:        this->cg_.refresh(nx_new);
module_base/opt_TN.hpp:        return this->iter_;
module_base/opt_TN.hpp:        innerproduct *= this->dV_;
module_base/opt_TN.hpp:        double xx = this->inner_product(px, px, this->nx_);
module_base/opt_TN.hpp:        double dd = this->inner_product(pcg_direction, pcg_direction, this->nx_);
module_base/opt_TN.hpp:        epsilon = 2 * sqrt(this->mach_prec_) * (1 + sqrt(xx)) / sqrt(dd);
module_base/opt_TN.hpp:        // epsilon = 2 * sqrt(this->mach_prec_) * (1 + sqrt(this->inner_product(px, px, this->nx_)))
module_base/opt_TN.hpp:        //         / sqrt(this->inner_product(pcg_direction, pcg_direction, this->nx_));
module_base/opt_TN.hpp:    ModuleBase::GlobalFunc::ZEROS(rdirect, this->nx_); // very important
module_base/opt_TN.hpp:    double* minus_gradient = new double[this->nx_]; // b=-g, which will be used in CG
module_base/opt_TN.hpp:    double* temp_x = new double[this->nx_];         // temp_x = x + step * cg_direct, used in interpolation
module_base/opt_TN.hpp:    double* temp_gradient = new double[this->nx_];  // df(temp_x)/dx
module_base/opt_TN.hpp:    double* cg_direct = new double[this->nx_];      // rdirect += cg_alpha * cg_direct at each step
module_base/opt_TN.hpp:    double* temp_Hcgd = new double[this->nx_];      // Hessian * cg_direct
module_base/opt_TN.hpp:    for (int i = 0; i < this->nx_; ++i)
module_base/opt_TN.hpp:    ModuleBase::GlobalFunc::ZEROS(cg_direct, this->nx_);
module_base/opt_TN.hpp:    ModuleBase::GlobalFunc::ZEROS(temp_x, this->nx_);
module_base/opt_TN.hpp:    ModuleBase::GlobalFunc::ZEROS(temp_gradient, this->nx_);
module_base/opt_TN.hpp:    ModuleBase::GlobalFunc::ZEROS(temp_Hcgd, this->nx_);
module_base/opt_TN.hpp:        epsilon = this->get_epsilon(px, cg_direct);
module_base/opt_TN.hpp:        for (int i = 0; i < this->nx_; ++i)
module_base/opt_TN.hpp:        for (int i = 0; i < this->nx_; ++i)
module_base/opt_TN.hpp:            for (int i = 0; i < this->nx_; ++i)
module_base/opt_TN.hpp:        for (int i = 0; i < this->nx_; ++i)
module_base/opt_TN.hpp:    this->iter_++;
module_base/realarray.cpp:	this->size = cd.getSize();
module_base/realarray.cpp:	this->ptr = new double[size];
module_base/realarray.cpp:		this->ptr[i] = cd.ptr[i];
module_base/realarray.cpp:	this->dim = cd.dim;
module_base/realarray.cpp:	this->bound1 = cd.bound1;
module_base/realarray.cpp:	this->bound2 = cd.bound2;
module_base/realarray.cpp:	this->bound3 = cd.bound3;
module_base/realarray.cpp:	this->bound4 = cd.bound4;
module_base/sph_bessel_recursive-d1.cpp:			const double smallx_range = pow( this->threshold/coeff*(l+1.5)*4, 1.0/(l+2) );
module_base/sph_bessel_recursive-d2.cpp:		const double smallx_range = pow( this->threshold/coeff*(l+1.5)*4, 1.0/(l+2) );
module_base/spherical_bessel_transformer.h:    inline bool operator==(SphericalBesselTransformer const& rhs) const { return this->impl_ == rhs.impl_; }
module_base/test/global_file_test.cpp:		GlobalV::MY_RANK and this->out_alllog.
module_base/test/gram_schmidt_orth_test.cpp:        if (ModuleBase::Gram_Schmidt_Orth<double,double>::Coordinate::Sphere == this->coordinate)
module_base/test/math_chebyshev_test.cpp:            if(this->LDA < 2) this->LDA=2;
module_base/test/math_chebyshev_test.cpp:            if(this->LDA < 2) this->LDA=2;
module_base/test/opt_test_tools.cpp:    A = new double*[this->nx];
module_base/test/opt_test_tools.cpp:    for (int i = 0; i < this->nx; ++i) 
module_base/test/opt_test_tools.cpp:        A[i] = new double[this->nx];
module_base/test/opt_test_tools.cpp:    b = new double[this->nx];
module_base/test/opt_test_tools.cpp:    b[0] = 1; b[1] = 2; b[2] = this->nx;
module_base/test/opt_test_tools.cpp:    for (int i = 0; i < this->nx; ++i)
module_base/test/opt_test_tools.cpp:    for (int i = 0; i < this->nx; ++i)
module_base/test/opt_test_tools.cpp:    double *Ax = new double[this->nx];
module_base/test/opt_test_tools.cpp:    this->get_Ap(A, x, Ax, this->nx, this->nx);
module_base/test/opt_test_tools.cpp:    for (int i = 0; i < this->nx; ++i)
module_base/test/opt_test_tools.cpp:    double *Ax = new double[this->nx];
module_base/test/opt_test_tools.cpp:    this->get_Ap(A, x, Ax, this->nx, this->nx);
module_base/test/opt_test_tools.cpp:    for (int i = 0; i < this->nx; ++i)
module_base/test/opt_test_tools.cpp:    double *Ax = new double[this->nx];
module_base/test/opt_test_tools.cpp:    get_Ap(A, x, Ax, this->nx, this->nx);
module_base/test/opt_test_tools.cpp:    for (int i = 0; i < this->nx; ++i)
module_base/test/opt_test_tools.h:        this->nx = le.nx;
module_base/test/realarray_test.cpp:	//std::cout<< &a3 << &(this->a3) <<std::endl;
module_basis/module_ao/ORB_atomic.cpp:	this->nchi = nullptr;
module_basis/module_ao/ORB_atomic.cpp:	this->phiLN = new Numerical_Orbital_Lm[1];
module_basis/module_ao/ORB_atomic.cpp:	this->rcut = 0.0;
module_basis/module_ao/ORB_atomic.cpp:	this->max_nchi = 0;
module_basis/module_ao/ORB_atomic.cpp:	this->type = 0;
module_basis/module_ao/ORB_atomic.cpp:	this->type = type_in;
module_basis/module_ao/ORB_atomic.cpp:	this->label = label_in;
module_basis/module_ao/ORB_atomic.cpp:	this->lmax = lmax_in;
module_basis/module_ao/ORB_atomic.cpp:	delete[] this->nchi;
module_basis/module_ao/ORB_atomic.cpp:	this->nchi = new int[this->lmax+1];
module_basis/module_ao/ORB_atomic.cpp:	for (int i = 0; i < this->lmax + 1; i++)
module_basis/module_ao/ORB_atomic.cpp:		this->nchi[i] = nchi_in[i];
module_basis/module_ao/ORB_atomic.cpp:		this->total_nchi = total_nchi_in;
module_basis/module_ao/ORB_atomic.cpp:	this->rcut = 0.0;
module_basis/module_ao/ORB_atomic.cpp:		this->rcut = this->phiLN[i].rcut;
module_basis/module_ao/ORB_atomic.cpp:			assert( rcut == this->phiLN[j].rcut );
module_basis/module_ao/ORB_atomic.cpp:	this->max_nchi=0;
module_basis/module_ao/ORB_atomic.cpp:	this->find_chi.create( lmax+1, max_nchi );
module_basis/module_ao/ORB_atomic.h:	const int& getLmax() const { return this->lmax; }
module_basis/module_ao/ORB_atomic.h:	const double& getRcut () const {return this->rcut; }
module_basis/module_ao/ORB_atomic.h:   	const int& getType() const { return this->type; }
module_basis/module_ao/ORB_atomic.h:	const int& getTotal_nchi() const { return this->total_nchi; }
module_basis/module_ao/ORB_atomic.h:	const int& getNchi(const int l) const { return this->nchi[l]; }
module_basis/module_ao/ORB_atomic.h:	const std::string& getLabel() const { return this->label; }
module_basis/module_ao/ORB_atomic.h:		return this->phiLN[ this->find_chi(L, N) ];
module_basis/module_ao/ORB_atomic.h:	Numerical_Orbital_Lm*& chi() { return this->phiLN; }
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psi[ir] = psi_in[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psir[ir] = psi[ir] * r_radial[ir]; //mohan 2010-04-19
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psif[ik] = psi_in[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psik[ik] = psif[ik] * k_radial[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psik2[ik] = psik[ik] * k_radial[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psik[ik] = psi_in[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psik2[ik] = psik[ik] * k_radial[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psik2[ik] = psi_in[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:			 	this->cal_rradial_sbpool();
module_basis/module_ao/ORB_atomic_lm.cpp:		this->extra_uniform(dr_uniform, force_flag);
module_basis/module_ao/ORB_atomic_lm.cpp:		this->use_uniform(dr_uniform);
module_basis/module_ao/ORB_atomic_lm.cpp:	this->extra_uniform(dr_uniform, force_flag);
module_basis/module_ao/ORB_atomic_lm.cpp:			 	this->cal_kradial_sbpool();
module_basis/module_ao/ORB_atomic_lm.cpp:				this->cal_kradial();
module_basis/module_ao/ORB_atomic_lm.cpp://	this->norm_test();						// Peize Lin delete 2016-08-31
module_basis/module_ao/ORB_atomic_lm.cpp:		this->plot();			// Peize Lin add flag_plot 2016-08-31
module_basis/module_ao/ORB_atomic_lm.cpp:    this->label = label_in;
module_basis/module_ao/ORB_atomic_lm.cpp:    this->index_atom_type = index_atom_type_in;
module_basis/module_ao/ORB_atomic_lm.cpp:    this->angular_momentum_l = angular_momentum_l_in;
module_basis/module_ao/ORB_atomic_lm.cpp:    this->index_chi = index_chi_in;
module_basis/module_ao/ORB_atomic_lm.cpp:    this->nr = nr_in;
module_basis/module_ao/ORB_atomic_lm.cpp:    this->rcut = r_radial_in[nr-1];
module_basis/module_ao/ORB_atomic_lm.cpp:    this->nk = nk_in;
module_basis/module_ao/ORB_atomic_lm.cpp:    this->dk = dk_in;
module_basis/module_ao/ORB_atomic_lm.cpp:	this->dr_uniform=dr_uniform_in;
module_basis/module_ao/ORB_atomic_lm.cpp://	this->dk = ModuleBase::PI / rcut / 2.0;
module_basis/module_ao/ORB_atomic_lm.cpp://	this->nk = this->nr;
module_basis/module_ao/ORB_atomic_lm.cpp:		this->r_radial[ir] = r_radial_in[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:		this->rab[ir] = rab_in[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:		this->k_radial[ik] = ik * this->dk;
module_basis/module_ao/ORB_atomic_lm.cpp:	this->kcut = (nk-1) * this->dk;
module_basis/module_ao/ORB_atomic_lm.cpp:	this->dr_uniform = dr_uniform_in;
module_basis/module_ao/ORB_atomic_lm.cpp:	this->nr_uniform = static_cast<int>(rcut/dr_uniform) + 10;
module_basis/module_ao/ORB_atomic_lm.cpp:	this->psi_uniform.resize(nr_uniform,0);
module_basis/module_ao/ORB_atomic_lm.cpp:	for (int ir = 0; ir < this->nr_uniform; ir++)
module_basis/module_ao/ORB_atomic_lm.cpp:		ModuleBase::Mathzone_Add1::Uni_RadialF(ModuleBase::GlobalFunc::VECTOR_TO_PTR(this->psi), this->nr, this->rab[0], ir * dr_uniform); 
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psi_uniform[ir] = psi_uniform_tmp;
module_basis/module_ao/ORB_atomic_lm.cpp://    	this->psi_uniform[ir] = ModuleBase::Mathzone::Polynomial_Interpolation(this->psi, this->nr, this->rab[0], ir * dr_uniform); 
module_basis/module_ao/ORB_atomic_lm.cpp:	this->dpsi_uniform.resize(this->nr_uniform);
module_basis/module_ao/ORB_atomic_lm.cpp:	this->ddpsi_uniform.resize(this->nr_uniform);
module_basis/module_ao/ORB_atomic_lm.cpp:	//double yp1=(this->psi[1]-this->psi[0])/this->r_radial[1];
module_basis/module_ao/ORB_atomic_lm.cpp:	//std::cout<<"psi0="<<"  "<<this->psi[0]<<"  "<<"psi1="<<"  "<<this->psi[1]<<"  "<<"r1="<<"  "<<this->r_radial[1]<<std::endl; 
module_basis/module_ao/ORB_atomic_lm.cpp:	switch( this->angular_momentum_l ) // added by pengfei 13-8-8 different l has different  boundary conditions 
module_basis/module_ao/ORB_atomic_lm.cpp:	//std::cout<<"angular_momentum_l="<<"  "<<this->angular_momentum_l<<std::endl;
module_basis/module_ao/ORB_atomic_lm.cpp:			ModuleBase::GlobalFunc::VECTOR_TO_PTR(this->psi_uniform), 
module_basis/module_ao/ORB_atomic_lm.cpp:			this->nr_uniform, 
module_basis/module_ao/ORB_atomic_lm.cpp:		this->zty = tmp[0]/ModuleBase::Mathzone_Add1::factorial (angular_momentum_l);
module_basis/module_ao/ORB_atomic_lm.cpp:	this->dr_uniform = dr_uniform_in;
module_basis/module_ao/ORB_atomic_lm.cpp:	this->nr_uniform = static_cast<int>(rcut/dr_uniform)+10;
module_basis/module_ao/ORB_atomic_lm.cpp:	this->psi_uniform.resize(nr_uniform,0);
module_basis/module_ao/ORB_atomic_lm.cpp:	if( 0==this->angular_momentum_l )
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 1==this->angular_momentum_l )
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 2==this->angular_momentum_l )
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 3<=this->angular_momentum_l && this->angular_momentum_l<=6 )
module_basis/module_ao/ORB_atomic_lm.cpp:		orbital_type = 'f'+this->angular_momentum_l-3;
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 7<=this->angular_momentum_l && this->angular_momentum_l<=11 )
module_basis/module_ao/ORB_atomic_lm.cpp:		orbital_type = 'k'+this->angular_momentum_l-7;
module_basis/module_ao/ORB_atomic_lm.cpp:		orbital_type = "L" + ModuleBase::GlobalFunc::TO_STRING(this->angular_momentum_l);
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psi_uniform[i] = 
module_basis/module_ao/ORB_atomic_lm.cpp:			ModuleBase::Mathzone_Add1::Uni_RadialF(ModuleBase::GlobalFunc::VECTOR_TO_PTR(psi), this->nr, this->rab[0], i*dr_uniform); 
module_basis/module_ao/ORB_atomic_lm.cpp:	this->dpsi_uniform.resize(nr_uniform);
module_basis/module_ao/ORB_atomic_lm.cpp:		ss << GlobalV::global_out_dir << this->label << "/"
module_basis/module_ao/ORB_atomic_lm.cpp:			<< this->label << "-" << orbital_type << ".ORBITAL_NOR_uniform.txt";
module_basis/module_ao/ORB_atomic_lm.cpp:	assert( this->nr > 0);
module_basis/module_ao/ORB_atomic_lm.cpp:	assert( this->nr_uniform > 0);
module_basis/module_ao/ORB_atomic_lm.cpp:							psi_uniform, 0, this->psik);
module_basis/module_ao/ORB_atomic_lm.cpp:	for (int ik = 0; ik < nk; ik++) this->psik[ik] *= (pref*k_radial[ik]);
module_basis/module_ao/ORB_atomic_lm.cpp:				this->nr, 
module_basis/module_ao/ORB_atomic_lm.cpp:				ModuleBase::GlobalFunc::VECTOR_TO_PTR(this->r_radial), 
module_basis/module_ao/ORB_atomic_lm.cpp:				this->k_radial[ik], 
module_basis/module_ao/ORB_atomic_lm.cpp:				this->angular_momentum_l, 
module_basis/module_ao/ORB_atomic_lm.cpp:			integrated_func[ir] = this->psir[ir] * this->r_radial[ir] * jl[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->nr,
module_basis/module_ao/ORB_atomic_lm.cpp:				ModuleBase::GlobalFunc::VECTOR_TO_PTR(this->rab),
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psif[ik]);
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psif[ik] *= pref;
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psik[ik] = this->psif[ik] * k_radial[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psik2[ik] = this->psik[ik] * k_radial[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:	assert( this->nr > 0);
module_basis/module_ao/ORB_atomic_lm.cpp:	assert( this->nr_uniform > 0);
module_basis/module_ao/ORB_atomic_lm.cpp:	const double dr = this->rab[0];
module_basis/module_ao/ORB_atomic_lm.cpp:	for( size_t ir=1; ir<this->nr; ++ir )
module_basis/module_ao/ORB_atomic_lm.cpp:		assert( dr == this->rab[ir] );
module_basis/module_ao/ORB_atomic_lm.cpp:		if( this->dk * dr == sb.get_dx() )
module_basis/module_ao/ORB_atomic_lm.cpp:	pSB->set_dx( this->dk * dr );
module_basis/module_ao/ORB_atomic_lm.cpp:	pSB->cal_jlx( this->angular_momentum_l, this->nk, this->nr );
module_basis/module_ao/ORB_atomic_lm.cpp:	const std::vector<std::vector<double>> &jl = pSB->get_jlx()[this->angular_momentum_l];
module_basis/module_ao/ORB_atomic_lm.cpp:	std::vector<double> integrated_func( this->nr );
module_basis/module_ao/ORB_atomic_lm.cpp:		psir2[ir] = this->psir[ir] * this->r_radial[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:				this->nr,
module_basis/module_ao/ORB_atomic_lm.cpp:				this->psik[ik]);
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psik[ik] *= ( pref * k_radial[ik]);
module_basis/module_ao/ORB_atomic_lm.cpp:	assert( this->nr > 0);
module_basis/module_ao/ORB_atomic_lm.cpp:	assert( this->nr_uniform > 0);
module_basis/module_ao/ORB_atomic_lm.cpp:	const double dr = this->rab[0];
module_basis/module_ao/ORB_atomic_lm.cpp:	for( int ir=1; ir<this->nr; ++ir )
module_basis/module_ao/ORB_atomic_lm.cpp:		assert( dr == this->rab[ir] );
module_basis/module_ao/ORB_atomic_lm.cpp:		if( this->dk * dr == sb.get_dx() )
module_basis/module_ao/ORB_atomic_lm.cpp:	pSB->set_dx( this->dk * dr );
module_basis/module_ao/ORB_atomic_lm.cpp:	pSB->cal_jlx( this->angular_momentum_l, this->nk, this->nr );
module_basis/module_ao/ORB_atomic_lm.cpp:	const std::vector<std::vector<double>> &jl = pSB->get_jlx()[this->angular_momentum_l];
module_basis/module_ao/ORB_atomic_lm.cpp:		r_tmp[ir] = this->psir[ir] * this->r_radial[ir] * this->rab[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:		pref * BlasConnector::dot( this->nr, ModuleBase::GlobalFunc::VECTOR_TO_PTR(r_tmp), 1, ModuleBase::GlobalFunc::VECTOR_TO_PTR(jl[ik]), 1 ) ;
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psif[ik] = psi_f_tmp;
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psik[ik] = psi_f_tmp * k_radial[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psik2[ik] = this->psik[ik] * k_radial[ik];
module_basis/module_ao/ORB_atomic_lm.cpp:	const double dr = this->rab[0];
module_basis/module_ao/ORB_atomic_lm.cpp:	for( int ir=1; ir<this->nr; ++ir )
module_basis/module_ao/ORB_atomic_lm.cpp:		assert( dr == this->rab[ir] );
module_basis/module_ao/ORB_atomic_lm.cpp:	pSB->cal_jlx( this->angular_momentum_l, this->nr, this->nk );
module_basis/module_ao/ORB_atomic_lm.cpp:	const std::vector<std::vector<double>> &jl = pSB->get_jlx()[this->angular_momentum_l];
module_basis/module_ao/ORB_atomic_lm.cpp:		k_tmp[ik] = this->psik2[ik] * dk;
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psi[ir] = pref * kj_dot;
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psi[ir] = pref * BlasConnector::dot( this->nk, ModuleBase::GlobalFunc::VECTOR_TO_PTR(k_tmp), 1, ModuleBase::GlobalFunc::VECTOR_TO_PTR(jl[ir]), 1 );
module_basis/module_ao/ORB_atomic_lm.cpp:		this->psir[ir] = this->psi[ir] * r_radial[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:		f[ir] = this->psir[ir] * this->psir[ir];
module_basis/module_ao/ORB_atomic_lm.cpp:	ModuleBase::Integral::Simpson_Integral(this->nr, f, ModuleBase::GlobalFunc::VECTOR_TO_PTR(this->rab), sumr);
module_basis/module_ao/ORB_atomic_lm.cpp:		f[ik] = this->psik[ik] * this->psik[ik];
module_basis/module_ao/ORB_atomic_lm.cpp://	ModuleBase::Integral::Simpson_Integral(this->nk, f, this->k_radial, sumk);
module_basis/module_ao/ORB_atomic_lm.cpp:	if( 0==this->angular_momentum_l )
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 1==this->angular_momentum_l )
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 2==this->angular_momentum_l )
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 3<=this->angular_momentum_l && this->angular_momentum_l<=6 )
module_basis/module_ao/ORB_atomic_lm.cpp:		orbital_type = 'f' + this->angular_momentum_l - 3;
module_basis/module_ao/ORB_atomic_lm.cpp:	else if( 7<=this->angular_momentum_l && this->angular_momentum_l<=11 )
module_basis/module_ao/ORB_atomic_lm.cpp:		orbital_type = 'k' + this->angular_momentum_l - 7;
module_basis/module_ao/ORB_atomic_lm.cpp:		orbital_type = "L" + ModuleBase::GlobalFunc::TO_STRING(this->angular_momentum_l);	
module_basis/module_ao/ORB_atomic_lm.cpp:		ssr << GlobalV::global_out_dir << this->label << "/"
module_basis/module_ao/ORB_atomic_lm.cpp:			<< this->label << "-"<< orbital_type << index_chi+1 << "-orbital-r.dat";
module_basis/module_ao/ORB_atomic_lm.cpp:		ssk << GlobalV::global_out_dir << this->label << "/"
module_basis/module_ao/ORB_atomic_lm.cpp:			<< this->label << "-" << orbital_type << index_chi+1 << "-orbital-k.dat";
module_basis/module_ao/ORB_atomic_lm.cpp:		ssru << GlobalV::global_out_dir << this->label << "/"
module_basis/module_ao/ORB_atomic_lm.cpp:			<< this->label << "-" << orbital_type << index_chi+1 << "-orbital-ru.dat";
module_basis/module_ao/ORB_atomic_lm.cpp:		ssdru << GlobalV::global_out_dir << this->label << "/"  // 2013-08-10 pengfei
module_basis/module_ao/ORB_atomic_lm.cpp:			<< this->label << "-" << orbital_type << index_chi+1 << "-orbital-dru.dat";
module_basis/module_ao/ORB_atomic_lm.cpp:		for (int i = 0; i < this->nr; i++)
module_basis/module_ao/ORB_atomic_lm.cpp:			ofsr << this->r_radial[i] << " " << psi[i] << std::endl;
module_basis/module_ao/ORB_atomic_lm.cpp:		for (int i = 0; i < this->nk; i++)
module_basis/module_ao/ORB_atomic_lm.cpp:			ofsk << this->k_radial[i] << " " << psik[i] << std::endl;
module_basis/module_ao/ORB_atomic_lm.cpp:		for (int i = 0; i < this->nr_uniform; i++)
module_basis/module_ao/ORB_atomic_lm.cpp:			ofsru << this->dr_uniform * i << " " << psi_uniform[i] << std::endl;
module_basis/module_ao/ORB_atomic_lm.cpp:		for (int i = 0; i < this->nr_uniform; i++)
module_basis/module_ao/ORB_atomic_lm.cpp:			ofsdru << this->dr_uniform * i << " " << dpsi_uniform[i] << std::endl;// output dphi/dr 2013-08-10  pengfei
module_basis/module_ao/ORB_control.cpp:    this->ParaV.nspin = nspin_in;
module_basis/module_ao/ORB_control.cpp:        this->divide_HS_2d(DIAG_WORLD, ofs_running, ofs_warning);
module_basis/module_ao/ORB_control.cpp:        this->ParaV.nloc = nlocal * nlocal;
module_basis/module_ao/ORB_control.cpp:    this->ParaV.set_global2local(nlocal, nlocal, div_2d, ofs_running);
module_basis/module_ao/ORB_control.cpp:    Parallel_Orbitals* pv = &this->ParaV;
module_basis/module_ao/ORB_control.cpp:    Parallel_Orbitals* pv = &this->ParaV;
module_basis/module_ao/ORB_control.cpp:    this->set_parameters(ofs_running, ofs_warning);
module_basis/module_ao/ORB_control.cpp:    this->set_parameters(ofs_running, ofs_warning);
module_basis/module_ao/ORB_control.cpp:        ModuleBase::GlobalFunc::OUT(ofs_running, "this->nrow", pv->nrow);
module_basis/module_ao/ORB_control.cpp:        ModuleBase::GlobalFunc::OUT(ofs_running, "this->ncol", pv->ncol);
module_basis/module_ao/ORB_gaunt_table.cpp:	this->Gaunt_Coefficients.create(nlm, nlm, nlm);
module_basis/module_ao/ORB_gaunt_table.cpp:            const int dim = this->get_lm_index(L,m);
module_basis/module_ao/ORB_gaunt_table.cpp:                    const int dim1 = this->get_lm_index(L1,m1);
module_basis/module_ao/ORB_gaunt_table.cpp:                            const int dim2 = this->get_lm_index(L2,m2);
module_basis/module_ao/ORB_gaunt_table.cpp:								this->Get_Gaunt_SH (L1, m1, L2, m2, L, m);	
module_basis/module_ao/ORB_gaunt_table.cpp:			          this->Ylm_Gaunt( this->get_lm_index(L1, m1), 16 * i + j) *
module_basis/module_ao/ORB_gaunt_table.cpp:			          this->Ylm_Gaunt( this->get_lm_index(L2, m2), 16 * i + j) *
module_basis/module_ao/ORB_gaunt_table.cpp:			          this->Ylm_Gaunt( this->get_lm_index(L,  m), 16 * i + j);
module_basis/module_ao/ORB_gaunt_table.cpp:	this->Ylm_Gaunt.create(nlm , 256);
module_basis/module_ao/ORB_gaunt_table.cpp:	ModuleBase::YlmReal::Ylm_Real(nlm, 256, &g_gaunt[0], this->Ylm_Gaunt);
module_basis/module_ao/ORB_gaunt_table.cpp:	//int Np = this->P_EL(L);
module_basis/module_ao/ORB_gaunt_table.cpp:	int Eff_Np = this->EP_EL(L);
module_basis/module_ao/ORB_gen_tables.cpp:	const ModuleBase::Vector3<double> dRa = (R0 - R1) * this->lat0;
module_basis/module_ao/ORB_gen_tables.cpp:					//double tmpGaunt = this->MGT.Get_Gaunt_SH(L1, m1, L0, m0, L, m);
module_basis/module_ao/ORB_gen_tables.cpp:						tmpGaunt = this->MGT.Gaunt_Coefficients(gindex1, gindex0, gindexa);
module_basis/module_ao/ORB_gen_tables.cpp:						tmpGaunt1= this->MGT.Gaunt_Coefficients(gindex0, gindex1, gindexa);
module_basis/module_ao/ORB_gen_tables.cpp:						tmpGaunt = this->MGT.Gaunt_Coefficients(gindex0, gindex1, gindexa);
module_basis/module_ao/ORB_gen_tables.cpp:	assert(this->lat0 > 0.0);
module_basis/module_ao/ORB_gen_tables.cpp:	double distance = noar.get_distance() * this->lat0;
module_basis/module_ao/ORB_gen_tables.cpp:	const int rmesh = this->MOT.get_rmesh(Rcut1, Rcut2);	//caoyu modified 2021-05-08
module_basis/module_ao/ORB_gen_tables.cpp:	int dim1 = this->MOT.OV_Tpair(T1, T2);
module_basis/module_ao/ORB_gen_tables.cpp:	int dim3 = this->MOT.OV_L2plus1(T1, T2); //2*lmax+1
module_basis/module_ao/ORB_gen_tables.cpp:		dim2 = this->MOT.OV_Opair(dim1, L1, L2, N1, N2);
module_basis/module_ao/ORB_gen_tables.cpp:		dim2 = this->MOT.OV_Opair(dim1, L2, L1, N2, N1);
module_basis/module_ao/ORB_gen_tables.cpp:	arr_dR[0] = noar.getX() * this->lat0;
module_basis/module_ao/ORB_gen_tables.cpp:	arr_dR[1] = noar.getY() * this->lat0;
module_basis/module_ao/ORB_gen_tables.cpp:	arr_dR[2] = noar.getZ() * this->lat0;
module_basis/module_ao/ORB_gen_tables.cpp:	assert(this->lat0 > 0.0);
module_basis/module_ao/ORB_gen_tables.cpp:	return dR.norm() * this->lat0;
module_basis/module_ao/ORB_gen_tables.cpp:	const ModuleBase::Vector3<double> dRa = (R0 - R1) * this->lat0;
module_basis/module_ao/ORB_gen_tables.cpp:						//double tmpGaunt = this->MGT.Get_Gaunt_SH(L1, m1, L0, m0, L, m);
module_basis/module_ao/ORB_gen_tables.cpp:							tmpGaunt = this->MGT.Gaunt_Coefficients(gindex1, gindex0, gindexa);
module_basis/module_ao/ORB_gen_tables.cpp:							tmpGaunt1= this->MGT.Gaunt_Coefficients(gindex0, gindex1, gindexa);
module_basis/module_ao/ORB_gen_tables.cpp:							tmpGaunt = this->MGT.Gaunt_Coefficients(gindex0, gindex1, gindexa);
module_basis/module_ao/ORB_nonlocal.cpp:	this->type = 0;
module_basis/module_ao/ORB_nonlocal.cpp:	this->lmax = 0;
module_basis/module_ao/ORB_nonlocal.cpp:	this->Proj = new Numerical_Nonlocal_Lm[1];
module_basis/module_ao/ORB_nonlocal.cpp:	this->nproj = -1;
module_basis/module_ao/ORB_nonlocal.cpp:	this->type = type_in;
module_basis/module_ao/ORB_nonlocal.cpp:	this->label = label_in;
module_basis/module_ao/ORB_nonlocal.cpp:	this->type_ps = type_ps_in;
module_basis/module_ao/ORB_nonlocal.cpp:	this->lmax = lmax_in;
module_basis/module_ao/ORB_nonlocal.cpp:	this->nproj = nproj_in;
module_basis/module_ao/ORB_nonlocal.cpp:	this->Proj = new Numerical_Nonlocal_Lm[this->nproj];
module_basis/module_ao/ORB_nonlocal.cpp:		this->Proj[p1] = Proj_in[p1];
module_basis/module_ao/ORB_nonlocal.cpp:	this->rcut_max = 0.0;
module_basis/module_ao/ORB_nonlocal.cpp:		this->rcut_max = std::max( this->Proj[p1].getRcut(), rcut_max ); 
module_basis/module_ao/ORB_nonlocal.h:	const int& getLmax() const { return this->lmax; }
module_basis/module_ao/ORB_nonlocal.h:   	const int& getType() const { return this->type; }
module_basis/module_ao/ORB_nonlocal.h:	const std::string& getLabel() const { return this->label; }
module_basis/module_ao/ORB_nonlocal.h:	const std::string& getType_ps() const { return this->type_ps; }
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->renew();
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->freemem();
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->r_radial = new double[nr];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->rab = new double[nr];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->beta_r = new double[nr];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->beta_uniform = new double[nr_uniform];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->dbeta_uniform = new double[nr_uniform];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->k_radial = new double[nk];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->beta_k = new double[nk];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->r_radial;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->rab;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->beta_r;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->beta_uniform;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->dbeta_uniform;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->k_radial;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->beta_k;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->label = nol.label;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->index_atom_type = nol.index_atom_type;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->angular_momentum_l = nol.angular_momentum_l;
module_basis/module_ao/ORB_nonlocal_lm.cpp:    this->index_proj = nol.index_proj;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->nr = nol.nr;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->nk = nol.nk;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->nr_uniform = nol.nr_uniform;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->dr_uniform = nol.dr_uniform;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->rcut = nol.rcut;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->kcut = nol.kcut;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->dk = nol.dk;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->freemem();
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->renew();
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->r_radial[ir] = nol.r_radial[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->rab[ir] = nol.rab[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->beta_r[ir] = nol.beta_r[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->beta_uniform[ir] = nol.beta_uniform[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->dbeta_uniform[ir] = nol.dbeta_uniform[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->k_radial[ik] = nol.k_radial[ik];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->beta_k[ik] = nol.beta_k[ik];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->label = label_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->index_atom_type = index_atom_type_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->angular_momentum_l = angular_momentum_l_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->dr_uniform = dr_uniform_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->nr = nr_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->rcut = r_radial_in[nr-1];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->nk = nk_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->dk = dk_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:    this->freemem();
module_basis/module_ao/ORB_nonlocal_lm.cpp:    this->renew();
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->r_radial[ir] = r_radial_in[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->rab[ir] = rab_in[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->beta_r[ir] = beta_r_in[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->k_radial[ik] = ik * this->dk;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->kcut = (nk-1) * this->dk;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	//this->extra_uniform(dr_uniform);
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->get_kradial();
module_basis/module_ao/ORB_nonlocal_lm.cpp:// beta[ir] = this->beta_r[ir]/r_radial[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->dr_uniform = dr_uniform_in;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->nr_uniform = static_cast<int>(rcut/dr_uniform) + 10;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->beta_uniform;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->beta_uniform = new double[nr_uniform];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	ModuleBase::GlobalFunc::ZEROS (this->beta_uniform, nr_uniform);
module_basis/module_ao/ORB_nonlocal_lm.cpp:		beta[ir] = this->beta_r[ir]/r_radial[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	for (int ir = 0; ir < this->nr_uniform; ir++)
module_basis/module_ao/ORB_nonlocal_lm.cpp:		this->beta_uniform[ir] = ModuleBase::PolyInt::Polynomial_Interpolation_xy(this->r_radial, beta, this->nr, rnew); 
module_basis/module_ao/ORB_nonlocal_lm.cpp:	delete[] this->dbeta_uniform;
module_basis/module_ao/ORB_nonlocal_lm.cpp:	this->dbeta_uniform = new double[nr_uniform];
module_basis/module_ao/ORB_nonlocal_lm.cpp:	ModuleBase::GlobalFunc::ZEROS(this->dbeta_uniform, nr_uniform);
module_basis/module_ao/ORB_nonlocal_lm.cpp:                this->nr,
module_basis/module_ao/ORB_nonlocal_lm.cpp:                this->r_radial,
module_basis/module_ao/ORB_nonlocal_lm.cpp:                this->k_radial[ik],
module_basis/module_ao/ORB_nonlocal_lm.cpp:                this->angular_momentum_l,
module_basis/module_ao/ORB_nonlocal_lm.cpp:            integrated_func[ir] = this->beta_r[ir] * this->r_radial[ir] * jl[ir];
module_basis/module_ao/ORB_nonlocal_lm.cpp:                this->nr,
module_basis/module_ao/ORB_nonlocal_lm.cpp:                this->rab,
module_basis/module_ao/ORB_nonlocal_lm.cpp:                this->beta_k[ik]);
module_basis/module_ao/ORB_nonlocal_lm.cpp:        this->beta_k[ik] *= ( pref*k_radial[ik]);
module_basis/module_ao/ORB_nonlocal_lm.cpp:	switch( this->angular_momentum_l )
module_basis/module_ao/ORB_nonlocal_lm.cpp:		ssr << GlobalV::global_out_dir << this->label << "/"
module_basis/module_ao/ORB_nonlocal_lm.cpp:			<< this->label << "-" << orbital_type << "-proj-r.dat";
module_basis/module_ao/ORB_nonlocal_lm.cpp:		ssk << GlobalV::global_out_dir << this->label << "/"
module_basis/module_ao/ORB_nonlocal_lm.cpp:			<< this->label << "-" << orbital_type << "-proj-k.dat";
module_basis/module_ao/ORB_nonlocal_lm.cpp:		ssru << GlobalV::global_out_dir << this->label << "/"
module_basis/module_ao/ORB_nonlocal_lm.cpp:			<< this->label << "-" << orbital_type << "-proj-ru.dat";
module_basis/module_ao/ORB_nonlocal_lm.cpp:		for (int i = 0; i < this->nr; i++)
module_basis/module_ao/ORB_nonlocal_lm.cpp:			ofsr << this->r_radial[i] << " " << this->beta_r[i] << std::endl;
module_basis/module_ao/ORB_nonlocal_lm.cpp:		for (int i = 0; i < this->nk; i++)
module_basis/module_ao/ORB_nonlocal_lm.cpp:			ofsk << this->k_radial[i] << " " << this->beta_k[i] << std::endl;
module_basis/module_ao/ORB_nonlocal_lm.cpp:		for (int i = 0; i < this->nr_uniform; i++)
module_basis/module_ao/ORB_nonlocal_lm.cpp:			ofsru << i * this->dr_uniform << " " << this->beta_uniform[i] << std::endl;
module_basis/module_ao/ORB_nonlocal_lm.h:	const int& getL() const { return this->angular_momentum_l; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const int& getType() const { return this->index_atom_type; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double& getRcut() const { return this->rcut; }
module_basis/module_ao/ORB_nonlocal_lm.h:    const int& getNr() const { return this->nr; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double* getRadial() const { return this->r_radial; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double& getRadial(const int &ir) const { return this->r_radial[ir]; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double* getBeta_r() const { return this->beta_r; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double& getBeta_r(const int &ir) const { return this->beta_r[ir]; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double& getDk()const { return this->dk; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double* getKpoint()const { return this->k_radial; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double& getKpoint(const int &ik) const { return this->k_radial[ik]; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double* getBeta_k() const { return this->beta_k; }
module_basis/module_ao/ORB_nonlocal_lm.h:	const double& getBeta_k(const int &ik) const { return this->beta_k[ik]; }
module_basis/module_ao/ORB_read.cpp:	this->nchimax = 0;// this initialzied must specified
module_basis/module_ao/ORB_read.cpp:	this->Phi = new Numerical_Orbital[1];	
module_basis/module_ao/ORB_read.cpp:	this->Alpha = new Numerical_Orbital[1];
module_basis/module_ao/ORB_read.cpp:	this->read_in_flag = false;	
module_basis/module_ao/ORB_read.cpp:	this->dr_uniform = 0.001;
module_basis/module_ao/ORB_read.cpp:	this->lmax_d = 0;
module_basis/module_ao/ORB_read.cpp:    this->nchimax_d = 0;
module_basis/module_ao/ORB_read.cpp:    this->rcutmax_Phi = 0.0;
module_basis/module_ao/ORB_read.cpp:	this->ntype = ntype_in; 
module_basis/module_ao/ORB_read.cpp:	this->lmax = lmax_in;
module_basis/module_ao/ORB_read.cpp:		this->kmesh = static_cast<int>( 2 * sqrt(ecutwfc) / dk )  + 4;
module_basis/module_ao/ORB_read.cpp:		this->kmesh = static_cast<int>( sqrt(ecutwfc) / dk )  + 4;
module_basis/module_ao/ORB_read.cpp:	//	this->kmesh = static_cast<int> (PI / 0.01 / 4 / this->dk);
module_basis/module_ao/ORB_read.cpp:	delete[] this->Phi;
module_basis/module_ao/ORB_read.cpp:	this->Phi = new Numerical_Orbital[ntype];
module_basis/module_ao/ORB_read.cpp:		this->Read_PAO(ofs_in, it, force_flag, my_rank);
module_basis/module_ao/ORB_read.cpp:		this->rcutmax_Phi = std::max(this->rcutmax_Phi, this->Phi[it].getRcut());
module_basis/module_ao/ORB_read.cpp:		delete[] this->Alpha;
module_basis/module_ao/ORB_read.cpp:		this->Alpha = new Numerical_Orbital[1];	//not related to atom type -- remain to be discussed
module_basis/module_ao/ORB_read.cpp:		this->Read_Descriptor(ofs_in, force_flag, my_rank);
module_basis/module_ao/ORB_read.cpp:// 2. pass nchi to phi via this->Phi[it].set_orbital_info 
module_basis/module_ao/ORB_read.cpp:		in_ao.open(this->orbital_file[it].c_str());
module_basis/module_ao/ORB_read.cpp:		std::cout << " Orbital file : " << this->orbital_file[it] << std::endl;
module_basis/module_ao/ORB_read.cpp:	this->read_orb_file(ofs_in, in_ao, it, lmaxt, nchimaxt, this->Phi, force_flag, my_rank);
module_basis/module_ao/ORB_read.cpp:	this->lmax = std::max(this->lmax, lmaxt);
module_basis/module_ao/ORB_read.cpp:	this->nchimax = std::max(this->nchimax, nchimaxt);
module_basis/module_ao/ORB_read.cpp:		in_de.open(this->descriptor_file.c_str());
module_basis/module_ao/ORB_read.cpp:		std::cout << " Orbital file : " << this->descriptor_file << std::endl;
module_basis/module_ao/ORB_read.cpp:	this->lmax_d = 0;
module_basis/module_ao/ORB_read.cpp:	this->nchimax_d = 0;
module_basis/module_ao/ORB_read.cpp:	this->read_orb_file(ofs_in, in_de, 0, this->lmax_d, this->nchimax_d, this->Alpha, force_flag, my_rank);
module_basis/module_ao/ORB_read.cpp:				this->kmesh,
module_basis/module_ao/ORB_read.cpp:				this->dk,
module_basis/module_ao/ORB_read.cpp:				this->dr_uniform,
module_basis/module_ao/ORB_table_alpha.cpp:	this->ntype = ntype_in; // number of (orbital) elements
module_basis/module_ao/ORB_table_alpha.cpp:	this->lmax = lmax_in;
module_basis/module_ao/ORB_table_alpha.cpp:	this->kmesh = kmesh_in;
module_basis/module_ao/ORB_table_alpha.cpp:	this->Rmax = Rmax_in;
module_basis/module_ao/ORB_table_alpha.cpp:	this->dr = dr_in;
module_basis/module_ao/ORB_table_alpha.cpp:	this->dk = dk_in;
module_basis/module_ao/ORB_table_alpha.cpp:	this->nlm = (2 * lmax + 1) * (2 * lmax + 1);
module_basis/module_ao/ORB_table_alpha.cpp:	this->Rmesh = static_cast<int>(Rmax / dr) + 4;
module_basis/module_ao/ORB_table_alpha.cpp:	int rmesh = static_cast<int>((R1 + R2) / this->dr) + 5;
module_basis/module_ao/ORB_table_alpha.cpp:	this->Table_DSR = new double ****[2];
module_basis/module_ao/ORB_table_alpha.cpp:	this->Table_DSR[0] = new double ***[this->ntype];
module_basis/module_ao/ORB_table_alpha.cpp:	this->Table_DSR[1] = new double ***[this->ntype];
module_basis/module_ao/ORB_table_alpha.cpp:		this->Table_DSR[0][T1] = new double **[pairs_chi];
module_basis/module_ao/ORB_table_alpha.cpp:		this->Table_DSR[1][T1] = new double **[pairs_chi];
module_basis/module_ao/ORB_table_alpha.cpp:						const int Opair = this->DS_Opair(T1, L1, L2, N1, N2);
module_basis/module_ao/ORB_table_alpha.cpp:						this->Table_DSR[0][T1][Opair] = new double *[L2plus1];
module_basis/module_ao/ORB_table_alpha.cpp:						this->Table_DSR[1][T1][Opair] = new double *[L2plus1];
module_basis/module_ao/ORB_table_alpha.cpp:						const int rmesh = this->get_rmesh(Rcut1, Rcut2);
module_basis/module_ao/ORB_table_alpha.cpp:						assert(rmesh < this->Rmesh);
module_basis/module_ao/ORB_table_alpha.cpp:							this->Table_DSR[0][T1][Opair][L] = new double[rmesh];
module_basis/module_ao/ORB_table_alpha.cpp:							this->Table_DSR[1][T1][Opair][L] = new double[rmesh];
module_basis/module_ao/ORB_table_alpha.cpp:							this->cal_S_PhiAlpha_R(
module_basis/module_ao/ORB_table_alpha.cpp:								this->Table_DSR[0][T1][Opair][L],
module_basis/module_ao/ORB_table_alpha.cpp:								this->Table_DSR[1][T1][Opair][L]);
module_basis/module_ao/ORB_table_alpha.cpp:	assert(this->ntype > 0);
module_basis/module_ao/ORB_table_alpha.cpp:		this->DS_2Lplus1[T1] = std::max(orb.Phi[T1].getLmax(), orb.Alpha[0].getLmax()) * 2 + 1;
module_basis/module_ao/ORB_table_alpha.cpp:	this->DS_Opair.create(this->ntype, lmax + 1, lmax_d + 1, nchimax, nchimax_d);
module_basis/module_ao/ORB_table_alpha.cpp:						this->DS_Opair(T1, L1, L2, N1, N2) = index;
module_basis/module_ao/ORB_table_alpha.cpp:	for (int T1 = 0; T1 < this->ntype; T1++)	//T1
module_basis/module_ao/ORB_table_alpha.cpp:						const int Opair = this->DS_Opair(T1, L1, L2, N1, N2);	//Opair
module_basis/module_ao/ORB_table_alpha.cpp:						for (int il = 0; il < this-> DS_2Lplus1[T1]; il++)
module_basis/module_ao/ORB_table_alpha.cpp:							const int rmesh = this->get_rmesh(Rcut1, Rcut2);
module_basis/module_ao/ORB_table_alpha.cpp:							ofs << "Rcut1="<<Rcut1<<", Rcut2="<<Rcut2<<", rmesh="<<rmesh<<", dr="<<this->dr<<";"<< std::endl;
module_basis/module_ao/ORB_table_alpha.h:	//int ntype_; // table is created with this->ntype
module_basis/module_ao/ORB_table_beta.cpp:	this->ntype = ntype_in;// type of elements.
module_basis/module_ao/ORB_table_beta.cpp:	this->lmax = lmax_in;
module_basis/module_ao/ORB_table_beta.cpp:	this->kmesh = kmesh_in;
module_basis/module_ao/ORB_table_beta.cpp:	this->Rmax = Rmax_in;
module_basis/module_ao/ORB_table_beta.cpp:	this->dr = dr_in;
module_basis/module_ao/ORB_table_beta.cpp:	this->dk = dk_in;
module_basis/module_ao/ORB_table_beta.cpp:	this->nlm = (2*lmax+1) * (2*lmax+1);
module_basis/module_ao/ORB_table_beta.cpp:	this->Rmesh = static_cast<int>( Rmax/dr ) + 4;
module_basis/module_ao/ORB_table_beta.cpp:	this->Table_NR = new double****[2];
module_basis/module_ao/ORB_table_beta.cpp:	this->Table_NR[0] = new double*** [this->NL_nTpairs];
module_basis/module_ao/ORB_table_beta.cpp:	this->Table_NR[1] = new double*** [this->NL_nTpairs];
module_basis/module_ao/ORB_table_beta.cpp:			const int Tpair=this->NL_Tpair(T1,T2);
module_basis/module_ao/ORB_table_beta.cpp:			this->Table_NR[0][Tpair] = new double** [ pairs_chi ];
module_basis/module_ao/ORB_table_beta.cpp:			this->Table_NR[1][Tpair] = new double** [ pairs_chi ];
module_basis/module_ao/ORB_table_beta.cpp:            const int T12_2Lplus1 = this->NL_L2plus1(T1,T2);
module_basis/module_ao/ORB_table_beta.cpp:						const int Opair = this->NL_Opair(Tpair,L1,N1,nb);
module_basis/module_ao/ORB_table_beta.cpp:						this->Table_NR[0][ Tpair ][ Opair ] = new double *[T12_2Lplus1];
module_basis/module_ao/ORB_table_beta.cpp:						this->Table_NR[1][ Tpair ][ Opair ] = new double *[T12_2Lplus1];
module_basis/module_ao/ORB_table_beta.cpp:						const int rmesh = this->get_rmesh( Rcut1, Rcut2);
module_basis/module_ao/ORB_table_beta.cpp:						assert( rmesh < this->Rmesh );
module_basis/module_ao/ORB_table_beta.cpp:							this->Table_NR[0][Tpair][Opair][L] = new double[rmesh];
module_basis/module_ao/ORB_table_beta.cpp:							this->Table_NR[1][Tpair][Opair][L] = new double[rmesh];
module_basis/module_ao/ORB_table_beta.cpp:							this->cal_VNL_PhiBeta_R(
module_basis/module_ao/ORB_table_beta.cpp:								this->Table_NR[0][Tpair][Opair][L],
module_basis/module_ao/ORB_table_beta.cpp:								this->Table_NR[1][Tpair][Opair][L]);
module_basis/module_ao/ORB_table_beta.cpp:				const int Tpair = this->NL_Tpair(T1,T2); 
module_basis/module_ao/ORB_table_beta.cpp:				const int L2plus1 = this->NL_L2plus1(T1,T2);
module_basis/module_ao/ORB_table_beta.cpp:	this->NL_nTpairs = this->ntype * this->ntype;	
module_basis/module_ao/ORB_table_beta.cpp:	this->NL_Tpair.create( this->ntype, this->ntype);
module_basis/module_ao/ORB_table_beta.cpp:	this->NL_L2plus1.create( this->ntype, this->ntype); // mohan fix bug 2011-03-14
module_basis/module_ao/ORB_table_beta.cpp:			 this->NL_Tpair(T1,T0) = index;
module_basis/module_ao/ORB_table_beta.cpp:			 this->NL_L2plus1(T1,T0) = std::max(phi_[T1].getLmax(), beta_[T0].getLmax() )*2+1;
module_basis/module_ao/ORB_table_beta.cpp:	this->NL_Opair.create( this->NL_nTpairs, lmax+1, nchimax, nprojmax);
module_basis/module_ao/ORB_table_beta.cpp:			const int nlpair = this->NL_Tpair(T1, T0);
module_basis/module_ao/ORB_table_beta.cpp:						this->NL_Opair(nlpair, L1, N1, ip) = index;
module_basis/module_ao/ORB_table_phi.cpp:	this->ntype = ntype_in;// type of elements.
module_basis/module_ao/ORB_table_phi.cpp:	this->lmax = lmax_in;
module_basis/module_ao/ORB_table_phi.cpp:	this->kmesh = kmesh_in;
module_basis/module_ao/ORB_table_phi.cpp:	this->Rmax = Rmax_in;
module_basis/module_ao/ORB_table_phi.cpp:	this->dr = dr_in;
module_basis/module_ao/ORB_table_phi.cpp:	this->dk = dk_in;
module_basis/module_ao/ORB_table_phi.cpp:	this->nlm = (2*lmax+1) * (2*lmax+1);
module_basis/module_ao/ORB_table_phi.cpp:	this->Rmesh = static_cast<int>( Rmax/dr ) + 4;
module_basis/module_ao/ORB_table_phi.cpp:	int rmesh = static_cast<int>((R1+R2)/ this->dr) + 5;
module_basis/module_ao/ORB_table_phi.cpp:		k1_dot_k2_dot_kpoint[ik] = k1_dot_k2[ik] * this->kpoint[ik];
module_basis/module_ao/ORB_table_phi.cpp:		k1_dot_k2_dot_kpoint[ik] = k1_dot_k2[ik] * this->kpoint[ik];
module_basis/module_ao/ORB_table_phi.cpp:	assert( this->dr > 0.0);
module_basis/module_ao/ORB_table_phi.cpp:	this->Table_SR = new double****[2];
module_basis/module_ao/ORB_table_phi.cpp:	this->Table_TR = new double****[2];
module_basis/module_ao/ORB_table_phi.cpp:		this->Table_SR[ir] = new double***[ this->OV_nTpairs ];
module_basis/module_ao/ORB_table_phi.cpp:		this->Table_TR[ir] = new double***[ this->OV_nTpairs ];
module_basis/module_ao/ORB_table_phi.cpp:			const int Tpair=this->OV_Tpair(T1,T2);
module_basis/module_ao/ORB_table_phi.cpp:				this->Table_SR[ir][ Tpair ] = new double**[pairs_chi];
module_basis/module_ao/ORB_table_phi.cpp:				this->Table_TR[ir][ Tpair ] = new double**[pairs_chi];
module_basis/module_ao/ORB_table_phi.cpp:			const int rmesh = this->get_rmesh( Rcut1, Rcut2);
module_basis/module_ao/ORB_table_phi.cpp:			assert( rmesh < this->Rmesh );
module_basis/module_ao/ORB_table_phi.cpp:							const int Opair = this->OV_Opair(Tpair,L1,L2,N1,N2);
module_basis/module_ao/ORB_table_phi.cpp:								this->Table_SR[ir][ Tpair ][ Opair ] = new double *[L2plus1];
module_basis/module_ao/ORB_table_phi.cpp:								this->Table_TR[ir][ Tpair ][ Opair ] = new double *[L2plus1];
module_basis/module_ao/ORB_table_phi.cpp:								this->cal_ST_Phi12_R(1,L,
module_basis/module_ao/ORB_table_phi.cpp:								this->cal_ST_Phi12_R(2,L,
module_basis/module_ao/ORB_table_phi.cpp:    this->OV_nTpairs = this->ntype * (this->ntype + 1) / 2;
module_basis/module_ao/ORB_table_phi.cpp:    this->OV_Tpair.create(ntype, ntype);
module_basis/module_ao/ORB_table_phi.cpp:	this->OV_L2plus1.create(ntype, ntype); // mohan fix bug 2011-03-14
module_basis/module_ao/ORB_table_phi.cpp:            this->OV_Tpair(T2, T1) = index;
module_basis/module_ao/ORB_table_phi.cpp:			this->OV_Tpair(T1, T2) = this->OV_Tpair(T2, T1);
module_basis/module_ao/ORB_table_phi.cpp:			this->OV_L2plus1(T1,T2) = std::max(orb.Phi[T1].getLmax(), orb.Phi[T2].getLmax() )*2+1;
module_basis/module_ao/ORB_table_phi.cpp:			this->OV_L2plus1(T2,T1) = this->OV_L2plus1(T1,T2);
module_basis/module_ao/ORB_table_phi.cpp:    this->OV_Opair.create(OV_nTpairs, lmax+1, lmax+1, nchimax, nchimax);
module_basis/module_ao/ORB_table_phi.cpp:			const int dim1 = this->OV_Tpair(T1,T2);
module_basis/module_ao/ORB_table_phi.cpp:                            this->OV_Opair(dim1, L1, L2, N1, N2) = index;
module_basis/module_ao/ORB_table_phi.cpp:	this->init_Lmax (orb_num,mode,Lmax_used,Lmax,Lmax_exx,orb, beta_);		// Peize Lin add 2016-01-26
module_basis/module_ao/ORB_table_phi.cpp:		if( this->dr * this->dk == sb.get_dx() )
module_basis/module_ao/ORB_table_phi.cpp:	pSB->set_dx( this->dr * this->dk );
module_basis/module_ao/ORB_table_phi.cpp:	pSB->cal_jlx( Lmax_used, this->Rmesh, this->kmesh );
module_basis/module_ao/ORB_table_phi.cpp:	ModuleBase::Memory::record ("ORB::Jl(x)", sizeof(double) * (Lmax_used+1) * this->kmesh * this->Rmesh);
module_basis/module_ao/parallel_2d.cpp:        this->dim1 = (int)sqrt((double)dsize);
module_basis/module_ao/parallel_2d.cpp:        while (dsize % this->dim1 != 0)
module_basis/module_ao/parallel_2d.cpp:            this->dim1 = this->dim1 - 1;
module_basis/module_ao/parallel_2d.cpp:        assert(this->dim1 > 0);
module_basis/module_ao/parallel_2d.cpp:        this->dim0 = dsize / this->dim1;
module_basis/module_ao/parallel_2d.cpp:        this->dim0 = (int)sqrt((double)dsize);
module_basis/module_ao/parallel_2d.cpp:        while (dsize % this->dim0 != 0)
module_basis/module_ao/parallel_2d.cpp:            this->dim0 = this->dim0 - 1;
module_basis/module_ao/parallel_2d.cpp:        assert(this->dim0 > 0);
module_basis/module_ao/parallel_2d.cpp:        this->dim1 = dsize / this->dim0;
module_basis/module_ao/parallel_2d.cpp:    this->init_global2local(M_A, N_A, ofs_running);
module_basis/module_ao/parallel_2d.cpp:        for (int i = 0; i < M_A; i++) this->global2local_row_[i] = i;
module_basis/module_ao/parallel_2d.cpp:        for (int i = 0; i < N_A; i++) this->global2local_col_[i] = i;
module_basis/module_ao/parallel_2d.cpp:        this->nrow = M_A;
module_basis/module_ao/parallel_2d.cpp:        this->ncol = N_A;
module_basis/module_ao/parallel_2d.cpp:        this->nloc = this->nrow * this->ncol;
module_basis/module_ao/parallel_2d.cpp:        for (int irow = 0; irow < this->nrow; irow++)
module_basis/module_ao/parallel_2d.cpp:            int global_row = this->local2global_row(irow);
module_basis/module_ao/parallel_2d.cpp:            this->global2local_row_[global_row] = irow;
module_basis/module_ao/parallel_2d.cpp:        for (int icol = 0; icol < this->ncol; icol++)
module_basis/module_ao/parallel_2d.cpp:            int global_col = this->local2global_col(icol);
module_basis/module_ao/parallel_2d.cpp:            this->global2local_col_[global_col] = icol;
module_basis/module_ao/parallel_2d.cpp:    delete[] this->global2local_row_;
module_basis/module_ao/parallel_2d.cpp:    delete[] this->global2local_col_;
module_basis/module_ao/parallel_2d.cpp:    this->global2local_row_ = new int[M_A];
module_basis/module_ao/parallel_2d.cpp:    this->global2local_col_ = new int[N_A];
module_basis/module_ao/parallel_2d.cpp:    for (int i = 0; i < M_A; i++) this->global2local_row_[i] = -1;
module_basis/module_ao/parallel_2d.cpp:    for (int i = 0; i < N_A; i++) this->global2local_col_[i] = -1;
module_basis/module_ao/parallel_2d.cpp:    assert(this->comm_2D != MPI_COMM_NULL);
module_basis/module_ao/parallel_2d.cpp:    assert(this->dim0 > 0 && this->dim1 > 0);
module_basis/module_ao/parallel_2d.cpp:    int dim[2] = { this->dim0, this->dim1 };
module_basis/module_ao/parallel_2d.cpp:    MPI_Cart_create(diag_world, 2, dim, period, reorder, &this->comm_2D);
module_basis/module_ao/parallel_2d.cpp:    assert(this->comm_2D != MPI_COMM_NULL);
module_basis/module_ao/parallel_2d.cpp:    assert(this->nb > 0 && this->dim0 > 0 && this->dim1 > 0);
module_basis/module_ao/parallel_2d.cpp:        int* usermap = new int[this->dim0 * this->dim1];
module_basis/module_ao/parallel_2d.cpp:        for (int i = 0; i < this->dim0; ++i)
module_basis/module_ao/parallel_2d.cpp:            for (int j = 0; j < this->dim1; ++j)
module_basis/module_ao/parallel_2d.cpp:                MPI_Cart_rank(comm_2D, pcoord, &usermap[i + j * this->dim0]);
module_basis/module_ao/parallel_2d.cpp:        Cblacs_get(comm_2D_f, 0, &this->blacs_ctxt);
module_basis/module_ao/parallel_2d.cpp:        Cblacs_gridmap(&this->blacs_ctxt, usermap, this->dim0, this->dim0, this->dim1);
module_basis/module_ao/parallel_2d.cpp:        Cblacs_gridinfo(this->blacs_ctxt, &this->dim0, &this->dim1, &myprow, &mypcol);
module_basis/module_ao/parallel_2d.cpp:    descinit_(desc, &gr, &gc, &this->nb, &this->nb, &ISRC, &ISRC, &this->blacs_ctxt, &lld, &info);
module_basis/module_ao/parallel_2d.cpp:    assert(this->nb > 0);
module_basis/module_ao/parallel_2d.cpp:    MPI_Cart_get(this->comm_2D, 2, dim, period, coord);
module_basis/module_ao/parallel_2d.cpp:    assert(dim[0] == this->dim0);
module_basis/module_ao/parallel_2d.cpp:    assert(dim[1] == this->dim1);
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Total Row Blocks Number", block);
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Local Row Block Number", row_b);
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Ending Row Block in processor", end_id);
module_basis/module_ao/parallel_2d.cpp:    // (4) this->nrow : how many rows in this processors :
module_basis/module_ao/parallel_2d.cpp:        this->nrow = (row_b - 1) * nb + (M_A - (block - 1) * nb);
module_basis/module_ao/parallel_2d.cpp:        this->nrow = row_b * nb;
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Local rows (including nb)", this->nrow);
module_basis/module_ao/parallel_2d.cpp:    this->local2global_row_.resize(this->nrow);
module_basis/module_ao/parallel_2d.cpp:            this->local2global_row_[j] = coord[0] * nb + i * nb * dim[0] + k;
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Total Col Blocks Number", block);
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Local Col Block Number", col_b);
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Ending Col Block in processor", end_id);
module_basis/module_ao/parallel_2d.cpp:        this->ncol = (col_b - 1) * nb + (N_A - (block - 1) * nb);
module_basis/module_ao/parallel_2d.cpp:        this->ncol = col_b * nb;
module_basis/module_ao/parallel_2d.cpp:    if (this->testpb)ModuleBase::GlobalFunc::OUT(ofs_running, "Local columns (including nb)", this->ncol);
module_basis/module_ao/parallel_2d.cpp:    this->nloc = this->nrow * this->ncol;
module_basis/module_ao/parallel_2d.cpp:    this->local2global_col_.resize(this->ncol);
module_basis/module_ao/parallel_2d.cpp:            this->local2global_col_[j] = coord[1] * nb + i * nb * dim[1] + k;
module_basis/module_ao/parallel_2d.cpp:    this->nrow = M_A;
module_basis/module_ao/parallel_2d.cpp:    this->ncol = N_A;
module_basis/module_ao/parallel_2d.cpp:    this->nloc = this->nrow * this->ncol;
module_basis/module_ao/parallel_2d.cpp:    this->local2global_row_.resize(this->nrow);
module_basis/module_ao/parallel_2d.cpp:    this->local2global_col_.resize(this->ncol);
module_basis/module_ao/parallel_2d.cpp:    for (int i = 0; i < this->nrow; i++) this->local2global_row_[i] = i;
module_basis/module_ao/parallel_2d.cpp:    for (int i = 0; i < this->ncol; i++) this->local2global_col_[i] = i;
module_basis/module_ao/parallel_2d.h:    int get_col_size()const { return this->ncol; };
module_basis/module_ao/parallel_2d.h:    int get_row_size()const { return this->nrow; };
module_basis/module_ao/parallel_2d.h:    int get_local_size()const { return this->nloc; };
module_basis/module_ao/parallel_2d.h:        return this->global2local_row_[igr];
module_basis/module_ao/parallel_2d.h:        return this->global2local_col_[igc];
module_basis/module_ao/parallel_2d.h:        return this->local2global_row_[ilr];
module_basis/module_ao/parallel_2d.h:        return this->local2global_col_[ilc];
module_basis/module_ao/parallel_2d.h:    void set_block_size(const int& nb_in) { this->nb = nb_in; };
module_basis/module_ao/parallel_2d.h:    int get_block_size()const { return this->nb; };
module_basis/module_ao/parallel_2d.h:        bool first_time = true/**< true: call `Cblacs_get`; false: use `this->blacs_ctxt`*/);
module_basis/module_ao/parallel_orbitals.cpp:    this->iat2iwt_ = iat2iwt;
module_basis/module_ao/parallel_orbitals.cpp:    this->atom_begin_col.resize(nat_plus_1);
module_basis/module_ao/parallel_orbitals.cpp:    this->atom_begin_row.resize(nat_plus_1);
module_basis/module_ao/parallel_orbitals.cpp:        this->atom_begin_col[iat] = -1;
module_basis/module_ao/parallel_orbitals.cpp:        this->atom_begin_row[iat] = -1;
module_basis/module_ao/parallel_orbitals.cpp:            if (this->global2local_row_[irow] != -1)
module_basis/module_ao/parallel_orbitals.cpp:                this->atom_begin_row[iat] = this->global2local_row_[irow];
module_basis/module_ao/parallel_orbitals.cpp:            if (this->global2local_col_[icol] != -1)
module_basis/module_ao/parallel_orbitals.cpp:                this->atom_begin_col[iat] = this->global2local_col_[icol];
module_basis/module_ao/parallel_orbitals.cpp:    this->atom_begin_row[nat] = this->nrow;
module_basis/module_ao/parallel_orbitals.cpp:    this->atom_begin_col[nat] = this->ncol;
module_basis/module_ao/parallel_orbitals.cpp:    return this->ncol;
module_basis/module_ao/parallel_orbitals.cpp:    return this->nrow;
module_basis/module_ao/parallel_orbitals.cpp:    int size = this->atom_begin_col[iat];
module_basis/module_ao/parallel_orbitals.cpp:    while(this->atom_begin_col[iat] <= this->ncol)
module_basis/module_ao/parallel_orbitals.cpp:        if(this->atom_begin_col[iat] != -1)
module_basis/module_ao/parallel_orbitals.cpp:            size = this->atom_begin_col[iat] - size;
module_basis/module_ao/parallel_orbitals.cpp:    int size = this->atom_begin_row[iat];
module_basis/module_ao/parallel_orbitals.cpp:    while(this->atom_begin_row[iat] <= this->nrow)
module_basis/module_ao/parallel_orbitals.cpp:        if(this->atom_begin_row[iat] != -1)
module_basis/module_ao/parallel_orbitals.cpp:            size = this->atom_begin_row[iat] - size;
module_basis/module_ao/parallel_orbitals.cpp:    std::vector<int> indexes(this->nrow);
module_basis/module_ao/parallel_orbitals.cpp:    for(int i = 0; i < this->nrow; i++)
module_basis/module_ao/parallel_orbitals.cpp:        indexes[i] = this->local2global_row(i);
module_basis/module_ao/parallel_orbitals.cpp:    std::vector<int> indexes(this->ncol);
module_basis/module_ao/parallel_orbitals.cpp:    for(int i = 0; i < this->ncol; i++)
module_basis/module_ao/parallel_orbitals.cpp:        indexes[i] = this->local2global_col(i);
module_basis/module_ao/parallel_orbitals.cpp:    int size = this->get_row_size(iat);
module_basis/module_ao/parallel_orbitals.cpp:    int irow = this->atom_begin_row[iat];
module_basis/module_ao/parallel_orbitals.cpp:    int begin = this->iat2iwt_[iat];
module_basis/module_ao/parallel_orbitals.cpp:        indexes[i] = this->local2global_row(irow + i) - begin;
module_basis/module_ao/parallel_orbitals.cpp:    int size = this->get_col_size(iat);
module_basis/module_ao/parallel_orbitals.cpp:    int icol = this->atom_begin_col[iat];
module_basis/module_ao/parallel_orbitals.cpp:    int begin = this->iat2iwt_[iat];
module_basis/module_ao/parallel_orbitals.cpp:        indexes[i] = this->local2global_col(icol + i) - begin;
module_basis/module_ao/parallel_orbitals.cpp:    assert(this->comm_2D != MPI_COMM_NULL);
module_basis/module_ao/parallel_orbitals.cpp:    assert(this->nb > 0 && this->dim0 > 0 && this->dim1 > 0);
module_basis/module_ao/parallel_orbitals.cpp:    descinit_(desc_wfc, &nbasis, &nbands, &this->nb, &this->nb, &ISRC, &ISRC, &this->blacs_ctxt, &lld, &info);
module_basis/module_ao/parallel_orbitals.cpp:    descinit_(desc_wfc1, &nbands, &nbasis, &this->nb, &this->nb, &ISRC, &ISRC, &this->blacs_ctxt, &lld, &info);
module_basis/module_ao/parallel_orbitals.cpp:    descinit_(desc_Eij, &nbands, &nbands, &this->nb, &this->nb, &ISRC, &ISRC, &this->blacs_ctxt, &lld, &info);
module_basis/module_ao/parallel_orbitals.cpp:        this->ncol_bands = (col_b_bands - 1) * nb + (N_A - (block - 1) * nb);
module_basis/module_ao/parallel_orbitals.cpp:        this->ncol_bands = col_b_bands * nb;
module_basis/module_ao/parallel_orbitals.cpp:    this->nloc_wfc = this->ncol_bands * this->nrow;
module_basis/module_ao/parallel_orbitals.cpp:    this->nloc_Eij = this->ncol_bands * this->ncol_bands;
module_basis/module_ao/test/1_snap_equal_test.cpp:	this->set_center2orbs();
module_basis/module_ao/test/1_snap_equal_test.cpp:								//std::cout << this->mock_center2_orb11[T1][T2][L1][N1][L2][N2]->cal_overlap(R1, R2, m1, m2);
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->dk_ = dk;
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->nk_ = calc_nk(ecut, dk);
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:                this->calc_nr_uniform(nolm_[ichi_tot].rcut, dr_uniform_));
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init_with_different_k(1600.0, dk_);
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init_with_different_k(1600.0, dk_);
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    ASSERT_NO_THROW(this->init());
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:        EXPECT_TRUE(this->check_file_match(nolm_[i].nr,
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:        EXPECT_TRUE(this->check_file_match(nolm_[i].nk,
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:        EXPECT_TRUE(this->check_file_match(nolm_[i].nr_uniform,
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:        EXPECT_TRUE(this->check_file_match(nolm_[i].nr_uniform,
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    this->init_with_different_k(1600.0, dk_);
module_basis/module_ao/test/ORB_atomic_lm_test.cpp:    EXPECT_NO_THROW(this->init());
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:            this->calc_nk(ecut, dk),
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:        this->change_k(tmp, ecut, tmp.dk);
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:            this->change_k(tmp, ecut_list[ie], tmp.dk);
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:            this->change_k(tmp, ecut, dk_list[idk]);
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:    this->init();
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:        EXPECT_EQ(true, this->check_file_match(nnl[i].nr, 
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:        EXPECT_EQ(true, this->check_file_match(nnl[i].nk, 
module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp:        EXPECT_EQ(true, this->check_file_match(nnl[i].nr_uniform, 
module_basis/module_ao/test/ORB_read_test.cpp:    EXPECT_EXIT(this->lcao_read(), testing::ExitedWithCode(0), "");
module_basis/module_ao/test/ORB_read_test.cpp:    EXPECT_EXIT(this->lcao_read(), testing::ExitedWithCode(0), "");
module_basis/module_ao/test/ORB_read_test.cpp:    EXPECT_EXIT(this->lcao_read(), testing::ExitedWithCode(0), "");
module_basis/module_ao/test/ORB_read_test.cpp:    this->lcao_read();
module_basis/module_ao/test/ORB_read_test.cpp:    this->lcao_read();
module_basis/module_ao/test/ORB_unittest.cpp:	this->ofs_running.open("log.txt");
module_basis/module_ao/test/ORB_unittest.cpp:	this->count_ntype();
module_basis/module_ao/test/ORB_unittest.cpp:    this->set_files();
module_basis/module_ao/test/ORB_unittest.cpp:    this->set_ekcut();
module_basis/module_ao/test/ORB_unittest.cpp:	this->set_orbs();
module_basis/module_ao/test/ORB_unittest.cpp:	//this->set_center2orbs();
module_basis/module_ao/test/ORB_unittest.cpp:		in_ao.open((this->case_dir+ORB.orbital_file[it].c_str()));
module_basis/module_ao/test/ORB_unittest.cpp:		ORB.orbital_file[it] = this->case_dir + ORB.orbital_file[it].c_str();
module_basis/module_ao/test/ORB_unittest.cpp:	std::ifstream ifs((this->case_dir + "STRU"),std::ios::in);
module_basis/module_ao/test/ORB_unittest.cpp:		std::cout << this->case_dir +"STRU" << std::endl;
module_basis/module_ao/test/ORB_unittest.cpp:	std::ifstream ifs( (this->case_dir+ "STRU"), std::ios::in);
module_basis/module_ao/test/ORB_unittest.cpp:							this->set_single_c2o<Center2_Orb::Orb11>(TA, TB, LA, NA, LB, NB);
module_basis/module_ao/test/ORB_unittest.cpp:	for (auto& co1 : this->test_center2_orb11)
module_basis/module_ao/test/ORB_unittest.cpp:	this->test_center2_orb11[TA][TB][LA][NA][LB].insert(
module_basis/module_ao/test/ORB_unittest.cpp:	std::cout << this->test_center2_orb11[0][0][0][0][0][0].cal_overlap(R1, R2, 0, 0);
module_basis/module_ao/test/parallel_2d_test.cpp:        this->ofs_running.open("log" + std::to_string(my_rank) + ".txt");
module_basis/module_ao/test/parallel_orbitals_test.cpp:        this->ofs_running.open("log" + std::to_string(my_rank) + ".txt");
module_basis/module_nao/atomic_radials.cpp:    this->symbol_ = other->symbol();
module_basis/module_nao/atomic_radials.cpp:    this->lmax_ = other->lmax();
module_basis/module_nao/atomic_radials.cpp:    this->nchi_ = other->nchi();
module_basis/module_nao/atomic_radials.cpp:    this->nzeta_max_ = other->nzeta_max();
module_basis/module_nao/atomic_radials.cpp:    this->itype_ = itype;
module_basis/module_nao/atomic_radials.cpp:    this->symbol_ = other->symbol();
module_basis/module_nao/atomic_radials.cpp:    this->nzeta_ = new int[this->lmax_ + 1];
module_basis/module_nao/atomic_radials.cpp:    for (int l = 0; l <= this->lmax_; ++l)
module_basis/module_nao/atomic_radials.cpp:        this->nzeta_[l] = other->nzeta(l);
module_basis/module_nao/atomic_radials.cpp:    this->indexing();
module_basis/module_nao/atomic_radials.cpp:    this->chi_ = new NumericalRadial[nchi_];
module_basis/module_nao/atomic_radials.cpp:    for(int ichi = 0;ichi<this->nchi_;ichi++)
module_basis/module_nao/atomic_radials.cpp:            this->chi_[ichi].build(l, true, ngrid, rgrid, rvalue, 0, izeta, symbol_, itype, false);
module_basis/module_nao/atomic_radials.cpp:            this->chi_[ichi].build(l, true, ngrid, rgrid, rvalue_new.data(), 0, izeta, symbol_, itype, false);
module_basis/module_nao/hydrogen_radials.cpp:        static_cast<double>(this->assoc_laguerre_.factorial(n - l - 1)) /
module_basis/module_nao/hydrogen_radials.cpp:        static_cast<double>(this->assoc_laguerre_.factorial(n + l)) /
module_basis/module_nao/hydrogen_radials.cpp:        rvalue[ir] = norm_factor * std::pow(rho, l) * exp(-rho/2.0) * this->assoc_laguerre_.value(
module_basis/module_nao/radial_collection.cpp:    this->ntype_ = nls->ntype();
module_basis/module_nao/radial_collection.cpp:    this->rcut_max_ = radius>0.0?radius:nls->rcut_max();
module_basis/module_nao/radial_collection.cpp:    this->radset_ = new RadialSet*[ntype_];
module_basis/module_nao/radial_collection.cpp:    this->lmax_ = nls->lmax();
module_basis/module_nao/radial_collection.cpp:    this->nchi_ = nls->nchi();
module_basis/module_nao/radial_collection.cpp:    this->nzeta_max_ = nls->nzeta_max();
module_basis/module_nao/radial_collection.cpp:        static_cast<AtomicRadials*>(radset_[itype])->build(nls->radset_[itype], itype, this->rcut_max_);
module_basis/module_nao/radial_collection.h:    /// *(this->cbegin(l)) returns the address of the first NumericalRadial object with angular momentum l
module_basis/module_nao/radial_collection.h:    /// *(this->cend(l)) returns the address of one-past-last NumericalRadial object with angular momentum l
module_basis/module_nao/two_center_table.cpp:                        (this->*f)(*it1, *it2, l);
module_basis/module_pw/fft.cpp:	this->clear();
module_basis/module_pw/fft.cpp:	this->cleanFFT();
module_basis/module_pw/fft.cpp:    if (this->device == "gpu") {
module_basis/module_pw/fft.cpp:    if (this->precision == "single") {
module_basis/module_pw/fft.cpp:        this->cleanfFFT();
module_basis/module_pw/fft.cpp:	this->gamma_only = gamma_only_in;
module_basis/module_pw/fft.cpp:	this->xprime = xprime_in;
module_basis/module_pw/fft.cpp:	this->fftnx = this->nx = nx_in;
module_basis/module_pw/fft.cpp:	this->fftny = this->ny = ny_in;
module_basis/module_pw/fft.cpp:	if(this->gamma_only)
module_basis/module_pw/fft.cpp:		if(xprime) 	this->fftnx = int(nx/2) +1;
module_basis/module_pw/fft.cpp:		else		this->fftny = int(ny/2) +1;
module_basis/module_pw/fft.cpp:	this->nz = nz_in;
module_basis/module_pw/fft.cpp:	this->ns = ns_in;
module_basis/module_pw/fft.cpp:	this->lixy = lixy_in;
module_basis/module_pw/fft.cpp:	this->rixy = rixy_in;
module_basis/module_pw/fft.cpp:	this->nplane = nplane_in;
module_basis/module_pw/fft.cpp:	this->nproc = nproc_in;
module_basis/module_pw/fft.cpp:	this->mpifft = mpifft_in;
module_basis/module_pw/fft.cpp:	this->nxy = this->nx * this-> ny;
module_basis/module_pw/fft.cpp:	this->fftnxy = this->fftnx * this->fftny;
module_basis/module_pw/fft.cpp:	// this->maxgrids = (this->nz * this->ns > this->nxy * nplane) ? this->nz * this->ns : this->nxy * nplane;
module_basis/module_pw/fft.cpp:	const int nrxx = this->nxy * this->nplane;
module_basis/module_pw/fft.cpp:	const int nsz = this->nz * this->ns;
module_basis/module_pw/fft.cpp:	if(!this->mpifft)
module_basis/module_pw/fft.cpp:        //     fftw_malloc(sizeof(fftw_complex) * (this->nx * this->ny * this->nz)));
module_basis/module_pw/fft.cpp:        if (this->device == "gpu") {
module_basis/module_pw/fft.cpp:            resmem_cd_op()(gpu_ctx, this->c_auxr_3d, this->nx * this->ny * this->nz);
module_basis/module_pw/fft.cpp:            resmem_zd_op()(gpu_ctx, this->z_auxr_3d, this->nx * this->ny * this->nz);
module_basis/module_pw/fft.cpp:        if (this->precision == "single") {
module_basis/module_pw/fft.cpp:    switch (this->fft_mode)
module_basis/module_pw/fft.cpp:    if(!this->mpifft)
module_basis/module_pw/fft.cpp:		this->initplan(flag);
module_basis/module_pw/fft.cpp:        if (this->precision == "single") {
module_basis/module_pw/fft.cpp:            this->initplanf(flag);
module_basis/module_pw/fft.cpp:		// this->initplan_mpi();
module_basis/module_pw/fft.cpp:        // if (this->precision == "single") {
module_basis/module_pw/fft.cpp:		//     this->initplanf_mpi();
module_basis/module_pw/fft.cpp:	this->planzfor = fftw_plan_many_dft(     1,    &this->nz,  this->ns,  
module_basis/module_pw/fft.cpp:					    (fftw_complex*) z_auxg,  &this->nz,  1,  this->nz,
module_basis/module_pw/fft.cpp:					    (fftw_complex*) z_auxg,  &this->nz,  1,  this->nz,  FFTW_FORWARD,  flag);
module_basis/module_pw/fft.cpp:	this->planzbac = fftw_plan_many_dft(     1,    &this->nz,  this->ns,  
module_basis/module_pw/fft.cpp:						(fftw_complex*) z_auxg,  &this->nz,  1,  this->nz,
module_basis/module_pw/fft.cpp:						(fftw_complex*) z_auxg,  &this->nz,  1,  this->nz,  FFTW_BACKWARD,  flag);
module_basis/module_pw/fft.cpp:	int npy = this->nplane * this->ny;
module_basis/module_pw/fft.cpp:	if(this->xprime)
module_basis/module_pw/fft.cpp:		this->planyfor  = fftw_plan_many_dft(  1, &this->ny,	this->nplane,	 (fftw_complex *)z_auxr, 		  embed, nplane,     1,
module_basis/module_pw/fft.cpp:		this->planybac  = fftw_plan_many_dft(  1, &this->ny,	this->nplane,	 (fftw_complex *)z_auxr, 		  embed, nplane,     1,
module_basis/module_pw/fft.cpp:		if(this->gamma_only)
module_basis/module_pw/fft.cpp:			this->planxr2c  = fftw_plan_many_dft_r2c(  1, &this->nx, npy,	d_rspace , embed, npy,      1,
module_basis/module_pw/fft.cpp:			this->planxc2r  = fftw_plan_many_dft_c2r(  1, &this->nx, npy,	(fftw_complex*)z_auxr , embed, npy,      1,
module_basis/module_pw/fft.cpp:			this->planxfor1  = fftw_plan_many_dft(  1, &this->nx,	npy,	 (fftw_complex *)z_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:			this->planxbac1  = fftw_plan_many_dft(  1, &this->nx,	npy,	 (fftw_complex *)z_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:		this->planxfor1  = fftw_plan_many_dft(  1, &this->nx,	this->nplane * (lixy + 1),	 (fftw_complex *)z_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:		this->planxbac1  = fftw_plan_many_dft(  1, &this->nx,	this->nplane * (lixy + 1),	 (fftw_complex *)z_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:		if(this->gamma_only)
module_basis/module_pw/fft.cpp:			this->planyr2c  = fftw_plan_many_dft_r2c(  1, &this->ny, this->nplane,	d_rspace , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				(fftw_complex*)z_auxr, embed, this->nplane,		1,	flag   );
module_basis/module_pw/fft.cpp:			this->planyc2r  = fftw_plan_many_dft_c2r(  1, &this->ny, this->nplane,	(fftw_complex*)z_auxr , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				d_rspace, embed, this->nplane,		1,			flag   );
module_basis/module_pw/fft.cpp:			this->planxfor2  = fftw_plan_many_dft(  1, &this->nx,	this->nplane * (ny - rixy),	 (fftw_complex *)z_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:			this->planxbac2  = fftw_plan_many_dft(  1, &this->nx,	this->nplane * (ny - rixy),	 (fftw_complex *)z_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:			this->planyfor  = fftw_plan_many_dft(  1, &this->ny, this->nplane,	(fftw_complex*)z_auxr , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				(fftw_complex*)z_auxr, embed, this->nplane,		1,		 FFTW_FORWARD,	flag   );
module_basis/module_pw/fft.cpp:			this->planybac  = fftw_plan_many_dft(  1, &this->ny, this->nplane,	(fftw_complex*)z_auxr , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				(fftw_complex*)z_auxr, embed, this->nplane,		1,		 FFTW_BACKWARD,	flag   );
module_basis/module_pw/fft.cpp:    //this->plan3dforward = fftw_plan_dft_3d(
module_basis/module_pw/fft.cpp:    //    this->nx, this->ny, this->nz,
module_basis/module_pw/fft.cpp:    //this->plan3dbackward = fftw_plan_dft_3d(
module_basis/module_pw/fft.cpp:    //    this->nx, this->ny, this->nz,
module_basis/module_pw/fft.cpp:    if (this->device == "gpu") {
module_basis/module_pw/fft.cpp:            cufftPlan3d(&c_handle, this->nx, this->ny, this->nz, CUFFT_C2C);
module_basis/module_pw/fft.cpp:            cufftPlan3d(&z_handle, this->nx, this->ny, this->nz, CUFFT_Z2Z);
module_basis/module_pw/fft.cpp:            hipfftPlan3d(&c_handle, this->nx, this->ny, this->nz, HIPFFT_C2C);
module_basis/module_pw/fft.cpp:            hipfftPlan3d(&z_handle, this->nx, this->ny, this->nz, HIPFFT_Z2Z);
module_basis/module_pw/fft.cpp:	this->planfzfor = fftwf_plan_many_dft(     1,    &this->nz,  this->ns,  
module_basis/module_pw/fft.cpp:					    (fftwf_complex*) c_auxg,  &this->nz,  1,  this->nz,
module_basis/module_pw/fft.cpp:					    (fftwf_complex*) c_auxg,  &this->nz,  1,  this->nz,  FFTW_FORWARD,  flag);
module_basis/module_pw/fft.cpp:	this->planfzbac = fftwf_plan_many_dft(     1,    &this->nz,  this->ns,  
module_basis/module_pw/fft.cpp:						(fftwf_complex*) c_auxg,  &this->nz,  1,  this->nz,
module_basis/module_pw/fft.cpp:						(fftwf_complex*) c_auxg,  &this->nz,  1,  this->nz,  FFTW_BACKWARD,  flag);
module_basis/module_pw/fft.cpp:	int npy = this->nplane * this->ny;
module_basis/module_pw/fft.cpp:	if(this->xprime)
module_basis/module_pw/fft.cpp:		this->planfyfor  = fftwf_plan_many_dft(  1, &this->ny,	this->nplane,	 (fftwf_complex *)c_auxr, 		  embed, nplane,     1,
module_basis/module_pw/fft.cpp:		this->planfybac  = fftwf_plan_many_dft(  1, &this->ny,	this->nplane,	 (fftwf_complex *)c_auxr, 		  embed, nplane,     1,
module_basis/module_pw/fft.cpp:		if(this->gamma_only)
module_basis/module_pw/fft.cpp:			this->planfxr2c  = fftwf_plan_many_dft_r2c(  1, &this->nx, npy,	s_rspace , embed, npy,      1,
module_basis/module_pw/fft.cpp:			this->planfxc2r  = fftwf_plan_many_dft_c2r(  1, &this->nx, npy,	(fftwf_complex*)c_auxr , embed, npy,      1,
module_basis/module_pw/fft.cpp:			this->planfxfor1  = fftwf_plan_many_dft(  1, &this->nx,	npy,	 (fftwf_complex *)c_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:			this->planfxbac1  = fftwf_plan_many_dft(  1, &this->nx,	npy,	 (fftwf_complex *)c_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:		this->planfxfor1  = fftwf_plan_many_dft(  1, &this->nx,	this->nplane * (lixy + 1),	 (fftwf_complex *)c_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:		this->planfxbac1  = fftwf_plan_many_dft(  1, &this->nx,	this->nplane * (lixy + 1),	 (fftwf_complex *)c_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:		if(this->gamma_only)
module_basis/module_pw/fft.cpp:			this->planfyr2c  = fftwf_plan_many_dft_r2c(  1, &this->ny, this->nplane,	s_rspace , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				(fftwf_complex*)c_auxr, embed, this->nplane,		1,	flag   );
module_basis/module_pw/fft.cpp:			this->planfyc2r  = fftwf_plan_many_dft_c2r(  1, &this->ny, this->nplane,	(fftwf_complex*)c_auxr , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				s_rspace, embed, this->nplane,		1,			flag   );
module_basis/module_pw/fft.cpp:			this->planfxfor2  = fftwf_plan_many_dft(  1, &this->nx,	this->nplane * (this->ny - rixy),	 (fftwf_complex *)c_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:			this->planfxbac2  = fftwf_plan_many_dft(  1, &this->nx,	this->nplane * (this->ny - rixy),	 (fftwf_complex *)c_auxr, 		  embed, npy,     1,
module_basis/module_pw/fft.cpp:			this->planfyfor  = fftwf_plan_many_dft(  1, &this->ny, this->nplane,	(fftwf_complex*)c_auxr , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				(fftwf_complex*)c_auxr, embed, this->nplane,		1,		 FFTW_FORWARD,	flag   );
module_basis/module_pw/fft.cpp:			this->planfybac  = fftwf_plan_many_dft(  1, &this->ny, this->nplane,	(fftwf_complex*)c_auxr , embed, this->nplane,      1,
module_basis/module_pw/fft.cpp:				(fftwf_complex*)c_auxr, embed, this->nplane,		1,		 FFTW_BACKWARD,	flag   );
module_basis/module_pw/fft.cpp:	// fftw_destroy_plan(this->plan3dforward);
module_basis/module_pw/fft.cpp:    // fftw_destroy_plan(this->plan3dbackward);
module_basis/module_pw/fft.cpp:    if (this->device == "gpu") {
module_basis/module_pw/fft.cpp:    fftwf_execute_dft(this->planfzfor,(fftwf_complex *)in,(fftwf_complex *)out);
module_basis/module_pw/fft.cpp:	fftw_execute_dft(this->planzfor,(fftw_complex *)in,(fftw_complex *)out);
module_basis/module_pw/fft.cpp:    fftwf_execute_dft(this->planfzbac,(fftwf_complex *)in, (fftwf_complex *)out);
module_basis/module_pw/fft.cpp:	fftw_execute_dft(this->planzbac,(fftw_complex *)in, (fftw_complex *)out);
module_basis/module_pw/fft.cpp:    int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:    if(this->xprime)
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxfor1, (fftwf_complex *)in, (fftwf_complex *)out);
module_basis/module_pw/fft.cpp:        for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfyfor, (fftwf_complex *)&in[i*npy], (fftwf_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:        for(int i = rixy ; i < this->nx; ++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfyfor, (fftwf_complex *)&in[i*npy], (fftwf_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:        for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfyfor, (fftwf_complex *)&in[i*npy], (fftwf_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxfor1, (fftwf_complex *)in, (fftwf_complex *)out);
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxfor2, (fftwf_complex *)&in[rixy*nplane], (fftwf_complex *)&out[rixy*nplane]);
module_basis/module_pw/fft.cpp:	int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:	if(this->xprime)
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxfor1, (fftw_complex *)in, (fftw_complex *)out);
module_basis/module_pw/fft.cpp:		for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planyfor, (fftw_complex *)&in[i*npy], (fftw_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:		for(int i = rixy ; i < this->nx; ++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planyfor, (fftw_complex *)&in[i*npy], (fftw_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:		for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planyfor, (fftw_complex *)&in[i*npy], (fftw_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxfor1, (fftw_complex *)in, (fftw_complex *)out);
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxfor2, (fftw_complex *)&in[rixy*nplane], (fftw_complex *)&out[rixy*nplane]);
module_basis/module_pw/fft.cpp:    int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:    if(this->xprime)
module_basis/module_pw/fft.cpp:        for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfybac, (fftwf_complex*)&in[i*npy], (fftwf_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:        for(int i = rixy ; i < this->nx; ++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfybac, (fftwf_complex*)&in[i*npy], (fftwf_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxbac1, (fftwf_complex *)in, (fftwf_complex *)out);
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxbac1, (fftwf_complex *)in, (fftwf_complex *)out);
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxbac2, (fftwf_complex *)&in[rixy*nplane], (fftwf_complex *)&out[rixy*nplane]);
module_basis/module_pw/fft.cpp:        for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfybac, (fftwf_complex*)&in[i*npy], (fftwf_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:	int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:	if(this->xprime)
module_basis/module_pw/fft.cpp:		for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planybac, (fftw_complex*)&in[i*npy], (fftw_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:		for(int i = rixy ; i < this->nx; ++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planybac, (fftw_complex*)&in[i*npy], (fftw_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxbac1, (fftw_complex *)in, (fftw_complex *)out);
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxbac1, (fftw_complex *)in, (fftw_complex *)out);
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxbac2, (fftw_complex *)&in[rixy*nplane], (fftw_complex *)&out[rixy*nplane]);
module_basis/module_pw/fft.cpp:		for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planybac, (fftw_complex*)&in[i*npy], (fftw_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:    int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:    if(this->xprime)
module_basis/module_pw/fft.cpp:        fftwf_execute_dft_r2c( this->planfxr2c, in, (fftwf_complex *)out);
module_basis/module_pw/fft.cpp:        for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfyfor, (fftwf_complex *)&out[i*npy], (fftwf_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:        for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft_r2c( this->planfyr2c, &in[i*npy], (fftwf_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxfor1, (fftwf_complex *)out, (fftwf_complex *)out);
module_basis/module_pw/fft.cpp:	int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:	if(this->xprime)
module_basis/module_pw/fft.cpp:		fftw_execute_dft_r2c( this->planxr2c, in, (fftw_complex *)out);
module_basis/module_pw/fft.cpp:		for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planyfor, (fftw_complex *)&out[i*npy], (fftw_complex *)&out[i*npy]);
module_basis/module_pw/fft.cpp:		for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft_r2c( this->planyr2c, &in[i*npy], (fftw_complex*)&out[i*npy] );
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxfor1, (fftw_complex *)out, (fftw_complex *)out);
module_basis/module_pw/fft.cpp:    int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:    if(this->xprime)
module_basis/module_pw/fft.cpp:        for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft( this->planfybac, (fftwf_complex *)&in[i*npy], (fftwf_complex *)&in[i*npy]);
module_basis/module_pw/fft.cpp:        fftwf_execute_dft_c2r( this->planfxc2r, (fftwf_complex *)in, out);
module_basis/module_pw/fft.cpp:        fftwf_execute_dft( this->planfxbac1, (fftwf_complex *)in, (fftwf_complex *)in);
module_basis/module_pw/fft.cpp:        for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:            fftwf_execute_dft_c2r( this->planfyc2r, (fftwf_complex*)&in[i*npy], &out[i*npy] );
module_basis/module_pw/fft.cpp:	int npy = this->nplane * this-> ny;
module_basis/module_pw/fft.cpp:	if(this->xprime)
module_basis/module_pw/fft.cpp:		for(int i = 0 ; i < this->lixy + 1; ++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft( this->planybac, (fftw_complex *)&in[i*npy], (fftw_complex *)&in[i*npy]);
module_basis/module_pw/fft.cpp:		fftw_execute_dft_c2r( this->planxc2r, (fftw_complex *)in, out);
module_basis/module_pw/fft.cpp:		fftw_execute_dft( this->planxbac1, (fftw_complex *)in, (fftw_complex *)in);
module_basis/module_pw/fft.cpp:		for (int i=0; i<this->nx;++i)
module_basis/module_pw/fft.cpp:			fftw_execute_dft_c2r( this->planyc2r, (fftw_complex*)&in[i*npy], &out[i*npy] );
module_basis/module_pw/fft.cpp:    cufftExecC2C(this->c_handle,
module_basis/module_pw/fft.cpp:    hipfftExecC2C(this->c_handle,
module_basis/module_pw/fft.cpp:    cufftExecZ2Z(this->z_handle,
module_basis/module_pw/fft.cpp:    hipfftExecZ2Z(this->z_handle,
module_basis/module_pw/fft.cpp:    cufftExecC2C(this->c_handle,
module_basis/module_pw/fft.cpp:    hipfftExecC2C(this->c_handle,
module_basis/module_pw/fft.cpp:    cufftExecZ2Z(this->z_handle,
module_basis/module_pw/fft.cpp:    hipfftExecZ2Z(this->z_handle,
module_basis/module_pw/fft.cpp:    return this->s_rspace;
module_basis/module_pw/fft.cpp:    return this->d_rspace;
module_basis/module_pw/fft.cpp:    return this->c_auxr;
module_basis/module_pw/fft.cpp:    return this->z_auxr;
module_basis/module_pw/fft.cpp:    return this->c_auxg;
module_basis/module_pw/fft.cpp:    return this->z_auxg;
module_basis/module_pw/fft.cpp:    return this->c_auxr_3d;
module_basis/module_pw/fft.cpp:    return this->z_auxr_3d;
module_basis/module_pw/fft.cpp:    this->device = std::move(device_);
module_basis/module_pw/fft.cpp:    this->precision = std::move(precision_);
module_basis/module_pw/kernels/test/pw_op_test.cpp:    set_3d_fft_box_cpu_op()(cpu_ctx, this->npwk, box_index.data(), in_1.data(), res.data());
module_basis/module_pw/kernels/test/pw_op_test.cpp:    for (int ii = 0; ii < this->nxyz; ii++) {
module_basis/module_pw/kernels/test/pw_op_test.cpp:    set_recip_to_real_output_cpu_op()(cpu_ctx, this->nxyz, this->add, this->factor, in_2.data(), res.data());
module_basis/module_pw/kernels/test/pw_op_test.cpp:    for (int ii = 0; ii < this->nxyz; ii++) {
module_basis/module_pw/kernels/test/pw_op_test.cpp:    set_real_to_recip_output_cpu_op()(cpu_ctx, this->npwk, this->nxyz, true, this->factor, box_index.data(), in_3.data(), res.data());
module_basis/module_pw/kernels/test/pw_op_test.cpp:    set_3d_fft_box_gpu_op()(gpu_ctx, this->npwk, d_box_index, d_in_1, d_res);
module_basis/module_pw/kernels/test/pw_op_test.cpp:    for (int ii = 0; ii < this->nxyz; ii++) {
module_basis/module_pw/kernels/test/pw_op_test.cpp:    set_recip_to_real_output_gpu_op()(gpu_ctx, this->nxyz, this->add, this->factor, d_in_2, d_res);
module_basis/module_pw/kernels/test/pw_op_test.cpp:    for (int ii = 0; ii < this->nxyz; ii++) {
module_basis/module_pw/kernels/test/pw_op_test.cpp:    set_real_to_recip_output_gpu_op()(gpu_ctx, this->npwk, this->nxyz, true, this->factor, d_box_index, d_in_3, d_res);
module_basis/module_pw/pw_basis.cpp:    this->ft.set_device(this->device);
module_basis/module_pw/pw_basis.cpp:    this->ft.set_precision(this->precision);
module_basis/module_pw/pw_basis.cpp:    if (this->device == "gpu") {
module_basis/module_pw/pw_basis.cpp:        delmem_int_op()(gpu_ctx, this->d_is2fftixy);
module_basis/module_pw/pw_basis.cpp:    ModuleBase::timer::tick(this->classname, "setuptransform");
module_basis/module_pw/pw_basis.cpp:    this->distribute_r();
module_basis/module_pw/pw_basis.cpp:    this->distribute_g();
module_basis/module_pw/pw_basis.cpp:    this->getstartgr();
module_basis/module_pw/pw_basis.cpp:    this->ft.clear();
module_basis/module_pw/pw_basis.cpp:    if(this->xprime)    this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime);
module_basis/module_pw/pw_basis.cpp:    else                this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime);
module_basis/module_pw/pw_basis.cpp:    this->ft.setupFFT();
module_basis/module_pw/pw_basis.cpp:    ModuleBase::timer::tick(this->classname, "setuptransform");
module_basis/module_pw/pw_basis.cpp:    if(this->gamma_only)    this->nmaxgr = ( this->npw > (this->nrxx+1)/2 ) ? this->npw : (this->nrxx+1)/2;
module_basis/module_pw/pw_basis.cpp:    else                    this->nmaxgr = ( this->npw > this->nrxx ) ? this->npw : this->nrxx;
module_basis/module_pw/pw_basis.cpp:    this->nmaxgr = (this->nz * this->nst > this->nxy * nplane) ? this->nz * this->nst : this->nxy * nplane;
module_basis/module_pw/pw_basis.cpp:    delete[] this->numg; this->numg = new int[poolnproc];
module_basis/module_pw/pw_basis.cpp:	delete[] this->startg; this->startg = new int[poolnproc];
module_basis/module_pw/pw_basis.cpp:	delete[] this->startr; this->startr = new int[poolnproc];
module_basis/module_pw/pw_basis.cpp:	delete[] this->numr; this->numr = new int[poolnproc];
module_basis/module_pw/pw_basis.cpp:	for (int ip = 0;ip < poolnproc; ++ip) this->numg[ip] = this->nst_per[poolrank] * this->numz[ip];
module_basis/module_pw/pw_basis.cpp:	for (int ip = 0;ip < poolnproc; ++ip) this->numr[ip] = this->nst_per[ip] * this->numz[poolrank];
module_basis/module_pw/pw_basis.cpp:	this->startg[0] = 0;
module_basis/module_pw/pw_basis.cpp:	for (int ip = 1;ip < poolnproc; ++ip) this->startg[ip] = this->startg[ip-1] + this->numg[ip-1];
module_basis/module_pw/pw_basis.cpp:	this->startr[0] = 0;
module_basis/module_pw/pw_basis.cpp:	for (int ip = 1;ip < poolnproc; ++ip) this->startr[ip] = this->startr[ip-1] + this->numr[ip-1];
module_basis/module_pw/pw_basis.cpp:    if(this->npw <= 0) return;
module_basis/module_pw/pw_basis.cpp:    this->ig_gge0 = -1;
module_basis/module_pw/pw_basis.cpp:    delete[] this->gg; this->gg = new double[this->npw];
module_basis/module_pw/pw_basis.cpp:    delete[] this->gdirect; this->gdirect = new ModuleBase::Vector3<double>[this->npw];
module_basis/module_pw/pw_basis.cpp:    delete[] this->gcar; this->gcar = new ModuleBase::Vector3<double>[this->npw];
module_basis/module_pw/pw_basis.cpp:    for(int ig = 0 ; ig < this-> npw ; ++ig)
module_basis/module_pw/pw_basis.cpp:        int isz = this->ig2isz[ig];
module_basis/module_pw/pw_basis.cpp:        int iz = isz % this->nz;
module_basis/module_pw/pw_basis.cpp:        int is = isz / this->nz;
module_basis/module_pw/pw_basis.cpp:        int ixy = this->is2fftixy[is];
module_basis/module_pw/pw_basis.cpp:        int ix = ixy / this->fftny;
module_basis/module_pw/pw_basis.cpp:        int iy = ixy % this->fftny;
module_basis/module_pw/pw_basis.cpp:        if (ix >= int(this->nx/2) + 1) ix -= this->nx;
module_basis/module_pw/pw_basis.cpp:        if (iy >= int(this->ny/2) + 1) iy -= this->ny;
module_basis/module_pw/pw_basis.cpp:        if (iz >= int(this->nz/2) + 1) iz -= this->nz;
module_basis/module_pw/pw_basis.cpp:        this->gg[ig] = f * (this->GGT * f);
module_basis/module_pw/pw_basis.cpp:        this->gdirect[ig] = f;
module_basis/module_pw/pw_basis.cpp:        this->gcar[ig] = f * this->G;
module_basis/module_pw/pw_basis.cpp:        if(this->gg[ig] < 1e-8) this->ig_gge0 = ig;
module_basis/module_pw/pw_basis.cpp:    if(this->npw <= 0) return;
module_basis/module_pw/pw_basis.cpp:    this->ig_gge0 = -1;
module_basis/module_pw/pw_basis.cpp:    delete[] this->ig2igg; this->ig2igg = new int [this->npw];
module_basis/module_pw/pw_basis.cpp:    int *sortindex = new int [this->npw];
module_basis/module_pw/pw_basis.cpp:    double *tmpgg = new double [this->npw];
module_basis/module_pw/pw_basis.cpp:    double *tmpgg2 = new double [this->npw];
module_basis/module_pw/pw_basis.cpp:    for(int ig = 0 ; ig < this-> npw ; ++ig)
module_basis/module_pw/pw_basis.cpp:        int isz = this->ig2isz[ig];
module_basis/module_pw/pw_basis.cpp:        int iz = isz % this->nz;
module_basis/module_pw/pw_basis.cpp:        int is = isz / this->nz;
module_basis/module_pw/pw_basis.cpp:        int ixy = this->is2fftixy[is];
module_basis/module_pw/pw_basis.cpp:        int ix = ixy / this->fftny;
module_basis/module_pw/pw_basis.cpp:        int iy = ixy % this->fftny;
module_basis/module_pw/pw_basis.cpp:        if (ix >= int(this->nx/2) + 1) ix -= this->nx;
module_basis/module_pw/pw_basis.cpp:        if (iy >= int(this->ny/2) + 1) iy -= this->ny;
module_basis/module_pw/pw_basis.cpp:        if (iz >= int(this->nz/2) + 1) iz -= this->nz;
module_basis/module_pw/pw_basis.cpp:        tmpgg[ig] = f * (this->GGT * f);
module_basis/module_pw/pw_basis.cpp:        if(tmpgg[ig] < 1e-8) this->ig_gge0 = ig;
module_basis/module_pw/pw_basis.cpp:    ModuleBase::GlobalFunc::ZEROS(sortindex, this->npw);
module_basis/module_pw/pw_basis.cpp:    ModuleBase::heapsort(this->npw, tmpgg, sortindex);
module_basis/module_pw/pw_basis.cpp:    this->ig2igg[sortindex[0]] = 0;
module_basis/module_pw/pw_basis.cpp:    for (int ig = 1; ig < this->npw; ++ig)
module_basis/module_pw/pw_basis.cpp:        this->ig2igg[sortindex[ig]] = igg;
module_basis/module_pw/pw_basis.cpp:    this->ngg = igg + 1;
module_basis/module_pw/pw_basis.cpp:    delete[] this->gg_uniq; this->gg_uniq = new double [this->ngg];
module_basis/module_pw/pw_basis.cpp:    for(int igg = 0 ; igg < this->ngg ; ++igg)
module_basis/module_pw/pw_basis.cpp:    for(int ixy = 0 ; ixy < this->fftnxy ; ++ixy)   fftixy2is[ixy] = -1;
module_basis/module_pw/pw_basis.cpp:    for(int is = 0; is < this->nst; ++is)
module_basis/module_pw/pw_basis.cpp:        for(; ixy < this->fftnxy ; ++ixy)
module_basis/module_pw/pw_basis.cpp:            if(this->is2fftixy[is] == ixy)
module_basis/module_pw/pw_basis.cpp:    this->device = std::move(device_);
module_basis/module_pw/pw_basis.cpp:    this->precision = std::move(precision_);
module_basis/module_pw/pw_basis.h:    //Count the total number of planewaves (tot_npw) and sticks (this->nstot) (in distributeg method1 and method2)
module_basis/module_pw/pw_basis_big.h:    this->lat0 = lat0_in;
module_basis/module_pw/pw_basis_big.h:    this->latvec = latvec_in;
module_basis/module_pw/pw_basis_big.h:    this->omega = std::abs(latvec.Det()) * lat0 * lat0 * lat0;
module_basis/module_pw/pw_basis_big.h:    this->GT = latvec.Inverse();
module_basis/module_pw/pw_basis_big.h:	this->G  = GT.Transpose();
module_basis/module_pw/pw_basis_big.h:	this->GGT = G * GT;
module_basis/module_pw/pw_basis_big.h:    this->tpiba = ModuleBase::TWO_PI / this->lat0;
module_basis/module_pw/pw_basis_big.h:    this->tpiba2 = this->tpiba * this->tpiba;
module_basis/module_pw/pw_basis_big.h:    this->gridecut_lat = gridecut / tpiba2;
module_basis/module_pw/pw_basis_big.h:    for(int igz = -ibox[2]+this->poolrank; igz <= ibox[2]; igz += this->poolnproc)
module_basis/module_pw/pw_basis_big.h:                double modulus = f * (this->GGT * f);
module_basis/module_pw/pw_basis_big.h:                if(modulus <= this->gridecut_lat)
module_basis/module_pw/pw_basis_big.h:    MPI_Allreduce(MPI_IN_PLACE, ibox, 3, MPI_INT, MPI_MAX , this->pool_world);
module_basis/module_pw/pw_basis_big.h:            if ((this->full_pw && this->full_pw_dim == 2) && b % 2 != 0) done_factoring = true; // full_pw_dim = 2 means FFT dimensions should be even.
module_basis/module_pw/pw_basis_big.h:				if (b % 2 == 0 && (!this->full_pw || this->full_pw_dim != 1)) // full_pw_dim = 1 means FFT dimension should be odd.
module_basis/module_pw/pw_basis_big.h:    if(!this->bz)
module_basis/module_pw/pw_basis_big.h:        this->autoset_big_cell_size(this->bz, ibox[2], this->poolnproc);
module_basis/module_pw/pw_basis_big.h:    if(!this->bx)
module_basis/module_pw/pw_basis_big.h:            this->bx = this->bz;
module_basis/module_pw/pw_basis_big.h:            this->autoset_big_cell_size(this->bx, ibox[0]);
module_basis/module_pw/pw_basis_big.h:    if(!this->by)
module_basis/module_pw/pw_basis_big.h:            this->by = this->bz;
module_basis/module_pw/pw_basis_big.h:            this->autoset_big_cell_size(this->by, ibox[1]);
module_basis/module_pw/pw_basis_big.h:    this->bxyz = this->bx * this->by * this->bz;
module_basis/module_pw/pw_basis_big.h:    if(ibox[0]%this->bx != 0) ibox[0] += (this->bx - ibox[0] % this->bx);
module_basis/module_pw/pw_basis_big.h:    if(ibox[1]%this->by != 0) ibox[1] += (this->by - ibox[1] % this->by);
module_basis/module_pw/pw_basis_big.h:    if(ibox[2]%this->bz != 0) ibox[2] += (this->bz - ibox[2] % this->bz);
module_basis/module_pw/pw_basis_big.h:    this->nx = ibox[0];
module_basis/module_pw/pw_basis_big.h:    this->ny = ibox[1];
module_basis/module_pw/pw_basis_big.h:    this->nz = ibox[2];
module_basis/module_pw/pw_basis_big.h:    this->nxy =this->nx * this->ny;
module_basis/module_pw/pw_basis_big.h:    this->nxyz = this->nxy * this->nz;
module_basis/module_pw/pw_basis_big.h:    this->nbx = this->nx / bx;
module_basis/module_pw/pw_basis_big.h:    this->nby = this->ny / by;
module_basis/module_pw/pw_basis_big.h:    this->nbz = this->nz / bz;
module_basis/module_pw/pw_basis_big.h:        this->lat0 = lat0_in;
module_basis/module_pw/pw_basis_big.h:        this->tpiba = ModuleBase::TWO_PI / this->lat0;
module_basis/module_pw/pw_basis_big.h:        this->tpiba2 = this->tpiba*this->tpiba;
module_basis/module_pw/pw_basis_big.h:        this->latvec = latvec_in;
module_basis/module_pw/pw_basis_big.h:        this->omega = std::abs(latvec.Det()) * lat0 * lat0 * lat0;
module_basis/module_pw/pw_basis_big.h:        this->GT = latvec.Inverse();
module_basis/module_pw/pw_basis_big.h:    	this->G  = GT.Transpose();
module_basis/module_pw/pw_basis_big.h:    	this->GGT = G * GT;
module_basis/module_pw/pw_basis_big.h:        this->nx = nx_in;
module_basis/module_pw/pw_basis_big.h:        this->ny = ny_in;
module_basis/module_pw/pw_basis_big.h:        this->nz = nz_in;
module_basis/module_pw/pw_basis_big.h:        if (!this->bz)
module_basis/module_pw/pw_basis_big.h:        this->autoset_big_cell_size(this->bz, nz, this->poolnproc);
module_basis/module_pw/pw_basis_big.h:        if (!this->bx)
module_basis/module_pw/pw_basis_big.h:            this->bx = this->bz;
module_basis/module_pw/pw_basis_big.h:            this->autoset_big_cell_size(this->bx, nx);
module_basis/module_pw/pw_basis_big.h:        if (!this->by)
module_basis/module_pw/pw_basis_big.h:            this->by = this->bz;
module_basis/module_pw/pw_basis_big.h:            this->autoset_big_cell_size(this->by, ny);
module_basis/module_pw/pw_basis_big.h:        this->bxyz = this->bx * this->by * this->bz;
module_basis/module_pw/pw_basis_big.h:        if(this->nx%this->bx != 0) this->nx += (this->bx - this->nx % this->bx);
module_basis/module_pw/pw_basis_big.h:        if(this->ny%this->by != 0) this->ny += (this->by - this->ny % this->by);
module_basis/module_pw/pw_basis_big.h:        if(this->nz%this->bz != 0) this->nz += (this->bz - this->nz % this->bz);
module_basis/module_pw/pw_basis_big.h:        this->nbx = this->nx / bx;
module_basis/module_pw/pw_basis_big.h:        this->nby = this->ny / by;
module_basis/module_pw/pw_basis_big.h:        this->nbz = this->nz / bz;
module_basis/module_pw/pw_basis_big.h:        this->nxy = this->nx * this->ny;
module_basis/module_pw/pw_basis_big.h:        this->nxyz = this->nxy * this->nz;
module_basis/module_pw/pw_basis_big.h:        ibox[0] = int((this->nx-1)/2)+1;
module_basis/module_pw/pw_basis_big.h:        ibox[1] = int((this->ny-1)/2)+1;
module_basis/module_pw/pw_basis_big.h:        ibox[2] = int((this->nz-1)/2)+1;
module_basis/module_pw/pw_basis_big.h:        this->gridecut_lat = 1e20;
module_basis/module_pw/pw_basis_big.h:                    if(count%this->poolnproc != this->poolrank) continue;
module_basis/module_pw/pw_basis_big.h:                    double modulus = f * (this->GGT * f);
module_basis/module_pw/pw_basis_big.h:                    if(modulus < this->gridecut_lat)
module_basis/module_pw/pw_basis_big.h:                        this->gridecut_lat = modulus;
module_basis/module_pw/pw_basis_big.h:        MPI_Allreduce(MPI_IN_PLACE, &this->gridecut_lat, 1, MPI_DOUBLE, MPI_MIN , this->pool_world);
module_basis/module_pw/pw_basis_big.h:        this->gridecut_lat -= 1e-6;
module_basis/module_pw/pw_basis_big.h:        delete[] this->numz; this->numz = new int[this->poolnproc];
module_basis/module_pw/pw_basis_big.h:        delete[] this->startz; this->startz = new int[this->poolnproc];
module_basis/module_pw/pw_basis_big.h:        ModuleBase::GlobalFunc::ZEROS(this->numz, this->poolnproc);
module_basis/module_pw/pw_basis_big.h:        ModuleBase::GlobalFunc::ZEROS(this->startz, this->poolnproc);
module_basis/module_pw/pw_basis_big.h:        int npbz = this->nbz / this->poolnproc;
module_basis/module_pw/pw_basis_big.h:        int modbz = this->nbz % this->poolnproc;
module_basis/module_pw/pw_basis_big.h:        this->startz[0] = 0;
module_basis/module_pw/pw_basis_big.h:        for(int ip = 0 ; ip < this->poolnproc ; ++ip)
module_basis/module_pw/pw_basis_big.h:            this->numz[ip] = npbz*this->bz;
module_basis/module_pw/pw_basis_big.h:            if(ip < modbz)   this->numz[ip]+=this->bz;
module_basis/module_pw/pw_basis_big.h:            if(ip < this->poolnproc - 1)   this->startz[ip+1] = this->startz[ip] + numz[ip];
module_basis/module_pw/pw_basis_big.h:            if(ip == this->poolrank) 
module_basis/module_pw/pw_basis_big.h:                this->nplane = numz[ip];
module_basis/module_pw/pw_basis_big.h:                this->startz_current = startz[ip];
module_basis/module_pw/pw_basis_big.h:        this->nbzp = this->nplane / this->bz;
module_basis/module_pw/pw_basis_big.h:        this->nrxx = this->numz[this->poolrank] * this->nxy;
module_basis/module_pw/pw_basis_big.h:        this->nbxx = this->nbzp * this->nbx * this->nby;
module_basis/module_pw/pw_basis_big.h:        this->nbzp_start = this->startz[this->poolrank] / this->bz;
module_basis/module_pw/pw_basis_k.cpp:    if (this->device == "gpu") {
module_basis/module_pw/pw_basis_k.cpp:        if (this->precision == "single") {
module_basis/module_pw/pw_basis_k.cpp:            delmem_sd_op()(gpu_ctx, this->s_kvec_c);
module_basis/module_pw/pw_basis_k.cpp:            delmem_sd_op()(gpu_ctx, this->s_gcar);
module_basis/module_pw/pw_basis_k.cpp:            delmem_sd_op()(gpu_ctx, this->s_gk2);
module_basis/module_pw/pw_basis_k.cpp:            delmem_dd_op()(gpu_ctx, this->d_gcar);
module_basis/module_pw/pw_basis_k.cpp:            delmem_dd_op()(gpu_ctx, this->d_gk2);
module_basis/module_pw/pw_basis_k.cpp:        delmem_dd_op()(gpu_ctx, this->d_kvec_c);
module_basis/module_pw/pw_basis_k.cpp:        delmem_int_op()(gpu_ctx, this->ig2ixyz_k);
module_basis/module_pw/pw_basis_k.cpp:        delmem_int_op()(gpu_ctx, this->d_igl2isz_k);
module_basis/module_pw/pw_basis_k.cpp:        if (this->precision == "single") {
module_basis/module_pw/pw_basis_k.cpp:            delmem_sh_op()(cpu_ctx, this->s_kvec_c);
module_basis/module_pw/pw_basis_k.cpp:            delmem_sh_op()(cpu_ctx, this->s_gcar);
module_basis/module_pw/pw_basis_k.cpp:            delmem_sh_op()(cpu_ctx, this->s_gk2);
module_basis/module_pw/pw_basis_k.cpp:    this->nks = nks_in;
module_basis/module_pw/pw_basis_k.cpp:    delete[] this->kvec_d; this->kvec_d = new ModuleBase::Vector3<double> [nks];
module_basis/module_pw/pw_basis_k.cpp:    delete[] this->kvec_c; this->kvec_c = new ModuleBase::Vector3<double> [nks];
module_basis/module_pw/pw_basis_k.cpp:    for(int ik = 0 ; ik < this->nks ; ++ik)
module_basis/module_pw/pw_basis_k.cpp:        this->kvec_d[ik] = kvec_d_in[ik];
module_basis/module_pw/pw_basis_k.cpp:        this->kvec_c[ik] = this->kvec_d[ik] * this->G;
module_basis/module_pw/pw_basis_k.cpp:        double kmod = sqrt(this->kvec_c[ik] * this->kvec_c[ik]);
module_basis/module_pw/pw_basis_k.cpp:    this->gk_ecut = gk_ecut_in/this->tpiba2;
module_basis/module_pw/pw_basis_k.cpp:    this->ggecut = pow(sqrt(this->gk_ecut) + kmaxmod, 2);
module_basis/module_pw/pw_basis_k.cpp:    if(this->ggecut > this->gridecut_lat)
module_basis/module_pw/pw_basis_k.cpp:        this->ggecut = this->gridecut_lat;
module_basis/module_pw/pw_basis_k.cpp:        this->gk_ecut = pow(sqrt(this->ggecut) - kmaxmod ,2);
module_basis/module_pw/pw_basis_k.cpp:    this->gamma_only = gamma_only_in;
module_basis/module_pw/pw_basis_k.cpp:    if(kmaxmod > 0)     this->gamma_only = false; //if it is not the gamma point, we do not use gamma_only
module_basis/module_pw/pw_basis_k.cpp:    this->xprime = xprime_in;
module_basis/module_pw/pw_basis_k.cpp:    this->fftny = this->ny;
module_basis/module_pw/pw_basis_k.cpp:    this->fftnx = this->nx;
module_basis/module_pw/pw_basis_k.cpp:    if (this->gamma_only)   
module_basis/module_pw/pw_basis_k.cpp:        if(this->xprime) this->fftnx = int(this->nx / 2) + 1;
module_basis/module_pw/pw_basis_k.cpp:        else            this->fftny = int(this->ny / 2) + 1;
module_basis/module_pw/pw_basis_k.cpp:    this->fftnz = this->nz;
module_basis/module_pw/pw_basis_k.cpp:    this->fftnxy = this->fftnx * this->fftny;
module_basis/module_pw/pw_basis_k.cpp:    this->fftnxyz = this->fftnxy * this->fftnz;
module_basis/module_pw/pw_basis_k.cpp:    this->distribution_type = distribution_type_in;
module_basis/module_pw/pw_basis_k.cpp:    if (this->device == "gpu") {
module_basis/module_pw/pw_basis_k.cpp:        if (this->precision == "single") {
module_basis/module_pw/pw_basis_k.cpp:            resmem_sd_op()(gpu_ctx, this->s_kvec_c, this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_kvec_c, reinterpret_cast<double *>(&this->kvec_c[0][0]), this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:        resmem_dd_op()(gpu_ctx, this->d_kvec_c, this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:        syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_kvec_c, reinterpret_cast<double *>(&this->kvec_c[0][0]), this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:        if (this->precision == "single") {
module_basis/module_pw/pw_basis_k.cpp:            resmem_sh_op()(cpu_ctx, this->s_kvec_c, this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_kvec_c, reinterpret_cast<double *>(&this->kvec_c[0][0]), this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:        this->d_kvec_c = reinterpret_cast<double *>(&this->kvec_c[0][0]);
module_basis/module_pw/pw_basis_k.cpp:    this->npwk_max = 0;
module_basis/module_pw/pw_basis_k.cpp:    delete[] this->npwk; this->npwk = new int [this->nks];
module_basis/module_pw/pw_basis_k.cpp:    for (int ik = 0; ik < this->nks; ik++)
module_basis/module_pw/pw_basis_k.cpp:        for (int ig = 0; ig < this->npw ; ig++)
module_basis/module_pw/pw_basis_k.cpp:            const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2();       
module_basis/module_pw/pw_basis_k.cpp:            if (gk2 <= this->gk_ecut)
module_basis/module_pw/pw_basis_k.cpp:        this->npwk[ik] = ng;
module_basis/module_pw/pw_basis_k.cpp:        if ( this->npwk_max < ng)
module_basis/module_pw/pw_basis_k.cpp:            this->npwk_max = ng;
module_basis/module_pw/pw_basis_k.cpp:    if(this->npwk_max <= 0) return;
module_basis/module_pw/pw_basis_k.cpp:    delete[] igl2isz_k; this->igl2isz_k = new int [this->nks * this->npwk_max];
module_basis/module_pw/pw_basis_k.cpp:    delete[] igl2ig_k; this->igl2ig_k = new int [this->nks * this->npwk_max];
module_basis/module_pw/pw_basis_k.cpp:    for (int ik = 0; ik < this->nks; ik++)
module_basis/module_pw/pw_basis_k.cpp:        for (int ig = 0; ig < this->npw ; ig++)
module_basis/module_pw/pw_basis_k.cpp:            const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2();       
module_basis/module_pw/pw_basis_k.cpp:            if (gk2 <= this->gk_ecut)
module_basis/module_pw/pw_basis_k.cpp:                this->igl2isz_k[ik*npwk_max + igl] = this->ig2isz[ig];
module_basis/module_pw/pw_basis_k.cpp:                this->igl2ig_k[ik*npwk_max + igl] = ig;
module_basis/module_pw/pw_basis_k.cpp:    if (this->device == "gpu") {
module_basis/module_pw/pw_basis_k.cpp:        resmem_int_op()(gpu_ctx, this->d_igl2isz_k, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:        syncmem_int_h2d_op()(gpu_ctx, cpu_ctx, this->d_igl2isz_k, this->igl2isz_k, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:    ModuleBase::timer::tick(this->classname, "setuptransform");
module_basis/module_pw/pw_basis_k.cpp:    this->distribute_r();
module_basis/module_pw/pw_basis_k.cpp:    this->distribute_g();
module_basis/module_pw/pw_basis_k.cpp:    this->getstartgr();
module_basis/module_pw/pw_basis_k.cpp:    this->setupIndGk();
module_basis/module_pw/pw_basis_k.cpp:    this->ft.clear();
module_basis/module_pw/pw_basis_k.cpp:    if(this->xprime)    this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime);
module_basis/module_pw/pw_basis_k.cpp:    else                this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime);
module_basis/module_pw/pw_basis_k.cpp:    this->ft.setupFFT();
module_basis/module_pw/pw_basis_k.cpp:    ModuleBase::timer::tick(this->classname, "setuptransform");
module_basis/module_pw/pw_basis_k.cpp:    this->erf_ecut = erf_ecut_in;
module_basis/module_pw/pw_basis_k.cpp:    this->erf_height = erf_height_in;
module_basis/module_pw/pw_basis_k.cpp:    this->erf_sigma = erf_sigma_in;
module_basis/module_pw/pw_basis_k.cpp:    if(this->npwk_max <= 0) return;
module_basis/module_pw/pw_basis_k.cpp:    this->gk2 = new double[this->npwk_max * this->nks];
module_basis/module_pw/pw_basis_k.cpp:    this->gcar = new ModuleBase::Vector3<double>[this->npwk_max * this->nks];
module_basis/module_pw/pw_basis_k.cpp:    ModuleBase::Memory::record("PW_B_K::gk2", sizeof(double) * this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:    ModuleBase::Memory::record("PW_B_K::gcar", sizeof(ModuleBase::Vector3<double>) * this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:    for(int ik = 0 ; ik < this->nks ; ++ik)
module_basis/module_pw/pw_basis_k.cpp:        ModuleBase::Vector3<double> kv = this->kvec_d[ik];
module_basis/module_pw/pw_basis_k.cpp:        for(int igl = 0 ; igl < this-> npwk[ik] ; ++igl)
module_basis/module_pw/pw_basis_k.cpp:            int isz = this->igl2isz_k[ik * npwk_max + igl];
module_basis/module_pw/pw_basis_k.cpp:            int iz = isz % this->nz;
module_basis/module_pw/pw_basis_k.cpp:            int is = isz / this->nz;
module_basis/module_pw/pw_basis_k.cpp:            int ixy = this->is2fftixy[is];
module_basis/module_pw/pw_basis_k.cpp:            int ix = ixy / this->fftny;
module_basis/module_pw/pw_basis_k.cpp:            int iy = ixy % this->fftny;
module_basis/module_pw/pw_basis_k.cpp:            if (ix >= int(this->nx/2) + 1) ix -= this->nx;
module_basis/module_pw/pw_basis_k.cpp:            if (iy >= int(this->ny/2) + 1) iy -= this->ny;
module_basis/module_pw/pw_basis_k.cpp:            if (iz >= int(this->nz/2) + 1) iz -= this->nz;
module_basis/module_pw/pw_basis_k.cpp:            this->gcar[ik * npwk_max + igl] = f * this->G;
module_basis/module_pw/pw_basis_k.cpp:            double temp_gk2 = (f + kv) * (this->GGT * (f + kv));
module_basis/module_pw/pw_basis_k.cpp:                this->gk2[ik * npwk_max + igl]
module_basis/module_pw/pw_basis_k.cpp:                this->gk2[ik * npwk_max + igl] = temp_gk2;
module_basis/module_pw/pw_basis_k.cpp:    if (this->device == "gpu") {
module_basis/module_pw/pw_basis_k.cpp:        if (this->precision == "single") {
module_basis/module_pw/pw_basis_k.cpp:            resmem_sd_op()(gpu_ctx, this->s_gk2, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:            resmem_sd_op()(gpu_ctx, this->s_gcar, this->npwk_max * this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_gk2, this->gk2, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_gcar, reinterpret_cast<double *>(&this->gcar[0][0]), this->npwk_max * this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:            resmem_dd_op()(gpu_ctx, this->d_gk2, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:            resmem_dd_op()(gpu_ctx, this->d_gcar, this->npwk_max * this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:            syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_gk2, this->gk2, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:            syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_gcar, reinterpret_cast<double *>(&this->gcar[0][0]), this->npwk_max * this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:        if (this->precision == "single") {
module_basis/module_pw/pw_basis_k.cpp:            resmem_sh_op()(cpu_ctx, this->s_gk2, this->npwk_max * this->nks, "PW_B_K::s_gk2");
module_basis/module_pw/pw_basis_k.cpp:            resmem_sh_op()(cpu_ctx, this->s_gcar, this->npwk_max * this->nks * 3, "PW_B_K::s_gcar");
module_basis/module_pw/pw_basis_k.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_gk2, this->gk2, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_gcar, reinterpret_cast<double *>(&this->gcar[0][0]), this->npwk_max * this->nks * 3);
module_basis/module_pw/pw_basis_k.cpp:            this->d_gcar = reinterpret_cast<double *>(&this->gcar[0][0]);
module_basis/module_pw/pw_basis_k.cpp:            this->d_gk2 = this->gk2;
module_basis/module_pw/pw_basis_k.cpp:    int isz = this->ig2isz[ig];
module_basis/module_pw/pw_basis_k.cpp:    int iz = isz % this->nz;
module_basis/module_pw/pw_basis_k.cpp:    int is = isz / this->nz;
module_basis/module_pw/pw_basis_k.cpp:    int ix = this->is2fftixy[is] / this->fftny;
module_basis/module_pw/pw_basis_k.cpp:    int iy = this->is2fftixy[is] % this->fftny;
module_basis/module_pw/pw_basis_k.cpp:    if (ix >= int(this->nx/2) + 1) ix -= this->nx;
module_basis/module_pw/pw_basis_k.cpp:    if (iy >= int(this->ny/2) + 1) iy -= this->ny;
module_basis/module_pw/pw_basis_k.cpp:    if (iz >= int(this->nz/2) + 1) iz -= this->nz;
module_basis/module_pw/pw_basis_k.cpp:    f = f * this->G;
module_basis/module_pw/pw_basis_k.cpp:    ModuleBase::Vector3<double> g_temp_ = this->kvec_c[ik] + f;
module_basis/module_pw/pw_basis_k.cpp:    return this->gk2[ik * this->npwk_max + igl];
module_basis/module_pw/pw_basis_k.cpp:    return this->gcar[ik * this->npwk_max + igl];
module_basis/module_pw/pw_basis_k.cpp:    ModuleBase::Vector3<double> f = this->latvec * this->gcar[ik * this->npwk_max + igl];
module_basis/module_pw/pw_basis_k.cpp:    return this->gcar[ik * this->npwk_max + igl]+this->kvec_c[ik];
module_basis/module_pw/pw_basis_k.cpp:    return this->igl2isz_k[ik*this->npwk_max + igl];
module_basis/module_pw/pw_basis_k.cpp:    return this->igl2ig_k[ik*this->npwk_max + igl];
module_basis/module_pw/pw_basis_k.cpp:    delete[] this->ig2ixyz_k_;
module_basis/module_pw/pw_basis_k.cpp:    this->ig2ixyz_k_ = new int [this->npwk_max * this->nks];
module_basis/module_pw/pw_basis_k.cpp:    ModuleBase::Memory::record("PW_B_K::ig2ixyz", sizeof(int) * this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:    for(int ik = 0; ik < this->nks; ++ik)
module_basis/module_pw/pw_basis_k.cpp:        for(int igl = 0; igl < this->npwk[ik]; ++igl)
module_basis/module_pw/pw_basis_k.cpp:            int isz = this->igl2isz_k[igl + ik * npwk_max];
module_basis/module_pw/pw_basis_k.cpp:            int iz = isz % this->nz;
module_basis/module_pw/pw_basis_k.cpp:            int is = isz / this->nz;
module_basis/module_pw/pw_basis_k.cpp:            int ixy = this->is2fftixy[is];
module_basis/module_pw/pw_basis_k.cpp:            int iy = ixy % this->ny;
module_basis/module_pw/pw_basis_k.cpp:            int ix = ixy / this->ny;
module_basis/module_pw/pw_basis_k.cpp:    if (this->device == "gpu") {
module_basis/module_pw/pw_basis_k.cpp:        resmem_int_op()(gpu_ctx, ig2ixyz_k, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:        syncmem_int_h2d_op()(gpu_ctx, cpu_ctx, this->ig2ixyz_k, this->ig2ixyz_k_, this->npwk_max * this->nks);
module_basis/module_pw/pw_basis_k.cpp:        int isz = this->igl2isz_k[ig + ik * npwk_max];
module_basis/module_pw/pw_basis_k.cpp:        int is = isz / this->nz;
module_basis/module_pw/pw_basis_k.cpp:        int ixy = this->is2fftixy[is];
module_basis/module_pw/pw_basis_k.cpp:        int ix = ixy / this->ny;
module_basis/module_pw/pw_basis_k.cpp:        int isz = this->igl2isz_k[ig + ik * npwk_max];
module_basis/module_pw/pw_basis_k.cpp:        int is = isz / this->nz;
module_basis/module_pw/pw_basis_k.cpp:        int ixy = this->is2fftixy[is];
module_basis/module_pw/pw_basis_k.cpp:        int iy = ixy % this->ny;
module_basis/module_pw/pw_basis_k.cpp:        int isz = this->igl2isz_k[ig + ik * npwk_max];
module_basis/module_pw/pw_basis_k.cpp:        int iz = isz % this->nz;
module_basis/module_pw/pw_basis_k.cpp:    return this->s_kvec_c;
module_basis/module_pw/pw_basis_k.cpp:    return this->d_kvec_c;
module_basis/module_pw/pw_basis_k.cpp:    return this->s_gcar;
module_basis/module_pw/pw_basis_k.cpp:    return this->d_gcar;
module_basis/module_pw/pw_basis_k.cpp:    return this->s_gk2;
module_basis/module_pw/pw_basis_k.cpp:    return this->d_gk2;
module_basis/module_pw/pw_basis_k_big.h:        this->nbx = this->nx / bx;
module_basis/module_pw/pw_basis_k_big.h:        this->nby = this->ny / by;
module_basis/module_pw/pw_basis_k_big.h:        this->nbz = this->nz / bz;
module_basis/module_pw/pw_basis_k_big.h:        delete[] this->numz; this->numz = new int[this->poolnproc];
module_basis/module_pw/pw_basis_k_big.h:        delete[] this->startz; this->startz = new int[this->poolnproc];
module_basis/module_pw/pw_basis_k_big.h:        ModuleBase::GlobalFunc::ZEROS(this->numz, this->poolnproc);
module_basis/module_pw/pw_basis_k_big.h:        ModuleBase::GlobalFunc::ZEROS(this->startz, this->poolnproc);
module_basis/module_pw/pw_basis_k_big.h:        int npbz = this->nbz / this->poolnproc;
module_basis/module_pw/pw_basis_k_big.h:        int modbz = this->nbz % this->poolnproc;
module_basis/module_pw/pw_basis_k_big.h:        this->startz[0] = 0;
module_basis/module_pw/pw_basis_k_big.h:        for(int ip = 0 ; ip < this->poolnproc ; ++ip)
module_basis/module_pw/pw_basis_k_big.h:            this->numz[ip] = npbz*this->bz;
module_basis/module_pw/pw_basis_k_big.h:            if(ip < modbz)   this->numz[ip]+=this->bz;
module_basis/module_pw/pw_basis_k_big.h:            if(ip < this->poolnproc - 1)   this->startz[ip+1] = this->startz[ip] + numz[ip];
module_basis/module_pw/pw_basis_k_big.h:            if(ip == this->poolrank) 
module_basis/module_pw/pw_basis_k_big.h:                this->nplane = numz[ip];
module_basis/module_pw/pw_basis_k_big.h:                this->startz_current = startz[ip];
module_basis/module_pw/pw_basis_k_big.h:        this->nrxx = this->numz[this->poolrank] * this->nxy;
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::timer::tick(this->classname, "setuptransform");
module_basis/module_pw/pw_basis_sup.cpp:    this->distribute_r();
module_basis/module_pw/pw_basis_sup.cpp:    this->distribute_g(pw_rho);
module_basis/module_pw/pw_basis_sup.cpp:    this->getstartgr();
module_basis/module_pw/pw_basis_sup.cpp:    this->ft.clear();
module_basis/module_pw/pw_basis_sup.cpp:    if (this->xprime)
module_basis/module_pw/pw_basis_sup.cpp:        this->ft.initfft(this->nx,
module_basis/module_pw/pw_basis_sup.cpp:                         this->ny,
module_basis/module_pw/pw_basis_sup.cpp:                         this->nz,
module_basis/module_pw/pw_basis_sup.cpp:                         this->lix,
module_basis/module_pw/pw_basis_sup.cpp:                         this->rix,
module_basis/module_pw/pw_basis_sup.cpp:                         this->nst,
module_basis/module_pw/pw_basis_sup.cpp:                         this->nplane,
module_basis/module_pw/pw_basis_sup.cpp:                         this->poolnproc,
module_basis/module_pw/pw_basis_sup.cpp:                         this->gamma_only,
module_basis/module_pw/pw_basis_sup.cpp:                         this->xprime);
module_basis/module_pw/pw_basis_sup.cpp:        this->ft.initfft(this->nx,
module_basis/module_pw/pw_basis_sup.cpp:                         this->ny,
module_basis/module_pw/pw_basis_sup.cpp:                         this->nz,
module_basis/module_pw/pw_basis_sup.cpp:                         this->liy,
module_basis/module_pw/pw_basis_sup.cpp:                         this->riy,
module_basis/module_pw/pw_basis_sup.cpp:                         this->nst,
module_basis/module_pw/pw_basis_sup.cpp:                         this->nplane,
module_basis/module_pw/pw_basis_sup.cpp:                         this->poolnproc,
module_basis/module_pw/pw_basis_sup.cpp:                         this->gamma_only,
module_basis/module_pw/pw_basis_sup.cpp:                         this->xprime);
module_basis/module_pw/pw_basis_sup.cpp:    this->ft.setupFFT();
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::timer::tick(this->classname, "setuptransform");
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::timer::tick(this->classname, "distributeg");
module_basis/module_pw/pw_basis_sup.cpp:    this->distribution_method3(pw_rho);
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::CHECK_WARNING_QUIT((this->npw == 0),
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::timer::tick(this->classname, "distributeg");
module_basis/module_pw/pw_basis_sup.cpp:    delete[] this->nst_per;
module_basis/module_pw/pw_basis_sup.cpp:    this->nst_per = new int[this->poolnproc]; // number of sticks on each core.
module_basis/module_pw/pw_basis_sup.cpp:    delete[] this->npw_per;
module_basis/module_pw/pw_basis_sup.cpp:    this->npw_per = new int[this->poolnproc]; // number of planewaves on each core.
module_basis/module_pw/pw_basis_sup.cpp:    delete[] this->fftixy2ip;
module_basis/module_pw/pw_basis_sup.cpp:    this->fftixy2ip = new int[this->fftnxy]; // ip of core which contains the stick on (x, y).
module_basis/module_pw/pw_basis_sup.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_basis_sup.cpp:        this->fftixy2ip[ixy] = -1; // meaning this stick has not been distributed or there is no stick on (x, y).
module_basis/module_pw/pw_basis_sup.cpp:        // (1) Count the total number of planewaves (tot_npw) and sticks (this->nstot).
module_basis/module_pw/pw_basis_sup.cpp:        // calculate this->nstot and this->npwtot, liy, riy
module_basis/module_pw/pw_basis_sup.cpp:        this->count_pw_st(st_length2D, st_bottom2D);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(&this->npwtot, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(&this->nstot, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(&liy, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(&riy, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(&lix, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(&rix, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    delete[] this->istot2ixy;
module_basis/module_pw/pw_basis_sup.cpp:    this->istot2ixy = new int[this->nstot];
module_basis/module_pw/pw_basis_sup.cpp:        int* st_i = new int[this->nstot];      // x or x + fftnx (if x < 0) of stick.
module_basis/module_pw/pw_basis_sup.cpp:        int* st_j = new int[this->nstot];      // y or y + fftny (if y < 0) of stick.
module_basis/module_pw/pw_basis_sup.cpp:        int* st_length = new int[this->nstot]; // number of planewaves in stick.
module_basis/module_pw/pw_basis_sup.cpp:        this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length);
module_basis/module_pw/pw_basis_sup.cpp:        this->startnsz_per = new int[this->poolnproc];
module_basis/module_pw/pw_basis_sup.cpp:        this->divide_sticks_3(st_length2D, st_i, st_j, st_length, pw_rho->fftixy2ip, pw_rho->nx, pw_rho->ny);
module_basis/module_pw/pw_basis_sup.cpp:        this->get_istot2ixy(st_i, st_j);
module_basis/module_pw/pw_basis_sup.cpp:        delete[] this->startnsz_per;
module_basis/module_pw/pw_basis_sup.cpp:        this->startnsz_per = nullptr;
module_basis/module_pw/pw_basis_sup.cpp:        this->nst_per[0] = this->nstot;
module_basis/module_pw/pw_basis_sup.cpp:        this->npw_per[0] = this->npwtot;
module_basis/module_pw/pw_basis_sup.cpp:                this->istot2ixy[st_move] = ixy / fftny * ny + ixy % fftny;
module_basis/module_pw/pw_basis_sup.cpp:                this->fftixy2ip[ixy] = 0;
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(st_length2D, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(st_bottom2D, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(this->fftixy2ip, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(this->istot2ixy, this->nstot, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(this->nst_per, this->poolnproc, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    MPI_Bcast(this->npw_per, this->poolnproc, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_basis_sup.cpp:    this->npw = this->npw_per[this->poolrank];
module_basis/module_pw/pw_basis_sup.cpp:    this->nst = this->nst_per[this->poolrank];
module_basis/module_pw/pw_basis_sup.cpp:    this->nstnz = this->nst * this->nz;
module_basis/module_pw/pw_basis_sup.cpp:    this->get_ig2isz_is2fftixy(st_bottom2D, st_length2D, pw_rho);
module_basis/module_pw/pw_basis_sup.cpp:/// distribute the stick to it, then update npw_per, this->fftixy2ip, and this->startnsz_per.
module_basis/module_pw/pw_basis_sup.cpp:/// known: tot_npw, this->nstot, st_i, st_j, st_length
module_basis/module_pw/pw_basis_sup.cpp:/// output: npw_per, nst_per, this->fftixy2ip, this->startnsz_per
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::GlobalFunc::ZEROS(this->nst_per, poolnproc);
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::GlobalFunc::ZEROS(this->npw_per, poolnproc);
module_basis/module_pw/pw_basis_sup.cpp:    if (this->gamma_only)
module_basis/module_pw/pw_basis_sup.cpp:        if (this->xprime)
module_basis/module_pw/pw_basis_sup.cpp:        int index = ix * this->fftny + iy;
module_basis/module_pw/pw_basis_sup.cpp:            this->fftixy2ip[index] = ip;
module_basis/module_pw/pw_basis_sup.cpp:            this->nst_per[ip]++;
module_basis/module_pw/pw_basis_sup.cpp:            this->npw_per[ip] += st_length2D[index];
module_basis/module_pw/pw_basis_sup.cpp:    for (int is = 0; is < this->nstot; ++is)
module_basis/module_pw/pw_basis_sup.cpp:        if (this->fftixy2ip[st_i[is] * this->fftny + st_j[is]] >= 0)
module_basis/module_pw/pw_basis_sup.cpp:        for (int ip = 0; ip < this->poolnproc; ++ip)
module_basis/module_pw/pw_basis_sup.cpp:            const int npwmin = this->npw_per[ipmin];
module_basis/module_pw/pw_basis_sup.cpp:            const int npw_ip = this->npw_per[ip];
module_basis/module_pw/pw_basis_sup.cpp:        this->nst_per[ipmin]++;
module_basis/module_pw/pw_basis_sup.cpp:        this->npw_per[ipmin] += st_length[is];
module_basis/module_pw/pw_basis_sup.cpp:        this->fftixy2ip[st_i[is] * this->fftny + st_j[is]] = ipmin;
module_basis/module_pw/pw_basis_sup.cpp:    this->startnsz_per[0] = 0;
module_basis/module_pw/pw_basis_sup.cpp:        this->startnsz_per[ip] = this->startnsz_per[ip - 1] + this->nst_per[ip - 1] * this->nz;
module_basis/module_pw/pw_basis_sup.cpp:/// known: this->nstot, st_bottom2D, st_length2D
module_basis/module_pw/pw_basis_sup.cpp:    int* st_bottom2D, // minimum z of stick, stored in 1d array with this->nstot elements.
module_basis/module_pw/pw_basis_sup.cpp:    if (this->npw == 0)
module_basis/module_pw/pw_basis_sup.cpp:        delete[] this->ig2isz;
module_basis/module_pw/pw_basis_sup.cpp:        this->ig2isz = nullptr; // map ig to the z coordinate of this planewave.
module_basis/module_pw/pw_basis_sup.cpp:        delete[] this->is2fftixy;
module_basis/module_pw/pw_basis_sup.cpp:        this->is2fftixy = nullptr; // map is (index of sticks) to ixy (iy + ix * fftny).
module_basis/module_pw/pw_basis_sup.cpp:        if (this->device == "gpu")
module_basis/module_pw/pw_basis_sup.cpp:            delmem_int_op()(gpu_ctx, this->d_is2fftixy);
module_basis/module_pw/pw_basis_sup.cpp:    delete[] this->ig2isz;
module_basis/module_pw/pw_basis_sup.cpp:    this->ig2isz = new int[this->npw]; // map ig to the z coordinate of this planewave.
module_basis/module_pw/pw_basis_sup.cpp:    ModuleBase::GlobalFunc::ZEROS(this->ig2isz, this->npw);
module_basis/module_pw/pw_basis_sup.cpp:    delete[] this->is2fftixy;
module_basis/module_pw/pw_basis_sup.cpp:    this->is2fftixy = new int[this->nst]; // map is (index of sticks) to ixy (iy + ix * fftny).
module_basis/module_pw/pw_basis_sup.cpp:    for (int is = 0; is < this->nst; ++is)
module_basis/module_pw/pw_basis_sup.cpp:        this->is2fftixy[is] = -1;
module_basis/module_pw/pw_basis_sup.cpp:    int* fftixy2is = new int[this->fftnxy]; // map ixy to is.
module_basis/module_pw/pw_basis_sup.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_basis_sup.cpp:    bool* found = new bool[this->fftnxyz]; // whether the planewave on (x, y, z) has been found on the smooth grid.
module_basis/module_pw/pw_basis_sup.cpp:    for (int i = 0; i < this->fftnxyz; ++i)
module_basis/module_pw/pw_basis_sup.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_basis_sup.cpp:        if (this->fftixy2ip[ixy] == this->poolrank)
module_basis/module_pw/pw_basis_sup.cpp:            this->is2fftixy[st_move] = ixy;
module_basis/module_pw/pw_basis_sup.cpp:        if (st_move == this->nst)
module_basis/module_pw/pw_basis_sup.cpp:            ix += this->nx;
module_basis/module_pw/pw_basis_sup.cpp:            iy += this->ny;
module_basis/module_pw/pw_basis_sup.cpp:            iz += this->nz;
module_basis/module_pw/pw_basis_sup.cpp:        int ixy_now = ix * this->fftny + iy;
module_basis/module_pw/pw_basis_sup.cpp:        int index = ixy_now * this->nz + iz;
module_basis/module_pw/pw_basis_sup.cpp:        int isz_now = is_now * this->nz + iz;
module_basis/module_pw/pw_basis_sup.cpp:        this->ig2isz[ig] = isz_now;
module_basis/module_pw/pw_basis_sup.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_basis_sup.cpp:        if (this->fftixy2ip[ixy] == this->poolrank)
module_basis/module_pw/pw_basis_sup.cpp:                    z += this->nz;
module_basis/module_pw/pw_basis_sup.cpp:                if (!found[ixy * this->nz + z])
module_basis/module_pw/pw_basis_sup.cpp:                    found[ixy * this->nz + z] = true;
module_basis/module_pw/pw_basis_sup.cpp:                    this->ig2isz[pw_filled] = is * this->nz + z;
module_basis/module_pw/pw_basis_sup.cpp:        if (pw_filled == this->npw)
module_basis/module_pw/pw_basis_sup.cpp:    if (this->device == "gpu")
module_basis/module_pw/pw_basis_sup.cpp:        resmem_int_op()(gpu_ctx, d_is2fftixy, this->nst);
module_basis/module_pw/pw_basis_sup.cpp:        syncmem_int_h2d_op()(gpu_ctx, cpu_ctx, this->d_is2fftixy, this->is2fftixy, this->nst);
module_basis/module_pw/pw_basis_sup.h:    void get_ig2isz_is2fftixy(int* st_bottom2D, // minimum z of stick, stored in 1d array with this->nstot elements.
module_basis/module_pw/pw_distributeg.cpp:    ModuleBase::timer::tick(this->classname, "distributeg");
module_basis/module_pw/pw_distributeg.cpp:    if(this->distribution_type == 1)
module_basis/module_pw/pw_distributeg.cpp:        this->distribution_method1();
module_basis/module_pw/pw_distributeg.cpp:    else if(this->distribution_type == 2)
module_basis/module_pw/pw_distributeg.cpp:        this->distribution_method2();
module_basis/module_pw/pw_distributeg.cpp:    ModuleBase::CHECK_WARNING_QUIT((this->npw == 0), "pw_distributeg.cpp", "Current core has no plane waves! Please reduce the cores.");
module_basis/module_pw/pw_distributeg.cpp:    ModuleBase::timer::tick(this->classname, "distributeg");
module_basis/module_pw/pw_distributeg.cpp:/// (1) We count the total number of planewaves (tot_npw) and sticks (this->nstot) here.
module_basis/module_pw/pw_distributeg.cpp:/// output: tot_npw, this->nstot, st_length2D, st_bottom2D, this->riy, this->liy
module_basis/module_pw/pw_distributeg.cpp:    ModuleBase::GlobalFunc::ZEROS(st_length2D, this->fftnxy);
module_basis/module_pw/pw_distributeg.cpp:    ModuleBase::GlobalFunc::ZEROS(st_bottom2D, this->fftnxy);
module_basis/module_pw/pw_distributeg.cpp:    int ix_end = int(this->nx / 2) + 1;
module_basis/module_pw/pw_distributeg.cpp:    int iy_end = int(this->ny / 2) + 1;
module_basis/module_pw/pw_distributeg.cpp:    int iz_end = int(this->nz / 2) + 1;
module_basis/module_pw/pw_distributeg.cpp:    if (this->full_pw)
module_basis/module_pw/pw_distributeg.cpp:        ix_end = int(this->nx / 2);
module_basis/module_pw/pw_distributeg.cpp:        ix_start = ix_end - this->nx + 1; 
module_basis/module_pw/pw_distributeg.cpp:        iy_end = int(this->ny / 2);
module_basis/module_pw/pw_distributeg.cpp:        iy_start = iy_end - this->ny + 1; 
module_basis/module_pw/pw_distributeg.cpp:        iz_end = int(this->nz / 2);
module_basis/module_pw/pw_distributeg.cpp:        iz_start = iz_end - this->nz + 1;
module_basis/module_pw/pw_distributeg.cpp:    if (this->gamma_only)
module_basis/module_pw/pw_distributeg.cpp:        if(this->xprime)
module_basis/module_pw/pw_distributeg.cpp:            ix_end = this->fftnx - 1;
module_basis/module_pw/pw_distributeg.cpp:            iy_end = this->fftny - 1;
module_basis/module_pw/pw_distributeg.cpp:    this->liy = this->riy = 0;
module_basis/module_pw/pw_distributeg.cpp:    this->lix = this->rix = 0;
module_basis/module_pw/pw_distributeg.cpp:    this->npwtot = 0;
module_basis/module_pw/pw_distributeg.cpp:    this->nstot = 0;
module_basis/module_pw/pw_distributeg.cpp:            if (x < 0) x += this->nx;
module_basis/module_pw/pw_distributeg.cpp:            if (y < 0) y += this->ny;
module_basis/module_pw/pw_distributeg.cpp:            int index = x * this->fftny + y;
module_basis/module_pw/pw_distributeg.cpp:                double modulus = f * (this->GGT * f);
module_basis/module_pw/pw_distributeg.cpp:                if (modulus <= this->ggecut || this->full_pw)
module_basis/module_pw/pw_distributeg.cpp:                    ++this->npwtot;
module_basis/module_pw/pw_distributeg.cpp:                    if(iy < this->riy) this->riy = iy;
module_basis/module_pw/pw_distributeg.cpp:                    if(iy > this->liy) this->liy = iy;
module_basis/module_pw/pw_distributeg.cpp:                    if(ix < this->rix) this->rix = ix;
module_basis/module_pw/pw_distributeg.cpp:                    if(ix > this->lix) this->lix = ix;
module_basis/module_pw/pw_distributeg.cpp:                ++this->nstot;
module_basis/module_pw/pw_distributeg.cpp:    riy += this->ny;
module_basis/module_pw/pw_distributeg.cpp:    rix += this->nx;
module_basis/module_pw/pw_distributeg.cpp:/// known: this->nstot, st_bottom2D, st_length2D
module_basis/module_pw/pw_distributeg.cpp:    int* st_bottom2D,     // minimum z of stick, stored in 1d array with this->nstot elements.
module_basis/module_pw/pw_distributeg.cpp:    if (this->npw == 0)
module_basis/module_pw/pw_distributeg.cpp:        delete[] this->ig2isz; this->ig2isz = nullptr; // map ig to the z coordinate of this planewave.
module_basis/module_pw/pw_distributeg.cpp:        delete[] this->is2fftixy; this->is2fftixy = nullptr; // map is (index of sticks) to ixy (iy + ix * fftny).
module_basis/module_pw/pw_distributeg.cpp:        if (this->device == "gpu") {
module_basis/module_pw/pw_distributeg.cpp:            delmem_int_op()(gpu_ctx, this->d_is2fftixy);
module_basis/module_pw/pw_distributeg.cpp:    delete[] this->ig2isz; this->ig2isz = new int[this->npw]; // map ig to the z coordinate of this planewave.
module_basis/module_pw/pw_distributeg.cpp:    ModuleBase::GlobalFunc::ZEROS(this->ig2isz, this->npw);
module_basis/module_pw/pw_distributeg.cpp:    delete[] this->is2fftixy; this->is2fftixy = new int[this->nst]; // map is (index of sticks) to ixy (iy + ix * fftny).
module_basis/module_pw/pw_distributeg.cpp:    for (int is = 0; is < this->nst; ++is) 
module_basis/module_pw/pw_distributeg.cpp:        this->is2fftixy[is] = -1;
module_basis/module_pw/pw_distributeg.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_distributeg.cpp:        if (this->fftixy2ip[ixy] == this->poolrank)
module_basis/module_pw/pw_distributeg.cpp:                if (z < 0) z += this->nz;
module_basis/module_pw/pw_distributeg.cpp:                this->ig2isz[pw_filled] = st_move * this->nz + z;
module_basis/module_pw/pw_distributeg.cpp:            this->is2fftixy[st_move] = ixy;
module_basis/module_pw/pw_distributeg.cpp:        if (st_move == this->nst && pw_filled == this->npw) break;
module_basis/module_pw/pw_distributeg.cpp:    if (this->device == "gpu") {
module_basis/module_pw/pw_distributeg.cpp:        resmem_int_op()(gpu_ctx, d_is2fftixy, this->nst);
module_basis/module_pw/pw_distributeg.cpp:        syncmem_int_h2d_op()(gpu_ctx, cpu_ctx, this->d_is2fftixy, this->is2fftixy, this->nst);
module_basis/module_pw/pw_distributeg_method1.cpp:    delete[] this->nst_per; this->nst_per = new int[this->poolnproc]; // number of sticks on each core.
module_basis/module_pw/pw_distributeg_method1.cpp:    delete[] this->npw_per;   this->npw_per = new int[this->poolnproc];  // number of planewaves on each core.
module_basis/module_pw/pw_distributeg_method1.cpp:    delete[] this->fftixy2ip; this->fftixy2ip = new int[this->fftnxy];              // ip of core which contains the stick on (x, y).
module_basis/module_pw/pw_distributeg_method1.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_distributeg_method1.cpp:        this->fftixy2ip[ixy] = -1;                 // meaning this stick has not been distributed or there is no stick on (x, y).
module_basis/module_pw/pw_distributeg_method1.cpp:        // (1) Count the total number of planewaves (tot_npw) and sticks (this->nstot).                  
module_basis/module_pw/pw_distributeg_method1.cpp:        // calculate this->nstot and this->npwtot, liy, riy
module_basis/module_pw/pw_distributeg_method1.cpp:        this->count_pw_st(st_length2D, st_bottom2D); 
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(&this->npwtot, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(&this->nstot, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(&liy, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(&riy, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(&lix, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(&rix, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    delete[] this->istot2ixy; this->istot2ixy = new int[this->nstot];
module_basis/module_pw/pw_distributeg_method1.cpp:        int* st_i = new int[this->nstot];                           // x or x + fftnx (if x < 0) of stick.
module_basis/module_pw/pw_distributeg_method1.cpp:        int* st_j = new int[this->nstot];                           // y or y + fftny (if y < 0) of stick.
module_basis/module_pw/pw_distributeg_method1.cpp:        int* st_length = new int[this->nstot];                      // number of planewaves in stick.  
module_basis/module_pw/pw_distributeg_method1.cpp:        this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length);
module_basis/module_pw/pw_distributeg_method1.cpp:        this->startnsz_per = new int[this->poolnproc];
module_basis/module_pw/pw_distributeg_method1.cpp:        this->divide_sticks_1(st_i, st_j, st_length);
module_basis/module_pw/pw_distributeg_method1.cpp:        this->get_istot2ixy(st_i, st_j);
module_basis/module_pw/pw_distributeg_method1.cpp:        delete[] this->startnsz_per;
module_basis/module_pw/pw_distributeg_method1.cpp:        this->startnsz_per=nullptr;
module_basis/module_pw/pw_distributeg_method1.cpp:        this->nst_per[0] = this->nstot;
module_basis/module_pw/pw_distributeg_method1.cpp:        this->npw_per[0] = this->npwtot;
module_basis/module_pw/pw_distributeg_method1.cpp:                this->istot2ixy[st_move] = ixy / fftny * ny + ixy % fftny;
module_basis/module_pw/pw_distributeg_method1.cpp:                this->fftixy2ip[ixy] = 0;
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(st_length2D, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(st_bottom2D, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(this->fftixy2ip, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(this->istot2ixy, this->nstot, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(this->nst_per, this->poolnproc, MPI_INT, 0 , this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    MPI_Bcast(this->npw_per, this->poolnproc, MPI_INT, 0 , this->pool_world);
module_basis/module_pw/pw_distributeg_method1.cpp:    this->npw = this->npw_per[this->poolrank];
module_basis/module_pw/pw_distributeg_method1.cpp:    this->nst = this->nst_per[this->poolrank];
module_basis/module_pw/pw_distributeg_method1.cpp:    this->nstnz = this->nst * this->nz;
module_basis/module_pw/pw_distributeg_method1.cpp:    this->get_ig2isz_is2fftixy(st_bottom2D, st_length2D);
module_basis/module_pw/pw_distributeg_method1.cpp:/// known: tot_npw, this->nstot, st_length2D, st_bottom2D
module_basis/module_pw/pw_distributeg_method1.cpp:    int* st_length                                  // number of planewaves in stick, stored in 1d array with this->nstot elements.
module_basis/module_pw/pw_distributeg_method1.cpp:    int *temp_st_i = new int[this->nstot];                      // x or x + fftnx (if x < 0) of stick.
module_basis/module_pw/pw_distributeg_method1.cpp:    int *temp_st_j = new int[this->nstot];                      // y or y + fftny (if y < 0) of stick.
module_basis/module_pw/pw_distributeg_method1.cpp:    double *temp_st_length = new double[this->nstot];           // length of sticks.
module_basis/module_pw/pw_distributeg_method1.cpp:    ModuleBase::GlobalFunc::ZEROS(temp_st_length, this->nstot);
module_basis/module_pw/pw_distributeg_method1.cpp:    int ix_end = int(this->nx / 2) + 1;
module_basis/module_pw/pw_distributeg_method1.cpp:    int iy_end = int(this->ny / 2) + 1;
module_basis/module_pw/pw_distributeg_method1.cpp:    if (this->full_pw)
module_basis/module_pw/pw_distributeg_method1.cpp:        ix_end = int(this->nx / 2);
module_basis/module_pw/pw_distributeg_method1.cpp:        ix_start = ix_end - this->nx + 1; 
module_basis/module_pw/pw_distributeg_method1.cpp:        iy_end = int(this->ny / 2);
module_basis/module_pw/pw_distributeg_method1.cpp:        iy_start = iy_end - this->ny + 1; 
module_basis/module_pw/pw_distributeg_method1.cpp:    if (this->gamma_only)
module_basis/module_pw/pw_distributeg_method1.cpp:        if(this->xprime)
module_basis/module_pw/pw_distributeg_method1.cpp:            ix_end = this->fftnx - 1;
module_basis/module_pw/pw_distributeg_method1.cpp:            iy_end = this->fftny - 1;
module_basis/module_pw/pw_distributeg_method1.cpp:            int index = x * this->fftny + y;
module_basis/module_pw/pw_distributeg_method1.cpp:                if (!this->full_pw)
module_basis/module_pw/pw_distributeg_method1.cpp:    assert(is == this->nstot);
module_basis/module_pw/pw_distributeg_method1.cpp:    int *st_sorted_index = new int[this->nstot]; // indexs in the order of length increasing.
module_basis/module_pw/pw_distributeg_method1.cpp:    ModuleBase::heapsort(this->nstot, temp_st_length, st_sorted_index); // sort st_* in the order of length increasing.
module_basis/module_pw/pw_distributeg_method1.cpp:    for (int istot = 0; istot < this->nstot; ++istot)
module_basis/module_pw/pw_distributeg_method1.cpp:        index = (this->nstot - 1) - istot;
module_basis/module_pw/pw_distributeg_method1.cpp:    // for (int is = 0; is < this->nstot; ++is) std::cout << st_length[is] << std::setw(4);
module_basis/module_pw/pw_distributeg_method1.cpp:/// then update npw_per, this->fftixy2ip, and this->startnsz_per.
module_basis/module_pw/pw_distributeg_method1.cpp:/// known: tot_npw, this->nstot, st_i, st_j, st_length
module_basis/module_pw/pw_distributeg_method1.cpp:/// output: npw_per, nst_per, this->fftixy2ip, this->startnsz_per
module_basis/module_pw/pw_distributeg_method1.cpp:    ModuleBase::GlobalFunc::ZEROS(this->nst_per, poolnproc);
module_basis/module_pw/pw_distributeg_method1.cpp:    ModuleBase::GlobalFunc::ZEROS(this->npw_per, poolnproc);
module_basis/module_pw/pw_distributeg_method1.cpp:    for (int is = 0; is < this->nstot; ++is)
module_basis/module_pw/pw_distributeg_method1.cpp:        for (int ip = 0; ip < this->poolnproc; ++ip)
module_basis/module_pw/pw_distributeg_method1.cpp:            const int npwmin = this->npw_per[ipmin];
module_basis/module_pw/pw_distributeg_method1.cpp:            const int npw_ip = this->npw_per[ip];
module_basis/module_pw/pw_distributeg_method1.cpp:        this->nst_per[ipmin]++;
module_basis/module_pw/pw_distributeg_method1.cpp:        this->npw_per[ipmin] += st_length[is];
module_basis/module_pw/pw_distributeg_method1.cpp:        this->fftixy2ip[st_i[is] * this->fftny + st_j[is]] = ipmin;
module_basis/module_pw/pw_distributeg_method1.cpp:     this->startnsz_per[0] = 0;
module_basis/module_pw/pw_distributeg_method1.cpp:        this->startnsz_per[ip] = this->startnsz_per[ip - 1] + this->nst_per[ip - 1] * this->nz;
module_basis/module_pw/pw_distributeg_method1.cpp:/// known: this->nstot, st_i, st_j, this->startnsz_per
module_basis/module_pw/pw_distributeg_method1.cpp:    assert(this->poolrank == 0);
module_basis/module_pw/pw_distributeg_method1.cpp:    int* st_move = new int[this->poolnproc]; // st_move[ip]: this is the st_move^th stick on ip^th core.
module_basis/module_pw/pw_distributeg_method1.cpp:    ModuleBase::GlobalFunc::ZEROS(this->istot2ixy, this->nstot);
module_basis/module_pw/pw_distributeg_method1.cpp:    ModuleBase::GlobalFunc::ZEROS(st_move, this->poolnproc);
module_basis/module_pw/pw_distributeg_method1.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_distributeg_method1.cpp:        int ip = this->fftixy2ip[ixy];
module_basis/module_pw/pw_distributeg_method1.cpp:            this->istot2ixy[this->startnsz_per[ip] / this->nz + st_move[ip]] = (ixy / fftny)*ny + ixy % fftny;
module_basis/module_pw/pw_distributeg_method2.cpp:    delete[] this->nst_per; this->nst_per = new int[this->poolnproc]; // number of sticks on each core.
module_basis/module_pw/pw_distributeg_method2.cpp:    delete[] this->npw_per;   this->npw_per = new int[this->poolnproc];  // number of planewaves on each core.
module_basis/module_pw/pw_distributeg_method2.cpp:    delete[] this->fftixy2ip; this->fftixy2ip = new int[this->fftnxy];              // ip of core which contains the stick on (x, y).
module_basis/module_pw/pw_distributeg_method2.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_distributeg_method2.cpp:        this->fftixy2ip[ixy] = -1;                 // meaning this stick has not been distributed or there is no stick on (x, y).
module_basis/module_pw/pw_distributeg_method2.cpp:        // (1) Count the total number of planewaves (tot_npw) and sticks (this->nstot).                  
module_basis/module_pw/pw_distributeg_method2.cpp:        // calculate this->nstot and this->npwtot, liy, riy
module_basis/module_pw/pw_distributeg_method2.cpp:        this->count_pw_st(st_length2D, st_bottom2D);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(&this->npwtot, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(&this->nstot, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(&liy, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(&riy, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(&lix, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(&rix, 1, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    delete[] this->istot2ixy; this->istot2ixy = new int[this->nstot];
module_basis/module_pw/pw_distributeg_method2.cpp:        this->startnsz_per = new int[this->poolnproc];
module_basis/module_pw/pw_distributeg_method2.cpp:        this->divide_sticks_2();
module_basis/module_pw/pw_distributeg_method2.cpp:        this->create_maps(st_length2D);
module_basis/module_pw/pw_distributeg_method2.cpp:        delete[] this->startnsz_per;
module_basis/module_pw/pw_distributeg_method2.cpp:        this->startnsz_per=nullptr;
module_basis/module_pw/pw_distributeg_method2.cpp:        this->nst_per[0] = this->nstot;
module_basis/module_pw/pw_distributeg_method2.cpp:        this->npw_per[0] = this->npwtot;
module_basis/module_pw/pw_distributeg_method2.cpp:                this->istot2ixy[st_move] = ixy / fftny * ny + ixy % fftny;
module_basis/module_pw/pw_distributeg_method2.cpp:                this->fftixy2ip[ixy] = 0;
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(st_length2D, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(st_bottom2D, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(this->fftixy2ip, this->fftnxy, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(this->istot2ixy, this->nstot, MPI_INT, 0, this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(this->nst_per, this->poolnproc, MPI_INT, 0 , this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    MPI_Bcast(this->npw_per, this->poolnproc, MPI_INT, 0 , this->pool_world);
module_basis/module_pw/pw_distributeg_method2.cpp:    this->npw = this->npw_per[this->poolrank];
module_basis/module_pw/pw_distributeg_method2.cpp:    this->nst = this->nst_per[this->poolrank];
module_basis/module_pw/pw_distributeg_method2.cpp:    this->nstnz = this->nst * this->nz;
module_basis/module_pw/pw_distributeg_method2.cpp:    this->get_ig2isz_is2fftixy(st_bottom2D, st_length2D);
module_basis/module_pw/pw_distributeg_method2.cpp:/// known: this->nstot, this->poolnproc
module_basis/module_pw/pw_distributeg_method2.cpp:/// output: nst_per, this->startnsz_per
module_basis/module_pw/pw_distributeg_method2.cpp:    ModuleBase::GlobalFunc::ZEROS(nst_per, this->poolnproc);
module_basis/module_pw/pw_distributeg_method2.cpp:    int average_nst = this->nstot / this->poolnproc;
module_basis/module_pw/pw_distributeg_method2.cpp:    int mods = this->nstot % this->poolnproc;
module_basis/module_pw/pw_distributeg_method2.cpp:    this->startnsz_per[0] = 0;
module_basis/module_pw/pw_distributeg_method2.cpp:    for (int ip = 0; ip < this->poolnproc; ++ip)
module_basis/module_pw/pw_distributeg_method2.cpp:        if (ip >= 1) this->startnsz_per[ip] = this->startnsz_per[ip-1] + this->nst_per[ip-1] * this->nz; 
module_basis/module_pw/pw_distributeg_method2.cpp:// output: this->fftixy2ip, this->istot2ixy, npw_per
module_basis/module_pw/pw_distributeg_method2.cpp:    ModuleBase::GlobalFunc::ZEROS(this->istot2ixy, this->nstot);
module_basis/module_pw/pw_distributeg_method2.cpp:    ModuleBase::GlobalFunc::ZEROS(this->npw_per, poolnproc);
module_basis/module_pw/pw_distributeg_method2.cpp:    for (int ixy = 0; ixy < this->fftnxy; ++ixy)
module_basis/module_pw/pw_distributeg_method2.cpp:            this->istot2ixy[st_move] = ixy / fftny * ny + ixy % fftny;
module_basis/module_pw/pw_distributeg_method2.cpp:            this->fftixy2ip[ixy] = ip;
module_basis/module_pw/pw_distributeg_method2.cpp:            this->npw_per[ip] += st_length2D[ixy];
module_basis/module_pw/pw_distributeg_method2.cpp:            if (ip < this->poolnproc - 1)
module_basis/module_pw/pw_distributeg_method2.cpp:                if (st_move * this->nz >= this->startnsz_per[ip + 1]) ip++; 
module_basis/module_pw/pw_distributer.cpp:    delete[] this->numz; this->numz = new int[this->poolnproc];
module_basis/module_pw/pw_distributer.cpp:    delete[] this->startz; this->startz = new int[this->poolnproc];
module_basis/module_pw/pw_distributer.cpp:    ModuleBase::GlobalFunc::ZEROS(this->numz, this->poolnproc);
module_basis/module_pw/pw_distributer.cpp:    ModuleBase::GlobalFunc::ZEROS(this->startz, this->poolnproc);
module_basis/module_pw/pw_distributer.cpp:    int npz = this->nz / this->poolnproc;
module_basis/module_pw/pw_distributer.cpp:    int modz = this->nz % this->poolnproc;
module_basis/module_pw/pw_distributer.cpp:    this->startz[0] = 0;
module_basis/module_pw/pw_distributer.cpp:    for(int ip = 0 ; ip < this->poolnproc ; ++ip)
module_basis/module_pw/pw_distributer.cpp:        this->numz[ip] = npz;
module_basis/module_pw/pw_distributer.cpp:        if(ip < modz)   this->numz[ip]++;
module_basis/module_pw/pw_distributer.cpp:        if(ip < this->poolnproc - 1)   this->startz[ip+1] = this->startz[ip] + numz[ip];
module_basis/module_pw/pw_distributer.cpp:        if(ip == this->poolrank) 
module_basis/module_pw/pw_distributer.cpp:            this->nplane = numz[ip];
module_basis/module_pw/pw_distributer.cpp:            this->startz_current = startz[ip];
module_basis/module_pw/pw_distributer.cpp:    this->nrxx = this->numz[this->poolrank] * this->nxy;
module_basis/module_pw/pw_gatherscatter.h:    ModuleBase::timer::tick(this->classname, "gatherp_scatters");
module_basis/module_pw/pw_gatherscatter.h:    if(this->poolnproc == 1) //In this case nst=nstot, nz = nplane, 
module_basis/module_pw/pw_gatherscatter.h:        for(int is = 0 ; is < this->nst ; ++is)
module_basis/module_pw/pw_gatherscatter.h:            int ixy = this->istot2ixy[is];
module_basis/module_pw/pw_gatherscatter.h:            for(int iz = 0 ; iz < this->nz ; ++iz)
module_basis/module_pw/pw_gatherscatter.h:        ModuleBase::timer::tick(this->classname, "gatherp_scatters");
module_basis/module_pw/pw_gatherscatter.h:		int ixy = this->istot2ixy[istot];
module_basis/module_pw/pw_gatherscatter.h:	    MPI_Alltoallv(out, numr, startr, MPI_DOUBLE_COMPLEX, in, numg, startg, MPI_DOUBLE_COMPLEX, this->pool_world);
module_basis/module_pw/pw_gatherscatter.h:        MPI_Alltoallv(out, numr, startr, MPI_COMPLEX, in, numg, startg, MPI_COMPLEX, this->pool_world);
module_basis/module_pw/pw_gatherscatter.h:    for (int ip = 0; ip < this->poolnproc ;++ip)
module_basis/module_pw/pw_gatherscatter.h:		for (int is = 0; is < this->nst; ++is)
module_basis/module_pw/pw_gatherscatter.h:            int nzip = this->numz[ip];
module_basis/module_pw/pw_gatherscatter.h:    ModuleBase::timer::tick(this->classname, "gatherp_scatters");
module_basis/module_pw/pw_gatherscatter.h:    ModuleBase::timer::tick(this->classname, "gathers_scatterp");
module_basis/module_pw/pw_gatherscatter.h:    if(this->poolnproc == 1) //In this case nrxx=fftnx*fftny*nz, nst = nstot, 
module_basis/module_pw/pw_gatherscatter.h:        for(int i = 0; i < this->nrxx; ++i)
module_basis/module_pw/pw_gatherscatter.h:        for(int is = 0 ; is < this->nst ; ++is)
module_basis/module_pw/pw_gatherscatter.h:            for(int iz = 0 ; iz < this->nz ; ++iz)
module_basis/module_pw/pw_gatherscatter.h:        ModuleBase::timer::tick(this->classname, "gathers_scatterp");
module_basis/module_pw/pw_gatherscatter.h:    for (int ip = 0; ip < this->poolnproc ;++ip)
module_basis/module_pw/pw_gatherscatter.h:		for (int is = 0; is < this->nst; ++is)
module_basis/module_pw/pw_gatherscatter.h:            int nzip = this->numz[ip];
module_basis/module_pw/pw_gatherscatter.h:	    MPI_Alltoallv(out, numg, startg, MPI_DOUBLE_COMPLEX, in, numr, startr, MPI_DOUBLE_COMPLEX, this->pool_world);
module_basis/module_pw/pw_gatherscatter.h:        MPI_Alltoallv(out, numg, startg, MPI_COMPLEX, in, numr, startr, MPI_COMPLEX, this->pool_world);
module_basis/module_pw/pw_gatherscatter.h:    for(int i = 0; i < this->nrxx; ++i)
module_basis/module_pw/pw_gatherscatter.h:		int ixy = this->istot2ixy[istot];
module_basis/module_pw/pw_gatherscatter.h:    ModuleBase::timer::tick(this->classname, "gathers_scatterp");
module_basis/module_pw/pw_init.cpp:    this->poolnproc = poolnproc_in;
module_basis/module_pw/pw_init.cpp:    this->poolrank = poolrank_in;
module_basis/module_pw/pw_init.cpp:    this->pool_world = pool_world_in;
module_basis/module_pw/pw_init.cpp:    this->lat0 = lat0_in;
module_basis/module_pw/pw_init.cpp:    this->tpiba = ModuleBase::TWO_PI / this->lat0;
module_basis/module_pw/pw_init.cpp:    this->tpiba2 = this->tpiba*this->tpiba;
module_basis/module_pw/pw_init.cpp:    this->latvec = latvec_in;
module_basis/module_pw/pw_init.cpp:    this->omega = std::abs(latvec.Det()) * lat0 * lat0 * lat0;
module_basis/module_pw/pw_init.cpp:    this->GT = latvec.Inverse();
module_basis/module_pw/pw_init.cpp:	this->G  = GT.Transpose();
module_basis/module_pw/pw_init.cpp:	this->GGT = G * GT;
module_basis/module_pw/pw_init.cpp:    this->gridecut_lat = gridecut / this->tpiba2;
module_basis/module_pw/pw_init.cpp:    ibox[0] = int(sqrt(this->gridecut_lat) * sqrt(lat * lat)) + 1;
module_basis/module_pw/pw_init.cpp:    ibox[1] = int(sqrt(this->gridecut_lat) * sqrt(lat * lat)) + 1;
module_basis/module_pw/pw_init.cpp:    ibox[2] = int(sqrt(this->gridecut_lat) * sqrt(lat * lat)) + 1;
module_basis/module_pw/pw_init.cpp:    for(int igz = -ibox[2]+this->poolrank; igz <= ibox[2]; igz += this->poolnproc)
module_basis/module_pw/pw_init.cpp:                double modulus = f * (this->GGT * f);
module_basis/module_pw/pw_init.cpp:                if(modulus <= this->gridecut_lat)
module_basis/module_pw/pw_init.cpp:    MPI_Allreduce(MPI_IN_PLACE, ibox, 3, MPI_INT, MPI_MAX , this->pool_world);
module_basis/module_pw/pw_init.cpp:            if ((this->full_pw && this->full_pw_dim == 2) && b % 2 != 0) done_factoring = true; // full_pw_dim = 2 means FFT dimensions should be even.
module_basis/module_pw/pw_init.cpp:				if (b % 2 == 0 && (!this->full_pw || this->full_pw_dim != 1)) // full_pw_dim = 1 means FFT dimension should be odd.
module_basis/module_pw/pw_init.cpp:    this->nx = ibox[0];
module_basis/module_pw/pw_init.cpp:    this->ny = ibox[1];
module_basis/module_pw/pw_init.cpp:    this->nz = ibox[2];
module_basis/module_pw/pw_init.cpp:    this->nxy =this->nx * this->ny;
module_basis/module_pw/pw_init.cpp:    this->nxyz = this->nxy * this->nz;
module_basis/module_pw/pw_init.cpp:    this->lat0 = lat0_in;
module_basis/module_pw/pw_init.cpp:    this->tpiba = ModuleBase::TWO_PI / this->lat0;
module_basis/module_pw/pw_init.cpp:    this->tpiba2 = this->tpiba*this->tpiba;
module_basis/module_pw/pw_init.cpp:    this->latvec = latvec_in;
module_basis/module_pw/pw_init.cpp:    this->omega = std::abs(latvec.Det()) * lat0 * lat0 * lat0;
module_basis/module_pw/pw_init.cpp:    this->GT = latvec.Inverse();
module_basis/module_pw/pw_init.cpp:	this->G  = GT.Transpose();
module_basis/module_pw/pw_init.cpp:	this->GGT = G * GT;
module_basis/module_pw/pw_init.cpp:    this->nx = nx_in;
module_basis/module_pw/pw_init.cpp:    this->ny = ny_in;
module_basis/module_pw/pw_init.cpp:    this->nz = nz_in;
module_basis/module_pw/pw_init.cpp:    this->nxy = this->nx * this->ny;
module_basis/module_pw/pw_init.cpp:    this->nxyz = this->nxy * this->nz;
module_basis/module_pw/pw_init.cpp:    ibox[0] = int((this->nx-1)/2)+1;
module_basis/module_pw/pw_init.cpp:    ibox[1] = int((this->ny-1)/2)+1;
module_basis/module_pw/pw_init.cpp:    ibox[2] = int((this->nz-1)/2)+1;
module_basis/module_pw/pw_init.cpp:    this->gridecut_lat = 1e20;
module_basis/module_pw/pw_init.cpp:                if(count%this->poolnproc != this->poolrank) continue;
module_basis/module_pw/pw_init.cpp:                double modulus = f * (this->GGT * f);
module_basis/module_pw/pw_init.cpp:                if(modulus < this->gridecut_lat)
module_basis/module_pw/pw_init.cpp:                    this->gridecut_lat = modulus;
module_basis/module_pw/pw_init.cpp:    MPI_Allreduce(MPI_IN_PLACE, &this->gridecut_lat, 1, MPI_DOUBLE, MPI_MIN , this->pool_world);
module_basis/module_pw/pw_init.cpp:    this->gridecut_lat -= 1e-6;
module_basis/module_pw/pw_init.cpp:    this->xprime = xprime_in;
module_basis/module_pw/pw_init.cpp:    this->gamma_only = gamma_only_in;
module_basis/module_pw/pw_init.cpp:    this->fftny = this->ny;
module_basis/module_pw/pw_init.cpp:    this->fftnx = this->nx;
module_basis/module_pw/pw_init.cpp:    if (this->gamma_only)   
module_basis/module_pw/pw_init.cpp:        if(this->xprime) this->fftnx = int(this->nx / 2) + 1;
module_basis/module_pw/pw_init.cpp:        else            this->fftny = int(this->ny / 2) + 1;
module_basis/module_pw/pw_init.cpp:    this->fftnz = this->nz;
module_basis/module_pw/pw_init.cpp:    this->fftnxy = this->fftnx * this->fftny;
module_basis/module_pw/pw_init.cpp:    this->fftnxyz = this->fftnxy * this->fftnz;
module_basis/module_pw/pw_init.cpp:    this->ggecut = pwecut_in / this->tpiba2;
module_basis/module_pw/pw_init.cpp:    if(this->ggecut > this->gridecut_lat) 
module_basis/module_pw/pw_init.cpp:        this->ggecut = this->gridecut_lat;
module_basis/module_pw/pw_init.cpp:    this->distribution_type = distribution_type_in;
module_basis/module_pw/pw_init.cpp:    this->full_pw = inpt_full_pw;
module_basis/module_pw/pw_init.cpp:    this->full_pw_dim = inpt_full_pw_dim;
module_basis/module_pw/pw_init.cpp:    if (!this->full_pw) this->full_pw_dim = 0;
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform.cpp:    for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform.cpp:        this->ft.get_auxr_data<FPTYPE>()[ir] = in[ir];
module_basis/module_pw/pw_transform.cpp:    this->ft.fftxyfor(ft.get_auxr_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    this->gatherp_scatters(this->ft.get_auxr_data<FPTYPE>(), this->ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    this->ft.fftzfor(ft.get_auxg_data<FPTYPE>(),ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:        FPTYPE tmpfac = factor / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform.cpp:        for(int ig = 0 ; ig < this->npw ; ++ig)
module_basis/module_pw/pw_transform.cpp:            out[ig] += tmpfac * this->ft.get_auxg_data<FPTYPE>()[this->ig2isz[ig]];
module_basis/module_pw/pw_transform.cpp:        FPTYPE tmpfac = 1.0 / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform.cpp:        for(int ig = 0 ; ig < this->npw ; ++ig)
module_basis/module_pw/pw_transform.cpp:            out[ig] = tmpfac * this->ft.get_auxg_data<FPTYPE>()[this->ig2isz[ig]];
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform.cpp:    if(this->gamma_only)
module_basis/module_pw/pw_transform.cpp:        const int npy = this->ny * this->nplane;
module_basis/module_pw/pw_transform.cpp:        for(int ix = 0 ; ix < this->nx ; ++ix)
module_basis/module_pw/pw_transform.cpp:                this->ft.get_rspace_data<FPTYPE>()[ix*npy + ipy] = in[ix*npy + ipy];
module_basis/module_pw/pw_transform.cpp:        this->ft.fftxyr2c(ft.get_rspace_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:        for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform.cpp:            this->ft.get_auxr_data<FPTYPE>()[ir] = std::complex<FPTYPE>(in[ir],0);
module_basis/module_pw/pw_transform.cpp:        this->ft.fftxyfor(ft.get_auxr_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    this->gatherp_scatters(this->ft.get_auxr_data<FPTYPE>(), this->ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    this->ft.fftzfor(ft.get_auxg_data<FPTYPE>(),ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:        FPTYPE tmpfac = factor / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform.cpp:        for(int ig = 0 ; ig < this->npw ; ++ig)
module_basis/module_pw/pw_transform.cpp:            out[ig] += tmpfac * this->ft.get_auxg_data<FPTYPE>()[this->ig2isz[ig]];
module_basis/module_pw/pw_transform.cpp:        FPTYPE tmpfac = 1.0 / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform.cpp:        for(int ig = 0 ; ig < this->npw ; ++ig)
module_basis/module_pw/pw_transform.cpp:            out[ig] = tmpfac * this->ft.get_auxg_data<FPTYPE>()[this->ig2isz[ig]];
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform.cpp:    for(int i = 0 ; i < this->nst * this->nz ; ++i)
module_basis/module_pw/pw_transform.cpp:    for(int ig = 0 ; ig < this->npw ; ++ig)
module_basis/module_pw/pw_transform.cpp:        this->ft.get_auxg_data<FPTYPE>()[this->ig2isz[ig]] = in[ig];
module_basis/module_pw/pw_transform.cpp:    this->ft.fftzbac(ft.get_auxg_data<FPTYPE>(), ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    this->gathers_scatterp(this->ft.get_auxg_data<FPTYPE>(),this->ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    this->ft.fftxybac(ft.get_auxr_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:        for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform.cpp:            out[ir] += factor * this->ft.get_auxr_data<FPTYPE>()[ir];
module_basis/module_pw/pw_transform.cpp:        for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform.cpp:            out[ir] = this->ft.get_auxr_data<FPTYPE>()[ir];
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform.cpp:    for(int i = 0 ; i < this->nst * this->nz ; ++i)
module_basis/module_pw/pw_transform.cpp:    for(int ig = 0 ; ig < this->npw ; ++ig)
module_basis/module_pw/pw_transform.cpp:        this->ft.get_auxg_data<FPTYPE>()[this->ig2isz[ig]] = in[ig];
module_basis/module_pw/pw_transform.cpp:    this->ft.fftzbac(ft.get_auxg_data<FPTYPE>(), ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    this->gathers_scatterp(this->ft.get_auxg_data<FPTYPE>(), this->ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:    if(this->gamma_only)
module_basis/module_pw/pw_transform.cpp:        this->ft.fftxyc2r(ft.get_auxr_data<FPTYPE>(),ft.get_rspace_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:        const int npy = this->ny * this->nplane;
module_basis/module_pw/pw_transform.cpp:            for(int ix = 0 ; ix < this->nx ; ++ix)
module_basis/module_pw/pw_transform.cpp:                    out[ix*npy + ipy] += factor * this->ft.get_rspace_data<FPTYPE>()[ix*npy + ipy];
module_basis/module_pw/pw_transform.cpp:            for(int ix = 0 ; ix < this->nx ; ++ix)
module_basis/module_pw/pw_transform.cpp:                    out[ix*npy + ipy] = this->ft.get_rspace_data<FPTYPE>()[ix*npy + ipy];
module_basis/module_pw/pw_transform.cpp:        this->ft.fftxybac(ft.get_auxr_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform.cpp:            for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform.cpp:                out[ir] += factor * this->ft.get_auxr_data<FPTYPE>()[ir].real();
module_basis/module_pw/pw_transform.cpp:            for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform.cpp:                out[ir] = this->ft.get_auxr_data<FPTYPE>()[ir].real();
module_basis/module_pw/pw_transform.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform_k.cpp:    auto* auxr = this->ft.get_auxr_data<FPTYPE>();
module_basis/module_pw/pw_transform_k.cpp:    for (int ir = 0; ir < this->nrxx; ++ir)
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftxyfor(ft.get_auxr_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->gatherp_scatters(this->ft.get_auxr_data<FPTYPE>(), this->ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftzfor(ft.get_auxg_data<FPTYPE>(), ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npwk = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:    auto* auxg = this->ft.get_auxg_data<FPTYPE>();
module_basis/module_pw/pw_transform_k.cpp:        FPTYPE tmpfac = factor / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:            out[igl] += tmpfac * auxg[this->igl2isz_k[igl + startig]];
module_basis/module_pw/pw_transform_k.cpp:        FPTYPE tmpfac = 1.0 / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:            out[igl] = tmpfac * auxg[this->igl2isz_k[igl + startig]];
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == true);
module_basis/module_pw/pw_transform_k.cpp:    // for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform_k.cpp:    //     this->ft.get_rspace_data<FPTYPE>()[ir] = in[ir];
module_basis/module_pw/pw_transform_k.cpp:    const int npy = this->ny * this->nplane;
module_basis/module_pw/pw_transform_k.cpp:    for(int ix = 0 ; ix < this->nx ; ++ix)
module_basis/module_pw/pw_transform_k.cpp:            this->ft.get_rspace_data<FPTYPE>()[ix * npy + ipy] = in[ix * npy + ipy];
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftxyr2c(ft.get_rspace_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->gatherp_scatters(this->ft.get_auxr_data<FPTYPE>(), this->ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftzfor(ft.get_auxg_data<FPTYPE>(),ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npwk = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:    auto* auxg = this->ft.get_auxg_data<FPTYPE>();
module_basis/module_pw/pw_transform_k.cpp:        FPTYPE tmpfac = factor / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:            out[igl] += tmpfac * auxg[this->igl2isz_k[igl + startig]];
module_basis/module_pw/pw_transform_k.cpp:        FPTYPE tmpfac = 1.0 / FPTYPE(this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:            out[igl] = tmpfac * auxg[this->igl2isz_k[igl + startig]];
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real2recip");
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::GlobalFunc::ZEROS(ft.get_auxg_data<FPTYPE>(), this->nst * this->nz);
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npwk = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:    auto* auxg = this->ft.get_auxg_data<FPTYPE>();
module_basis/module_pw/pw_transform_k.cpp:        auxg[this->igl2isz_k[igl+startig]] = in[igl];
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftzbac(ft.get_auxg_data<FPTYPE>(), ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->gathers_scatterp(this->ft.get_auxg_data<FPTYPE>(),this->ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftxybac(ft.get_auxr_data<FPTYPE>(),ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    auto* auxr = this->ft.get_auxr_data<FPTYPE>();
module_basis/module_pw/pw_transform_k.cpp:        for (int ir = 0; ir < this->nrxx; ++ir)
module_basis/module_pw/pw_transform_k.cpp:        for (int ir = 0; ir < this->nrxx; ++ir)
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == true);
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::GlobalFunc::ZEROS(ft.get_auxg_data<FPTYPE>(), this->nst * this->nz);
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npwk = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:    auto* auxg = this->ft.get_auxg_data<FPTYPE>();
module_basis/module_pw/pw_transform_k.cpp:        auxg[this->igl2isz_k[igl + startig]] = in[igl];
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftzbac(ft.get_auxg_data<FPTYPE>(), ft.get_auxg_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->gathers_scatterp(this->ft.get_auxg_data<FPTYPE>(), this->ft.get_auxr_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fftxyc2r(ft.get_auxr_data<FPTYPE>(),ft.get_rspace_data<FPTYPE>());
module_basis/module_pw/pw_transform_k.cpp:    // for(int ir = 0 ; ir < this->nrxx ; ++ir)
module_basis/module_pw/pw_transform_k.cpp:    //     out[ir] = this->ft.get_rspace_data<FPTYPE>()[ir] / this->nxyz;
module_basis/module_pw/pw_transform_k.cpp:    const int npy = this->ny * this->nplane;
module_basis/module_pw/pw_transform_k.cpp:    auto* rspace = this->ft.get_rspace_data<FPTYPE>();
module_basis/module_pw/pw_transform_k.cpp:        for (int ix = 0; ix < this->nx; ++ix)
module_basis/module_pw/pw_transform_k.cpp:        for (int ix = 0; ix < this->nx; ++ix)
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip2real");
module_basis/module_pw/pw_transform_k.cpp:    this->real2recip(in, out, ik, add, factor);
module_basis/module_pw/pw_transform_k.cpp:    this->real2recip(in, out, ik, add, factor);
module_basis/module_pw/pw_transform_k.cpp:    this->recip2real(in, out, ik, add, factor);
module_basis/module_pw/pw_transform_k.cpp:    this->recip2real(in, out, ik, add, factor);
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real_to_recip gpu");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform_k.cpp:    assert(this->poolnproc == 1);
module_basis/module_pw/pw_transform_k.cpp:         this->ft.get_auxr_3d_data<float>(), in,
module_basis/module_pw/pw_transform_k.cpp:         this->nrxx);
module_basis/module_pw/pw_transform_k.cpp:     this->ft.fft3D_forward(ctx, this->ft.get_auxr_3d_data<float>(), this->ft.get_auxr_3d_data<float>());
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npw_k = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:        ctx, npw_k, this->nxyz, add, factor,  this->ig2ixyz_k + startig, this->ft.get_auxr_3d_data<float>(), out);
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real_to_recip gpu");
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real_to_recip gpu");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform_k.cpp:    assert(this->poolnproc == 1);
module_basis/module_pw/pw_transform_k.cpp:         this->ft.get_auxr_3d_data<double>(), in,
module_basis/module_pw/pw_transform_k.cpp:         this->nrxx);
module_basis/module_pw/pw_transform_k.cpp:     this->ft.fft3D_forward(ctx, this->ft.get_auxr_3d_data<double>(), this->ft.get_auxr_3d_data<double>());
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npw_k = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:        ctx, npw_k, this->nxyz, add, factor,  this->ig2ixyz_k + startig, this->ft.get_auxr_3d_data<double>(), out);
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "real_to_recip gpu");
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip_to_real gpu");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform_k.cpp:    assert(this->poolnproc == 1);
module_basis/module_pw/pw_transform_k.cpp:    // ModuleBase::GlobalFunc::ZEROS(ft.get_auxr_3d_data<float>(), this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:        ctx, this->ft.get_auxr_3d_data<float>(), 0, this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npw_k = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:        ctx, npw_k, this->ig2ixyz_k + startig, in, this->ft.get_auxr_3d_data<float>());
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fft3D_backward(ctx, this->ft.get_auxr_3d_data<float>(), this->ft.get_auxr_3d_data<float>());
module_basis/module_pw/pw_transform_k.cpp:        ctx, this->nrxx, add, factor, this->ft.get_auxr_3d_data<float>(), out);
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip_to_real gpu");
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip_to_real gpu");
module_basis/module_pw/pw_transform_k.cpp:    assert(this->gamma_only == false);
module_basis/module_pw/pw_transform_k.cpp:    assert(this->poolnproc == 1);
module_basis/module_pw/pw_transform_k.cpp:    // ModuleBase::GlobalFunc::ZEROS(ft.get_auxr_3d_data<double>(), this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:        ctx, this->ft.get_auxr_3d_data<double>(), 0, this->nxyz);
module_basis/module_pw/pw_transform_k.cpp:    const int startig = ik*this->npwk_max;
module_basis/module_pw/pw_transform_k.cpp:    const int npw_k = this->npwk[ik];
module_basis/module_pw/pw_transform_k.cpp:        ctx, npw_k, this->ig2ixyz_k + startig, in, this->ft.get_auxr_3d_data<double>());
module_basis/module_pw/pw_transform_k.cpp:    this->ft.fft3D_backward(ctx, this->ft.get_auxr_3d_data<double>(), this->ft.get_auxr_3d_data<double>());
module_basis/module_pw/pw_transform_k.cpp:        ctx, this->nrxx, add, factor, this->ft.get_auxr_3d_data<double>(), out);
module_basis/module_pw/pw_transform_k.cpp:    ModuleBase::timer::tick(this->classname, "recip_to_real gpu");
module_cell/atom_pseudo.cpp:	for(int is=0;is<4;is++) this->index1_soc[is] = nullptr;
module_cell/atom_pseudo.cpp:	for(int is=0;is<4;is++) this->index2_soc[is] = nullptr;
module_cell/atom_pseudo.cpp:		if(this->index1_soc[is] != nullptr) delete[] this->index1_soc[is];
module_cell/atom_pseudo.cpp:		if(this->index2_soc[is] != nullptr) delete[] this->index2_soc[is];
module_cell/atom_pseudo.cpp:	if (this->lmax < -1 || this->lmax > 20)
module_cell/atom_pseudo.cpp:	this->nproj = nproj_in;
module_cell/atom_pseudo.cpp:	this->nproj_soc = nproj_in_so;
module_cell/atom_pseudo.cpp:		this->non_zero_count_soc[is] = 0;
module_cell/atom_pseudo.cpp:		delete[] this->index1_soc[is];
module_cell/atom_pseudo.cpp:		this->index1_soc[is] = new int[nproj_soc * nproj_soc];
module_cell/atom_pseudo.cpp:		delete[] this->index2_soc[is];
module_cell/atom_pseudo.cpp:		this->index2_soc[is] = new int[nproj_soc * nproj_soc];
module_cell/atom_pseudo.cpp:		this->d_real.create(nproj_soc+1,  nproj_soc+1);
module_cell/atom_pseudo.cpp:		this->d_so.create(spin_dimension,  nproj_soc+1,  nproj_soc+1);//for noncollinear-spin only case
module_cell/atom_pseudo.cpp:				this->d_real(L1, L2) =
module_cell/atom_pseudo.cpp:					this->index1_soc[0][non_zero_count_soc[0]] = L1;
module_cell/atom_pseudo.cpp:					this->index2_soc[0][non_zero_count_soc[0]] = L2;
module_cell/atom_pseudo.cpp:					this->non_zero_count_soc[0]++;
module_cell/atom_pseudo.cpp:				this->d_so(0, L1, L2) =
module_cell/atom_pseudo.cpp:				this->d_so(3, L1, L2) =
module_cell/atom_pseudo.cpp:					this->index1_soc[3][non_zero_count_soc[3]] = L1;
module_cell/atom_pseudo.cpp:					this->index2_soc[3][non_zero_count_soc[3]] = L2;
module_cell/atom_pseudo.cpp:					this->non_zero_count_soc[3]++;
module_cell/atom_pseudo.cpp:		this->d_so.create(spin_dimension,  nproj_soc+1,  nproj_soc+1);
module_cell/atom_pseudo.cpp:		if(this->lmax > -1)
module_cell/atom_pseudo.cpp:								this->d_so(is, L1, L2) =
module_cell/atom_pseudo.cpp:								if(fabs(this->d_so(is, L1, L2).real())>1.0e-8 ||
module_cell/atom_pseudo.cpp:										fabs(this->d_so(is, L1, L2).imag())>1.0e-8 )
module_cell/atom_pseudo.cpp:									this->index1_soc[is][non_zero_count_soc[is]] = L1;
module_cell/atom_pseudo.cpp:									this->index2_soc[is][non_zero_count_soc[is]] = L2;
module_cell/atom_pseudo.cpp:									this->non_zero_count_soc[is]++;
module_cell/atom_pseudo.cpp:									this->d_so(is, L1, L2) = std::complex<double>(0.0,0.0);
module_cell/atom_pseudo.cpp:									this->d_so(is, L1, L2)
module_cell/atom_pseudo.cpp:								if(std::abs(this->d_so(is, L1, L2).real())>1.0e-8
module_cell/atom_pseudo.cpp:										|| std::abs(this->d_so(is, L1, L2).imag())>1.0e-8)
module_cell/atom_pseudo.cpp:									this->index1_soc[is][non_zero_count_soc[is]] = L1;
module_cell/atom_pseudo.cpp:									this->index2_soc[is][non_zero_count_soc[is]] = L2;
module_cell/atom_pseudo.cpp:									this->non_zero_count_soc[is]++;
module_cell/atom_pseudo.h:		tmp_d = &this->d_so(is, p1, p2);
module_cell/atom_pseudo.h:		tmp_d = &this->d_real(p1, p2);
module_cell/atom_spec.cpp:    	ofs << std::setw(15) << this->tau[i].x
module_cell/atom_spec.cpp:    		<< std::setw(15) << this->tau[i].y
module_cell/atom_spec.cpp:    		<< std::setw(15) << this->tau[i].z << std::endl;
module_cell/atom_spec.cpp:    Parallel_Common::bcast_bool( this->flag_empty_element );
module_cell/atom_spec.cpp:    this->ncpp.bcast_atom_pseudo();
module_cell/klist.cpp:	this->nspin = nspin_in;
module_cell/klist.cpp:	if(this->nspin==4)
module_cell/klist.cpp:		this->nspin = 1;//zhengdy-soc
module_cell/klist.cpp:	bool read_succesfully = this->read_kpoints(k_file_name);
module_cell/klist.cpp:        this->ibz_kpoint(symm, ModuleSymmetry::Symmetry::symm_flag, skpt1, GlobalC::ucell, match);
module_cell/klist.cpp:                this->ibz_kpoint(symm, ModuleSymmetry::Symmetry::symm_flag, skpt1, GlobalC::ucell, match);
module_cell/klist.cpp:            this->update_use_ibz();
module_cell/klist.cpp:            this->nks = this->nkstot = this->nkstot_ibz;
module_cell/klist.cpp:    this->set_both_kvec(reciprocal_vec, latvec, skpt2);
module_cell/klist.cpp:	this->normalize_wk(deg);
module_cell/klist.cpp:    this->mpi_k();//2008-4-29
module_cell/klist.cpp:    this->set_kup_and_kdw();
module_cell/klist.cpp:    this->print_klists(GlobalV::ofs_running);
module_cell/klist.cpp:    this->k_nkstot = nkstot; //LiuXh add 20180619
module_cell/klist.cpp:    this->k_kword = kword; //LiuXh add 20180619
module_cell/klist.cpp:        this->Monkhorst_Pack(nmp, koffset, k_type);
module_cell/klist.cpp:        	this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_cell/klist.cpp:            this->kc_done = true;
module_cell/klist.cpp:        	this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_cell/klist.cpp:            this->kd_done = true;
module_cell/klist.cpp:			int nks_special = this->nkstot;
module_cell/klist.cpp:        	this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_cell/klist.cpp:            this->kc_done = true;
module_cell/klist.cpp:			int nks_special = this->nkstot;
module_cell/klist.cpp:        	this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_cell/klist.cpp:            this->kd_done = true;
module_cell/klist.cpp:    this->nkstot_full = this->nks = this->nkstot;
module_cell/klist.cpp:    this->nkstot = mpnx * mpny * mpnz;
module_cell/klist.cpp:    this->renew(nkstot * nspin); // mohan fix bug 2009-09-01
module_cell/klist.cpp:    this->kd_done = true;
module_cell/klist.cpp:    this->nkstot = this->nkstot_ibz;
module_cell/klist.cpp:    this->kvec_d.resize(this->nkstot * nspin); //qianrui fix a bug 2021-7-13 for nspin=2 in set_kup_and_kdw()
module_cell/klist.cpp:    for (int i = 0; i < this->nkstot; ++i)
module_cell/klist.cpp:        this->kvec_d[i] = this->kvec_d_ibz[i];
module_cell/klist.cpp:        this->wk[i] = this->wk_ibz[i];
module_cell/klist.cpp:    this->kd_done = true;
module_cell/klist.cpp:    this->kc_done = false;
module_cell/klist.cpp:    if (this->is_mp)
module_cell/klist.cpp:        if (this->is_mp)
module_cell/klist.cpp:    if (this->is_mp)symm.gmatrix_convert(kgmatrix.data(), kkmatrix, nrotkm, ucell.G, gk);
module_cell/klist.cpp:    if (this->is_mp) for (int i = 0;i < nkstot;++i) kvec_d_k[i] = kvec_d[i] * ucell.G * gk.Inverse();
module_cell/klist.cpp:    this->nkstot_ibz = 0;
module_cell/klist.cpp:    kvec_d_ibz.resize(this->nkstot);
module_cell/klist.cpp:    wk_ibz.resize(this->nkstot);
module_cell/klist.cpp:    ibz2bz.resize(this->nkstot);
module_cell/klist.cpp:                if (this->is_mp)
module_cell/klist.cpp:                for (int k=0; k< this->nkstot_ibz; ++k)
module_cell/klist.cpp:                    if (    symm.equal(kvec_rot.x, this->kvec_d_ibz[k].x) &&
module_cell/klist.cpp:                            symm.equal(kvec_rot.y, this->kvec_d_ibz[k].y) &&
module_cell/klist.cpp:                            symm.equal(kvec_rot.z, this->kvec_d_ibz[k].z))
module_cell/klist.cpp:                        this->wk_ibz[k] += weight;
module_cell/klist.cpp:            this->kvec_d_ibz[nkstot_ibz] = kvec_rot;
module_cell/klist.cpp:            this->wk_ibz[nkstot_ibz] = weight;
module_cell/klist.cpp:            this->ibz2bz[nkstot_ibz] = i;
module_cell/klist.cpp:        //     << std::setw(20) << this->kvec_d[i].x
module_cell/klist.cpp:        //     << std::setw(20) << this->kvec_d[i].y
module_cell/klist.cpp:        //     << std::setw(20) << this->kvec_d[i].z;
module_cell/klist.cpp:        //         << std::setw(20) << this->kvec_d_ibz[ibz_index[i]].x
module_cell/klist.cpp:        //         << std::setw(20) << this->kvec_d_ibz[ibz_index[i]].y
module_cell/klist.cpp:        //         << std::setw(20) << this->kvec_d_ibz[ibz_index[i]].z << std::endl;
module_cell/klist.cpp:        _direct_x.push_back(this->kvec_d[i].x);
module_cell/klist.cpp:        _direct_y.push_back(this->kvec_d[i].y);
module_cell/klist.cpp:        _direct_z.push_back(this->kvec_d[i].z);
module_cell/klist.cpp:        _direct_x_ibz.push_back(this->kvec_d_ibz[ibz_index[i]].x);
module_cell/klist.cpp:        _direct_y_ibz.push_back(this->kvec_d_ibz[ibz_index[i]].y);
module_cell/klist.cpp:        _direct_z_ibz.push_back(this->kvec_d_ibz[ibz_index[i]].z);
module_cell/klist.cpp:            << std::setw(20) << this->kvec_d_ibz[ik].x
module_cell/klist.cpp:            << std::setw(20) << this->kvec_d_ibz[ik].y
module_cell/klist.cpp:            << std::setw(20) << this->kvec_d_ibz[ik].z
module_cell/klist.cpp:            << std::setw(20) << this->wk_ibz[ik]
module_cell/klist.cpp:            << std::setw(10) << this->ibz2bz[ik] << std::endl; */
module_cell/klist.cpp:        _direct_x.push_back(this->kvec_d_ibz[ik].x);
module_cell/klist.cpp:        _direct_y.push_back(this->kvec_d_ibz[ik].y);
module_cell/klist.cpp:        _direct_z.push_back(this->kvec_d_ibz[ik].z);
module_cell/klist.cpp:        _weights.push_back(this->wk_ibz[ik]);
module_cell/klist.cpp:        _ibz2bz.push_back(this->ibz2bz[ik]);
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].x
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].y
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].z
module_cell/klist.cpp:        //      << std::setw(20) << this->wk[i] << std::endl;
module_cell/klist.cpp:        _direct_x.push_back(this->kvec_d[i].x);
module_cell/klist.cpp:        _direct_y.push_back(this->kvec_d[i].y);
module_cell/klist.cpp:        _direct_z.push_back(this->kvec_d[i].z);
module_cell/klist.cpp:        _weights.push_back(this->wk[i]);
module_cell/klist.cpp:        //         << std::setw(20) << this->kvec_d[ik].x
module_cell/klist.cpp:        //         << std::setw(20) << this->kvec_d[ik].y
module_cell/klist.cpp:        //         << std::setw(20) << this->kvec_d[ik].z
module_cell/klist.cpp:        //         << std::setw(20) << this->wk[ik] << std::endl;
module_cell/klist.cpp:        //       //  << std::setw(10) << this->ibz2bz[ik] << std::endl;
module_cell/klist.cpp:        sum += this->wk[ik];
module_cell/klist.cpp:        this->wk[ik] /= sum;
module_cell/klist.cpp:        this->wk[ik] *= degspin;
module_cell/klist.cpp:    this->nks = GlobalC::Pkpoints.nks_pool[GlobalV::MY_POOL];
module_cell/klist.cpp:    int nks_minimum = this->nks;
module_cell/klist.cpp:    this->renew(this->nks * this->nspin);
module_cell/klist.cpp:            this->isk[ik] = 0;
module_cell/klist.cpp:            this->kvec_c[ik+nks] = kvec_c[ik];
module_cell/klist.cpp:            this->kvec_d[ik+nks] = kvec_d[ik];
module_cell/klist.cpp:            this->wk[ik+nks]     = wk[ik];
module_cell/klist.cpp:            this->isk[ik]        = 0;
module_cell/klist.cpp:            this->isk[ik+nks]    = 1;
module_cell/klist.cpp:        this->nks *= 2;
module_cell/klist.cpp:        this->nkstot *= 2;
module_cell/klist.cpp:            this->isk[ik] = 0;
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_c[i].x
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_c[i].y
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_c[i].z
module_cell/klist.cpp:        //      << std::setw(20) << this->wk[i] << std::endl;
module_cell/klist.cpp:        _cartesian_x.push_back(this->kvec_c[i].x);
module_cell/klist.cpp:        _cartesian_y.push_back(this->kvec_c[i].y);
module_cell/klist.cpp:        _cartesian_z.push_back(this->kvec_c[i].z);
module_cell/klist.cpp:        _weights.push_back(this->wk[i]);
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].x
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].y
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].z
module_cell/klist.cpp:        //      << std::setw(20) << this->wk[i] << std::endl;
module_cell/klist.cpp:        _direct_x.push_back(this->kvec_d[i].x);
module_cell/klist.cpp:        _direct_y.push_back(this->kvec_d[i].y);
module_cell/klist.cpp:        _direct_z.push_back(this->kvec_d[i].z);
module_cell/klist.cpp:    this->nspin = nspin_in;
module_cell/klist.cpp:    this->set_both_kvec_after_vc(reciprocal_vec, latvec);
module_cell/klist.cpp:    //this->set_both_kvec(reciprocal_vec, latvec);
module_cell/klist.cpp:    // this->mpi_k_after_vc(); 
module_cell/klist.cpp:    // this->set_kup_and_kdw_after_vc();
module_cell/klist.cpp:    this->print_klists(GlobalV::ofs_running);
module_cell/klist.cpp:    this->nks = GlobalC::Pkpoints.nks_pool[GlobalV::MY_POOL];
module_cell/klist.cpp:    int nks_minimum = this->nks;
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].x
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].y
module_cell/klist.cpp:        //      << std::setw(20) << this->kvec_d[i].z
module_cell/klist.cpp:        //      << std::setw(20) << this->wk[i] << std::endl;
module_cell/klist.cpp:        _direct_x.push_back(this->kvec_d[i].x);
module_cell/klist.cpp:        _direct_y.push_back(this->kvec_d[i].y);
module_cell/klist.cpp:        _direct_z.push_back(this->kvec_d[i].z);
module_cell/klist.cpp:        _weights.push_back(this->wk[i]);
module_cell/klist.cpp:            this->isk[ik] = 0;
module_cell/klist.cpp:            this->kvec_c[ik+nks] = kvec_c[ik];
module_cell/klist.cpp:            this->kvec_d[ik+nks] = kvec_d[ik];
module_cell/klist.cpp:            this->wk[ik+nks]     = wk[ik];
module_cell/klist.cpp:            this->isk[ik]        = 0;
module_cell/klist.cpp:            this->isk[ik+nks]    = 1;
module_cell/klist.cpp:        this->nks *= 2;
module_cell/klist.cpp:        //this->nkstot *= 2; //This makes the code difficult to read.
module_cell/klist.cpp:            this->isk[ik] = 0;
module_cell/klist.h:    int nkp = this->nkstot / GlobalV::KPAR;
module_cell/klist.h:    int rem = this->nkstot % GlobalV::KPAR;
module_cell/module_neighbor/sltk_adjacent_set.cpp:	this->length = 0;
module_cell/module_neighbor/sltk_adjacent_set.cpp:	this->box.push_back(index_box);
module_cell/module_neighbor/sltk_adjacent_set.cpp:	this->offset.push_back(offset_in);
module_cell/module_neighbor/sltk_adjacent_set.cpp:	this->length++;
module_cell/module_neighbor/sltk_atom.h:	{ return this->as; }
module_cell/module_neighbor/sltk_atom.h:	{ this->as = std::make_shared<AdjacentSet>(); }
module_cell/module_neighbor/sltk_atom_input.cpp:	this->x_min = ucell.atoms[0].tau[0].x;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->y_min = ucell.atoms[0].tau[0].y;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->z_min = ucell.atoms[0].tau[0].z;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->x_max = ucell.atoms[0].tau[0].x;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->y_max = ucell.atoms[0].tau[0].y;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->z_max = ucell.atoms[0].tau[0].z;
module_cell/module_neighbor/sltk_atom_input.cpp:			if (ucell.atoms[i].tau[j].x < x_min) this->x_min = ucell.atoms[i].tau[j].x;
module_cell/module_neighbor/sltk_atom_input.cpp:			if (ucell.atoms[i].tau[j].y < y_min) this->y_min = ucell.atoms[i].tau[j].y;
module_cell/module_neighbor/sltk_atom_input.cpp:			if (ucell.atoms[i].tau[j].z < z_min) this->z_min = ucell.atoms[i].tau[j].z;
module_cell/module_neighbor/sltk_atom_input.cpp:			if (ucell.atoms[i].tau[j].x > x_max) this->x_max = ucell.atoms[i].tau[j].x;
module_cell/module_neighbor/sltk_atom_input.cpp:			if (ucell.atoms[i].tau[j].y > y_max) this->y_max = ucell.atoms[i].tau[j].y;
module_cell/module_neighbor/sltk_atom_input.cpp:			if (ucell.atoms[i].tau[j].z > z_max) this->z_max = ucell.atoms[i].tau[j].z;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->Check_Expand_Condition(ucell);
module_cell/module_neighbor/sltk_atom_input.cpp:	if (this->expand_flag)
module_cell/module_neighbor/sltk_atom_input.cpp:		this->Expand_Grid(ucell, ntype);
module_cell/module_neighbor/sltk_atom_input.cpp:	this->calculate_cells();
module_cell/module_neighbor/sltk_atom_input.cpp:		this->expand_flag = true;
module_cell/module_neighbor/sltk_atom_input.cpp:		this->expand_flag = true;
module_cell/module_neighbor/sltk_atom_input.cpp:		this->expand_flag = false;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->d_amount_expand = d_amount * gcopy;
module_cell/module_neighbor/sltk_atom_input.cpp:	this->store_x = new double[d_amount_expand];
module_cell/module_neighbor/sltk_atom_input.cpp:	this->store_y = new double[d_amount_expand];
module_cell/module_neighbor/sltk_atom_input.cpp:	this->store_z = new double[d_amount_expand];
module_cell/module_neighbor/sltk_atom_input.cpp:	this->store_type = new int[d_amount_expand];
module_cell/module_neighbor/sltk_atom_input.cpp:	this->store_natom = new int[d_amount_expand];
module_cell/module_neighbor/sltk_atom_input.cpp:	this->x_min_expand = //this->x_min
module_cell/module_neighbor/sltk_atom_input.cpp:	this->y_min_expand = //this->y_min
module_cell/module_neighbor/sltk_atom_input.cpp:	this->z_min_expand = //this->z_min
module_cell/module_neighbor/sltk_atom_input.cpp:	this->x_max_expand = //this->x_max 
module_cell/module_neighbor/sltk_atom_input.cpp:	this->y_max_expand = //this->y_max 
module_cell/module_neighbor/sltk_atom_input.cpp:	this->z_max_expand = //this->z_max 
module_cell/module_neighbor/sltk_atom_input.cpp://	if(int_nx != real_nx) this->cell_nx++;
module_cell/module_neighbor/sltk_atom_input.cpp://	if(int_ny != real_ny) this->cell_ny++;
module_cell/module_neighbor/sltk_atom_input.cpp://	if(int_nz != real_nz) this->cell_nz++;
module_cell/module_neighbor/sltk_grid.cpp:	this->atomlink = new AtomLink[1];
module_cell/module_neighbor/sltk_grid.cpp:	this->delete_Cell();
module_cell/module_neighbor/sltk_grid.cpp:	this->setMemberVariables(ofs_in, input);
module_cell/module_neighbor/sltk_grid.cpp:	this->setAtomLinkArray(ucell, input);
module_cell/module_neighbor/sltk_grid.cpp:	this->setBoundaryAdjacent(ofs_in, input);
module_cell/module_neighbor/sltk_grid.cpp:	this->delete_Cell();
module_cell/module_neighbor/sltk_grid.cpp:	this->natom = input.getAmount();
module_cell/module_neighbor/sltk_grid.cpp:	this->pbc = input.getBoundary();
module_cell/module_neighbor/sltk_grid.cpp:	if(test_grid)ModuleBase::GlobalFunc::OUT(ofs_in, "PeriodicBoundary", this->pbc);
module_cell/module_neighbor/sltk_grid.cpp:	this->sradius = input.getRadius();
module_cell/module_neighbor/sltk_grid.cpp:		this->vec1[i] = input.vec1[i];
module_cell/module_neighbor/sltk_grid.cpp:		this->vec2[i] = input.vec2[i];
module_cell/module_neighbor/sltk_grid.cpp:		this->vec3[i] = input.vec3[i];
module_cell/module_neighbor/sltk_grid.cpp:	this->lat_now = input.getLatNow();
module_cell/module_neighbor/sltk_grid.cpp:	this->expand_flag = input.getExpandFlag();
module_cell/module_neighbor/sltk_grid.cpp:	this->grid_length[0] = input.Clength0();
module_cell/module_neighbor/sltk_grid.cpp:	this->grid_length[1] = input.Clength1();
module_cell/module_neighbor/sltk_grid.cpp:	this->grid_length[2] = input.Clength2();
module_cell/module_neighbor/sltk_grid.cpp:	this->d_minX = input.minX();
module_cell/module_neighbor/sltk_grid.cpp:	this->d_minY = input.minY();
module_cell/module_neighbor/sltk_grid.cpp:	this->d_minZ = input.minZ();
module_cell/module_neighbor/sltk_grid.cpp:	this->cell_x_length = input.getCellXLength();
module_cell/module_neighbor/sltk_grid.cpp:	this->cell_y_length = input.getCellYLength();
module_cell/module_neighbor/sltk_grid.cpp:	this->cell_z_length = input.getCellZLength();
module_cell/module_neighbor/sltk_grid.cpp:	this->dx = input.getCellX();
module_cell/module_neighbor/sltk_grid.cpp:	this->dy = input.getCellY();
module_cell/module_neighbor/sltk_grid.cpp:	this->dz = input.getCellZ();
module_cell/module_neighbor/sltk_grid.cpp:	this->init_cell_flag = true;
module_cell/module_neighbor/sltk_grid.cpp:	AtomLink* const pointCache = this->Build_Cache(ucell, input);
module_cell/module_neighbor/sltk_grid.cpp:	this->Build_Cell();
module_cell/module_neighbor/sltk_grid.cpp:	this->Build_Hash_Table(ucell, pointCache);
module_cell/module_neighbor/sltk_grid.cpp:	this->Fold_Hash_Table();
module_cell/module_neighbor/sltk_grid.cpp:		this->Construct_Adjacent_expand(i, j, k);
module_cell/module_neighbor/sltk_grid.cpp:		this->Construct_Adjacent_begin();
module_cell/module_neighbor/sltk_grid.cpp:	this->In_Which_Cell(ucell, a, b, c, atom);
module_cell/module_neighbor/sltk_grid.cpp:		++ this->Cell[a][b][c].length;
module_cell/module_neighbor/sltk_grid.cpp://		if(test_grid) ofs_running << std::setw(10) << this->Cell[a][b][c].length << std::endl;
module_cell/module_neighbor/sltk_grid.cpp:		if (this->Push(ucell, current->fatom))
module_cell/module_neighbor/sltk_grid.cpp:	delete[] this->atomlink;
module_cell/module_neighbor/sltk_grid.cpp:	this->atomlink = new AtomLink[this->natom];
module_cell/module_neighbor/sltk_grid.cpp:	this->cordon_p = this->atomlink + this->natom;
module_cell/module_neighbor/sltk_grid.cpp:	AtomLink* cellAddress = this->atomlink;
module_cell/module_neighbor/sltk_grid.cpp:	for (int i = 0; i < this->dx; ++i)
module_cell/module_neighbor/sltk_grid.cpp:		for (int j = 0; j < this->dy; ++j)
module_cell/module_neighbor/sltk_grid.cpp:			for (int k = 0; k < this->dz; ++k)
module_cell/module_neighbor/sltk_grid.cpp:		//a = static_cast<int>( (directx - this->d_minX) + save_add );
module_cell/module_neighbor/sltk_grid.cpp:		//b = static_cast<int>( (directy - this->d_minY) + save_add );
module_cell/module_neighbor/sltk_grid.cpp:		//c = static_cast<int>( (directz - this->d_minZ) + save_add );
module_cell/module_neighbor/sltk_grid.cpp:		a = static_cast<int>(directx - now_x_d - this->d_minX + 0.5 );
module_cell/module_neighbor/sltk_grid.cpp:                b = static_cast<int>(directy - now_y_d - this->d_minY + 0.5 );
module_cell/module_neighbor/sltk_grid.cpp:                c = static_cast<int>(directz - now_z_d - this->d_minZ + 0.5 );
module_cell/module_neighbor/sltk_grid.cpp:			std::cout << " (int)directy=" << (int)directy << " (int)d_minY=" << (int)d_minY << " static_cast<int>( (directx - this->d_minX) )=" << static_cast<int>( (directy - this->d_minY) ) << std::endl;
module_cell/module_neighbor/sltk_grid.cpp:		a = static_cast<int>(std::floor((atom.x() - this->d_minX) / this->cell_x_length));
module_cell/module_neighbor/sltk_grid.cpp:		b = static_cast<int>(std::floor((atom.y() - this->d_minY) / this->cell_y_length));
module_cell/module_neighbor/sltk_grid.cpp:		c = static_cast<int>(std::floor((atom.z() - this->d_minZ) / this->cell_z_length));
module_cell/module_neighbor/sltk_grid.cpp:	this->In_Which_Cell(ucell, a, b, c, atom);
module_cell/module_neighbor/sltk_grid.cpp:	return this->Cell[a][b][c].address +
module_cell/module_neighbor/sltk_grid.cpp:	        % this->Cell[a][b][c].length);
module_cell/module_neighbor/sltk_grid.cpp:	const AtomLink* const end = pointCache + this->natom;
module_cell/module_neighbor/sltk_grid.cpp:		AtomLink* const hashTarget = this->getHashCode(ucell, current->fatom);
module_cell/module_neighbor/sltk_grid.cpp:			hashTarget->next_p = this->cordon_p;
module_cell/module_neighbor/sltk_grid.cpp:		else if (hashTarget->next_p == this->cordon_p)
module_cell/module_neighbor/sltk_grid.cpp:	}availableSpace(this->natom);
module_cell/module_neighbor/sltk_grid.cpp:				AtomLink* current = this->Cell[i][j][k].address;
module_cell/module_neighbor/sltk_grid.cpp:				//			<<"\n length = "<<this->Cell[i][j][k].length<<std::endl;
module_cell/module_neighbor/sltk_grid.cpp:				const AtomLink* const end = current + this->Cell[i][j][k].length;
module_cell/module_neighbor/sltk_grid.cpp:				current = this->Cell[i][j][k].address;
module_cell/module_neighbor/sltk_grid.cpp:						// this->cordon_p or null
module_cell/module_neighbor/sltk_grid.cpp:						if ((current->next_p != this->cordon_p && current->next_p != NullPtr))
module_cell/module_neighbor/sltk_grid.cpp:							atomlink[pos].next_p = this->cordon_p;
module_cell/module_neighbor/sltk_grid.cpp:	AdjacentSet::setExpandFlag(this->expand_flag);
module_cell/module_neighbor/sltk_grid.cpp:	AdjacentSet::setDx(this->dx);
module_cell/module_neighbor/sltk_grid.cpp:	AdjacentSet::setDy(this->dy);
module_cell/module_neighbor/sltk_grid.cpp:	AdjacentSet::setDz(this->dz);
module_cell/module_neighbor/sltk_grid.cpp:	for (int i = 0;i < this->dx;i++)
module_cell/module_neighbor/sltk_grid.cpp:		for (int j = 0;j < this->dy;j++)
module_cell/module_neighbor/sltk_grid.cpp:			for (int k = 0;k < this->dz;k++)
module_cell/module_neighbor/sltk_grid.cpp:				this->Cell[i][j][k].in_grid[0] = i - true_i;
module_cell/module_neighbor/sltk_grid.cpp:				this->Cell[i][j][k].in_grid[1] = j - true_j;
module_cell/module_neighbor/sltk_grid.cpp:				this->Cell[i][j][k].in_grid[2] = k - true_k;
module_cell/module_neighbor/sltk_grid.cpp:		if (this->pbc)
module_cell/module_neighbor/sltk_grid.cpp:	for (int i = 0;i < this->dx;i++)
module_cell/module_neighbor/sltk_grid.cpp:		for (int j = 0;j < this->dy;j++)
module_cell/module_neighbor/sltk_grid.cpp:			for (int k = 0;k < this->dz;k++)
module_cell/module_neighbor/sltk_grid.cpp:	for (int i = 0;i < this->dx;i++)
module_cell/module_neighbor/sltk_grid.cpp:		for (int j = 0;j < this->dy;j++)
module_cell/module_neighbor/sltk_grid.cpp:			for (int k = 0;k < this->dz;k++)
module_cell/module_neighbor/sltk_grid.cpp://					this->Cell[i][j][k].address[ia].fatom.setAdjacentSet( p );
module_cell/module_neighbor/sltk_grid.cpp:					this->Cell[i][j][k].address[ia].fatom.allocate_AdjacentSet();
module_cell/module_neighbor/sltk_grid.cpp:					if (this->pbc)
module_cell/module_neighbor/sltk_grid.cpp:	if (dr != 0.0 && dr <= this->sradius)
module_cell/module_neighbor/sltk_grid.cpp:		int offset = Cell[i2][j2][k2].address - this->atomlink;
module_cell/module_neighbor/sltk_grid.cpp:			if (this->pbc)
module_cell/module_neighbor/sltk_grid.h:		if (this->init_cell_flag)
module_cell/module_neighbor/sltk_grid.h:			for (int i = 0;i < this->dx;i++)
module_cell/module_neighbor/sltk_grid.h:				for (int j = 0;j < this->dy;j++)
module_cell/module_neighbor/sltk_grid.h:					delete[] this->Cell[i][j];
module_cell/module_neighbor/sltk_grid.h:			for (int i = 0;i < this->dx;i++)
module_cell/module_neighbor/sltk_grid.h:				delete[] this->Cell[i];
module_cell/module_neighbor/sltk_grid.h:			delete[] this->Cell;
module_cell/module_neighbor/sltk_grid.h:			this->init_cell_flag = false;
module_cell/module_neighbor/sltk_grid_driver.cpp:	//const int offset = this->Locate_offset(cartesian_pos);
module_cell/module_neighbor/sltk_grid_driver.cpp:	const int offset = this->Locate_offset(ucell, cartesian_pos, ntype, nnumber);
module_cell/module_neighbor/sltk_grid_driver.cpp:	AdjacentAtomInfo* local_adjs = adjs == nullptr ? &this->adj_info : adjs;
module_cell/module_neighbor/sltk_grid_driver.cpp:	this->Find_adjacent_atom(offset, this->atomlink[offset].fatom.getAdjacentSet(), *local_adjs);
module_cell/module_neighbor/sltk_grid_driver.cpp:	AtomLink* Search = this->getHashCode(ucell, temp.fatom);
module_cell/module_neighbor/sltk_grid_driver.cpp:	for (; Search < this->cordon_p ; Search = Search->next_p)
module_cell/module_neighbor/sltk_grid_driver.cpp:			const int offset = Search - this->atomlink;
module_cell/module_neighbor/sltk_grid_driver.cpp://		OUT(GlobalV::ofs_running,"adj_num",this->adj_num);
module_cell/module_neighbor/sltk_grid_driver.cpp:	ntype[adj_num] = this->atomlink[offset].fatom.getType();
module_cell/module_neighbor/sltk_grid_driver.cpp:	natom[adj_num] = this->atomlink[offset].fatom.getNatom();
module_cell/module_neighbor/sltk_grid_driver.cpp:	adjacent_tau[adj_num].x = this->atomlink[offset].fatom.x();
module_cell/module_neighbor/sltk_grid_driver.cpp:	adjacent_tau[adj_num].y = this->atomlink[offset].fatom.y();
module_cell/module_neighbor/sltk_grid_driver.cpp:	adjacent_tau[adj_num].z = this->atomlink[offset].fatom.z();
module_cell/module_neighbor/sltk_grid_driver.cpp:// offset ( the position in this->atomlink , this is
module_cell/module_neighbor/sltk_grid_driver.cpp:		ntype[i] = this->atomlink[offset_i].fatom.getType();
module_cell/module_neighbor/sltk_grid_driver.cpp:		natom[i] = this->atomlink[offset_i].fatom.getNatom();
module_cell/module_neighbor/sltk_grid_driver.cpp:			adjacent_tau[i].x = this->atomlink[offset_i].fatom.x();
module_cell/module_neighbor/sltk_grid_driver.cpp:			adjacent_tau[i].y = this->atomlink[offset_i].fatom.y();
module_cell/module_neighbor/sltk_grid_driver.cpp:			adjacent_tau[i].z = this->atomlink[offset_i].fatom.z();
module_cell/module_neighbor/sltk_grid_driver.cpp:					const double distance = Distance(this->atomlink[offset], this->atomlink[offset_i]);
module_cell/module_neighbor/sltk_grid_driver.cpp:					GlobalV::ofs_running << std::setw(10) << this->atomlink[offset_i].fatom.x()
module_cell/module_neighbor/sltk_grid_driver.cpp:					<< std::setw(10) << this->atomlink[offset_i].fatom.y()
module_cell/module_neighbor/sltk_grid_driver.cpp:					<< std::setw(10) << this->atomlink[offset_i].fatom.z()
module_cell/module_neighbor/sltk_grid_driver.cpp:					assert(distance <= this->sradius);
module_cell/module_neighbor/sltk_grid_driver.cpp:					const double distance = this->Distance(this->atomlink[offset], adjacent_tau[i]);
module_cell/module_neighbor/sltk_grid_driver.cpp:					assert(distance <= this->sradius);
module_cell/module_neighbor/sltk_grid_driver.cpp:	adjacent_site.x = this->atomlink[offset].fatom.x() +
module_cell/module_neighbor/sltk_grid_driver.cpp:	adjacent_site.y = this->atomlink[offset].fatom.y() +
module_cell/module_neighbor/sltk_grid_driver.cpp:	adjacent_site.z = this->atomlink[offset].fatom.z() +
module_cell/module_neighbor/sltk_grid_driver.cpp:		<< " " << this->atomlink[offset].fatom.x()
module_cell/module_neighbor/sltk_grid_driver.cpp:		<< " " << this->atomlink[offset].fatom.y()
module_cell/module_neighbor/sltk_grid_driver.cpp:		<< " " << this->atomlink[offset].fatom.z() 
module_cell/module_neighbor/sltk_grid_driver.cpp:    this->Find_atom(ucell_in, tau, it, ia, &adjs);
module_cell/module_neighbor/test/prepare_unitcell.h:		this->ntype = this->elements.size();
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->setup(this->latname,
module_cell/module_neighbor/test/prepare_unitcell.h:				this->ntype,
module_cell/module_neighbor/test/prepare_unitcell.h:				this->lmaxmax,
module_cell/module_neighbor/test/prepare_unitcell.h:				this->init_vel,
module_cell/module_neighbor/test/prepare_unitcell.h:				this->fixed_axes);
module_cell/module_neighbor/test/prepare_unitcell.h:			ucell->atom_label[it] = this->elements[it];
module_cell/module_neighbor/test/prepare_unitcell.h:			ucell->atom_mass[it] = this->atomic_mass[it];
module_cell/module_neighbor/test/prepare_unitcell.h:			ucell->pseudo_fn[it] = this->pp_files[it];
module_cell/module_neighbor/test/prepare_unitcell.h:			ucell->pseudo_type[it] = this->pp_types[it];
module_cell/module_neighbor/test/prepare_unitcell.h:			ucell->orbital_fn[it] = this->orb_files[it];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->lat0 = this->lat0;
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e11 = this->latvec[0];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e12 = this->latvec[1];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e13 = this->latvec[2];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e21 = this->latvec[3];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e22 = this->latvec[4];
module_cell/module_neighbor/test/prepare_unitcell.h:	       	ucell->latvec.e23 = this->latvec[5];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e31 = this->latvec[6];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e32 = this->latvec[7];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->latvec.e33 = this->latvec[8];
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->Coordinate = this->coor_type;
module_cell/module_neighbor/test/prepare_unitcell.h:		this->atomic_index = 0;
module_cell/module_neighbor/test/prepare_unitcell.h:			ucell->atoms[it].label = this->elements[it];
module_cell/module_neighbor/test/prepare_unitcell.h:			ucell->atoms[it].na = this->natom[it];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].x = this->coordinates[this->atomic_index*3+0];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].y = this->coordinates[this->atomic_index*3+1];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].z = this->coordinates[this->atomic_index*3+2];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].x = this->coordinates[this->atomic_index*3+0];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].y = this->coordinates[this->atomic_index*3+1];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].z = this->coordinates[this->atomic_index*3+2];
module_cell/module_neighbor/test/prepare_unitcell.h:				if(this->init_vel)
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].x = this->velocity[this->atomic_index*3+0];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].y = this->velocity[this->atomic_index*3+1];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].z = this->velocity[this->atomic_index*3+2];
module_cell/module_neighbor/test/prepare_unitcell.h:				if(this->selective_dynamics)
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].x = this->mbl[this->atomic_index*3+0];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].y = this->mbl[this->atomic_index*3+1];
module_cell/module_neighbor/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].z = this->mbl[this->atomic_index*3+2];
module_cell/module_neighbor/test/prepare_unitcell.h:				++(this->atomic_index);
module_cell/module_neighbor/test/prepare_unitcell.h:		ucell->nat = this->natom.sum();
module_cell/module_neighbor/test/sltk_atom_arrange_test.cpp:    this->tot_magnetization = 0.0;
module_cell/module_neighbor/test/sltk_atom_arrange_test.cpp:    this->abs_magnetization = 0.0;
module_cell/module_neighbor/test/sltk_atom_arrange_test.cpp:    this->start_magnetization = nullptr;
module_cell/module_neighbor/test/sltk_atom_arrange_test.cpp:    delete[] this->start_magnetization;
module_cell/module_neighbor/test/sltk_atom_input_test.cpp:    this->tot_magnetization = 0.0;
module_cell/module_neighbor/test/sltk_atom_input_test.cpp:    this->abs_magnetization = 0.0;
module_cell/module_neighbor/test/sltk_atom_input_test.cpp:    this->start_magnetization = nullptr;
module_cell/module_neighbor/test/sltk_atom_input_test.cpp:    delete[] this->start_magnetization;
module_cell/module_neighbor/test/sltk_grid_test.cpp:    this->tot_magnetization = 0.0;
module_cell/module_neighbor/test/sltk_grid_test.cpp:    this->abs_magnetization = 0.0;
module_cell/module_neighbor/test/sltk_grid_test.cpp:    this->start_magnetization = nullptr;
module_cell/module_neighbor/test/sltk_grid_test.cpp:    delete[] this->start_magnetization;
module_cell/module_paw/paw_cell.cpp:    this->map_paw_proj();
module_cell/module_paw/paw_element.cpp:    line = this->scan_file(ifs, "<atom");
module_cell/module_paw/paw_element.cpp:    this->symbol = this->extract_string(line,"symbol=");
module_cell/module_paw/paw_element.cpp:    this->Zat    = this->extract_double(line,"Z=");
module_cell/module_paw/paw_element.cpp:    this->core   = this->extract_double(line,"core=");
module_cell/module_paw/paw_element.cpp:    this->val    = this->extract_double(line,"valence=");
module_cell/module_paw/paw_element.cpp:    this->reset_buffer(ifs);
module_cell/module_paw/paw_element.cpp:    line = this->scan_file(ifs, "<paw_radius");
module_cell/module_paw/paw_element.cpp:    this->rcut   = this->extract_double(line,"rc=");
module_cell/module_paw/paw_element.cpp:    this->reset_buffer(ifs);
module_cell/module_paw/paw_element.cpp:    nstates = this->count_nstates(ifs);
module_cell/module_paw/paw_element.cpp:    this->reset_buffer(ifs);
module_cell/module_paw/paw_element.cpp:        line = this->scan_file(ifs, "<state");
module_cell/module_paw/paw_element.cpp:        this->lstate[istate] = this->extract_int(line,"l=");
module_cell/module_paw/paw_element.cpp:            this->lstate_occ[istate] = this->extract_double(line,"f=");
module_cell/module_paw/paw_element.cpp:            this->lstate_occ[istate] = 0.0;
module_cell/module_paw/paw_element.cpp:    this->nstates_to_mstates();
module_cell/module_paw/paw_element.cpp:    this->reset_buffer(ifs);
module_cell/module_paw/paw_element.cpp:    line = this->scan_file(ifs, "<radial_grid");
module_cell/module_paw/paw_element.cpp:    std::string grid_type = this->extract_string(line,"eq=");
module_cell/module_paw/paw_element.cpp:    rstep = this->extract_double(line,"a=");
module_cell/module_paw/paw_element.cpp:    lstep = this->extract_double(line,"d=");
module_cell/module_paw/paw_element.cpp:    int istart = this->extract_int(line,"istart=");
module_cell/module_paw/paw_element.cpp:    int iend   = this->extract_int(line,"iend=");
module_cell/module_paw/paw_element.cpp:    line = this->scan_file(ifs, "<values>");
module_cell/module_paw/paw_element.cpp:    line = this->scan_file(ifs, "<derivatives>");
module_cell/module_paw/paw_element.cpp:    this->get_nrcut();
module_cell/module_paw/paw_element.cpp:        line = this->scan_file(ifs, "<projector_function");
module_cell/module_paw/paw_sphbes.cpp:    return this->splint(qgrid, ptilde_q[istate_in], d2ptilde_q[istate_in], q_in) * factor;
module_cell/module_paw/paw_sphbes.cpp:            ptilde_q[istate][iq] = this->spherical_bessel_transform(l, ptilde_r[istate], qgrid[iq]);
module_cell/module_paw/paw_sphbes.cpp:            this-> spherical_bessel_function(l,x,sph_bes,tmp,0);
module_cell/module_paw/paw_sphbes.cpp:    return this->simpson_integration(integrand);
module_cell/module_paw/paw_sphbes.cpp:    this->prepare_simpson_integration(rr[mmax], simp_int_meshsz, simp_fact);
module_cell/module_symmetry/symmetry.cpp:    this->nat = st.nat;
module_cell/module_symmetry/symmetry.cpp:    this->ntype = st.ntype;
module_cell/module_symmetry/symmetry.cpp:    this->na = new int[ntype];
module_cell/module_symmetry/symmetry.cpp:    this->istart = new int[ntype];
module_cell/module_symmetry/symmetry.cpp:    this->index = new int [nat + 2];
module_cell/module_symmetry/symmetry.cpp:    this->a1 = lat.a1;
module_cell/module_symmetry/symmetry.cpp:    this->a2 = lat.a2;
module_cell/module_symmetry/symmetry.cpp:    this->a3 = lat.a3;
module_cell/module_symmetry/symmetry.cpp:    this->itmin_type = 0;
module_cell/module_symmetry/symmetry.cpp:    this->itmin_start = 0;
module_cell/module_symmetry/symmetry.cpp:        this->na[it] = atom->na;
module_cell/module_symmetry/symmetry.cpp:            this->itmin_type = it;
module_cell/module_symmetry/symmetry.cpp:            this->itmin_start = istart[it];
module_cell/module_symmetry/symmetry.cpp:        this->lattice_type(this->a1, this->a2, this->a3, this->s1, this->s2, this->s3,
module_cell/module_symmetry/symmetry.cpp:            this->cel_const, this->pre_const, this->real_brav, ilattname, atoms, true, this->newpos);
module_cell/module_symmetry/symmetry.cpp:        this->pricell(this->newpos, atoms);         // pengfei Li 2018-05-14 
module_cell/module_symmetry/symmetry.cpp:        this->setgroup(this->symop, this->nop, this->real_brav);
module_cell/module_symmetry/symmetry.cpp:        if (GlobalV::NSPIN > 1) pricell_loop = this->magmom_same_check(atoms);
module_cell/module_symmetry/symmetry.cpp:                for (int ia = 0;ia < atoms[it].na;++ia) if (atoms[it].mag[ia] > -this->epsilon) ++na_spinup;
module_cell/module_symmetry/symmetry.cpp:                this->na[it] = na_spinup;
module_cell/module_symmetry/symmetry.cpp:                    if (atoms[it].mag[ia] > -this->epsilon)
module_cell/module_symmetry/symmetry.cpp:                        pos_spinup.push_back(this->newpos[3 * (istart[it] + ia)]);
module_cell/module_symmetry/symmetry.cpp:                        pos_spinup.push_back(this->newpos[3 * (istart[it] + ia) + 1]);
module_cell/module_symmetry/symmetry.cpp:                        pos_spinup.push_back(this->newpos[3 * (istart[it] + ia) + 2]);
module_cell/module_symmetry/symmetry.cpp:                    this->itmin_type = it;
module_cell/module_symmetry/symmetry.cpp:                    this->itmin_start = istart[it];
module_cell/module_symmetry/symmetry.cpp:            this->getgroup(nrot_out, nrotk_out, ofs_running, pos_spinup.data());
module_cell/module_symmetry/symmetry.cpp:                this->na[it] = atoms[it].na;
module_cell/module_symmetry/symmetry.cpp:            this->getgroup(nrot_out, nrotk_out, ofs_running, this->newpos);
module_cell/module_symmetry/symmetry.cpp:        if (this->nrotk > this->max_nrotk)this->max_nrotk = this->nrotk;
module_cell/module_symmetry/symmetry.cpp:        while (tmp_nrotk < this->max_nrotk && epsilon < MAX_EPS)
module_cell/module_symmetry/symmetry.cpp:        if (tmp_nrotk > this->nrotk)
module_cell/module_symmetry/symmetry.cpp:            this->nrotk = tmp_nrotk;
module_cell/module_symmetry/symmetry.cpp:            if (this->nrotk > this->max_nrotk)this->max_nrotk = this->nrotk;
module_cell/module_symmetry/symmetry.cpp:                this->nrotk = tmp_nrotk;
module_cell/module_symmetry/symmetry.cpp:            this->nrotk = tmp_nrotk;
module_cell/module_symmetry/symmetry.cpp:        lattice_to_group(this->nrot, this->nrotk, ofs_running);
module_cell/module_symmetry/symmetry.cpp:    ofs_running << "symmetry_prec(epsilon) in current ion step: " << this->epsilon << std::endl;
module_cell/module_symmetry/symmetry.cpp:    ofs_running << "number of symmetry operations in current ion step: " << this->nrotk << std::endl;
module_cell/module_symmetry/symmetry.cpp:    this->pointgroup(this->nrot, this->pgnumber, this->pgname, this->gmatrix, ofs_running);
module_cell/module_symmetry/symmetry.cpp:	ModuleBase::GlobalFunc::OUT(ofs_running,"POINT GROUP", this->pgname);
module_cell/module_symmetry/symmetry.cpp:    this->pointgroup(this->nrotk, this->spgnumber, this->spgname, this->gmatrix, ofs_running);
module_cell/module_symmetry/symmetry.cpp:    ModuleBase::GlobalFunc::OUT(ofs_running, "POINT GROUP IN SPACE GROUP", this->spgname);
module_cell/module_symmetry/symmetry.cpp:    if (!this->valid_group)
module_cell/module_symmetry/symmetry.cpp:        std::vector<int>invmap(this->nrotk, -1);
module_cell/module_symmetry/symmetry.cpp:        this->gmatrix_invmap(this->gmatrix, this->nrotk, invmap.data());
module_cell/module_symmetry/symmetry.cpp:        for (int isym = 0;isym < this->nrotk;++isym)
module_cell/module_symmetry/symmetry.cpp:                    this->gmatrix[nrotk_new] = this->gmatrix[isym];
module_cell/module_symmetry/symmetry.cpp:                    this->gtrans[nrotk_new] = this->gtrans[isym];
module_cell/module_symmetry/symmetry.cpp:        this->nrotk = nrotk_new;
module_cell/module_symmetry/symmetry.cpp:    this->gmatrix_convert_int(gmatrix, kgmatrix, nrotk, optlat, lat.G);
module_cell/module_symmetry/symmetry.cpp:    this->gmatrix_convert_int(gmatrix, gmatrix, nrotk, optlat, latvec1);
module_cell/module_symmetry/symmetry.cpp:    this->gtrans_convert(gtrans, gtrans, nrotk, optlat, latvec1);
module_cell/module_symmetry/symmetry.cpp:    this->set_atom_map(atoms);
module_cell/module_symmetry/symmetry.cpp:        this->all_mbl = this->is_all_movable(atoms, st);
module_cell/module_symmetry/symmetry.cpp:        if (!this->all_mbl)
module_cell/module_symmetry/symmetry.cpp:    this->get_shortest_latvec(v1, v2, v3);
module_cell/module_symmetry/symmetry.cpp:    this->get_optlat(v1, v2, v3, w1, w2, w3, real_brav, cel_const, temp_const);
module_cell/module_symmetry/symmetry.cpp:            for (int it = 0; it < this->ntype; ++it)
module_cell/module_symmetry/symmetry.cpp:                for (int ia = 0; ia < this->na[it]; ++ia)
module_cell/module_symmetry/symmetry.cpp:                                    this->check_translation( newpos[at*3+k], -floor(newpos[at*3+k]));
module_cell/module_symmetry/symmetry.cpp:                                    this->check_boundary( newpos[at*3+k] );
module_cell/module_symmetry/symmetry.cpp:            for (int it = 0; it < this->ntype; it++)
module_cell/module_symmetry/symmetry.cpp:                for (int ia = 0; ia < this->na[it]; ia++)
module_cell/module_symmetry/symmetry.cpp:            for (int it = 0; it < this->ntype; ++it)
module_cell/module_symmetry/symmetry.cpp:                for (int ia = 0; ia < this->na[it]; ++ia)
module_cell/module_symmetry/symmetry.cpp:                            this->check_translation( newpos[at*3+k], -floor(newpos[at*3+k]));
module_cell/module_symmetry/symmetry.cpp:                            this->check_boundary( newpos[at*3+k] );
module_cell/module_symmetry/symmetry.cpp:        this->checksym(this->symop[i], this->gtrans[i], pos);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(pos[j*3+0]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(pos[j*3+1]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(pos[j*3+2]);
module_cell/module_symmetry/symmetry.cpp:        this->atom_ordering_new(pos + istart[it] * 3, na[it], index + istart[it]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(rotpos[xx]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(rotpos[yy]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(rotpos[zz]);
module_cell/module_symmetry/symmetry.cpp:        this->atom_ordering_new(rotpos + istart[it] * 3, na[it], index + istart[it]);
module_cell/module_symmetry/symmetry.cpp:        gtrans.x = this->get_translation_vector( sptmin.x, pos[i*3+0]);
module_cell/module_symmetry/symmetry.cpp:        gtrans.y = this->get_translation_vector( sptmin.y, pos[i*3+1]);
module_cell/module_symmetry/symmetry.cpp:        gtrans.z = this->get_translation_vector( sptmin.z, pos[i*3+2]);
module_cell/module_symmetry/symmetry.cpp:                this->check_translation( rotpos[ia*3+0], gtrans.x );
module_cell/module_symmetry/symmetry.cpp:                this->check_translation( rotpos[ia*3+1], gtrans.y );
module_cell/module_symmetry/symmetry.cpp:                this->check_translation( rotpos[ia*3+2], gtrans.z );
module_cell/module_symmetry/symmetry.cpp:                this->check_boundary( rotpos[ia*3+0] );
module_cell/module_symmetry/symmetry.cpp:                this->check_boundary( rotpos[ia*3+1] );
module_cell/module_symmetry/symmetry.cpp:                this->check_boundary( rotpos[ia*3+2] );
module_cell/module_symmetry/symmetry.cpp:            this->atom_ordering_new(rotpos + istart[it] * 3, na[it], index + istart[it]);
module_cell/module_symmetry/symmetry.cpp:                diff.x = this->check_diff( pos[ia*3+0], rotpos[ia*3+0]);
module_cell/module_symmetry/symmetry.cpp:                diff.y = this->check_diff( pos[ia*3+1], rotpos[ia*3+1]);
module_cell/module_symmetry/symmetry.cpp:                diff.z = this->check_diff( pos[ia*3+2], rotpos[ia*3+2]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(pos[j*3+0]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(pos[j*3+1]);
module_cell/module_symmetry/symmetry.cpp:            this->check_boundary(pos[j*3+2]);
module_cell/module_symmetry/symmetry.cpp:        this->atom_ordering_new(pos + istart[it] * 3, na[it], index + istart[it]);
module_cell/module_symmetry/symmetry.cpp:        tmp_ptrans[0] = this->get_translation_vector( pos[i*3+0], sptmin.x);
module_cell/module_symmetry/symmetry.cpp:        tmp_ptrans[1] = this->get_translation_vector( pos[i*3+1], sptmin.y);
module_cell/module_symmetry/symmetry.cpp:        tmp_ptrans[2] = this->get_translation_vector( pos[i*3+2], sptmin.z);
module_cell/module_symmetry/symmetry.cpp:                this->check_translation( rotpos[ia*3+0], tmp_ptrans[0] );
module_cell/module_symmetry/symmetry.cpp:                this->check_translation( rotpos[ia*3+1], tmp_ptrans[1] );
module_cell/module_symmetry/symmetry.cpp:                this->check_translation( rotpos[ia*3+2], tmp_ptrans[2] );
module_cell/module_symmetry/symmetry.cpp:                this->check_boundary( rotpos[ia*3+0] );
module_cell/module_symmetry/symmetry.cpp:                this->check_boundary( rotpos[ia*3+1] );
module_cell/module_symmetry/symmetry.cpp:                this->check_boundary( rotpos[ia*3+2] );
module_cell/module_symmetry/symmetry.cpp:            this->atom_ordering_new(rotpos + istart[it] * 3, na[it], index + istart[it]);
module_cell/module_symmetry/symmetry.cpp:                diff.x = this->check_diff( pos[ia*3+0], rotpos[ia*3+0]);
module_cell/module_symmetry/symmetry.cpp:                diff.y = this->check_diff( pos[ia*3+1], rotpos[ia*3+1]);
module_cell/module_symmetry/symmetry.cpp:                diff.z = this->check_diff( pos[ia*3+2], rotpos[ia*3+2]);
module_cell/module_symmetry/symmetry.cpp:        this->p1=this->a1;
module_cell/module_symmetry/symmetry.cpp:        this->p2=this->a2;
module_cell/module_symmetry/symmetry.cpp:        this->p3=this->a3;
module_cell/module_symmetry/symmetry.cpp:        this->pbrav=this->real_brav;
module_cell/module_symmetry/symmetry.cpp:        this->ncell=1;
module_cell/module_symmetry/symmetry.cpp:        for (int i=0;i<6;++i)   this->pcel_const[i]=this->cel_const[i];
module_cell/module_symmetry/symmetry.cpp:    this->atom_ordering_new(ptrans_array, ntrans, index);
module_cell/module_symmetry/symmetry.cpp:    while(kplane<ntrans && std::abs(ptrans[kplane].z-ptrans[0].z)<this->epsilon) ++kplane;
module_cell/module_symmetry/symmetry.cpp:    while(jplane<ntrans && (std::abs(ptrans[jplane].y-ptrans[0].y)<this->epsilon
module_cell/module_symmetry/symmetry.cpp:    while(iplane<ntrans && (std::abs(ptrans[iplane].x-ptrans[0].x)<this->epsilon
module_cell/module_symmetry/symmetry.cpp:    this->plat=coeff*this->optlat;
module_cell/module_symmetry/symmetry.cpp:        this->plat=coeff*this->optlat;
module_cell/module_symmetry/symmetry.cpp:    this->p1.x=plat.e11;
module_cell/module_symmetry/symmetry.cpp:    this->p1.y=plat.e12;
module_cell/module_symmetry/symmetry.cpp:    this->p1.z=plat.e13;
module_cell/module_symmetry/symmetry.cpp:    this->p2.x=plat.e21;
module_cell/module_symmetry/symmetry.cpp:    this->p2.y=plat.e22;
module_cell/module_symmetry/symmetry.cpp:    this->p2.z=plat.e23;       
module_cell/module_symmetry/symmetry.cpp:    this->p3.x=plat.e31;
module_cell/module_symmetry/symmetry.cpp:    this->p3.y=plat.e32;
module_cell/module_symmetry/symmetry.cpp:    this->p3.z=plat.e33;
module_cell/module_symmetry/symmetry.cpp:    this->lattice_type(p1, p2, p3, p01, p02, p03, pcel_const, pcel_pre_const, pbrav, pbravname, atoms, false, nullptr);
module_cell/module_symmetry/symmetry.cpp:    this->plat.e11=p1.x;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e12=p1.y;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e13=p1.z;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e21=p2.x;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e22=p2.y;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e23=p2.z;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e31=p3.x;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e32=p3.y;
module_cell/module_symmetry/symmetry.cpp:    this->plat.e33=p3.z;
module_cell/module_symmetry/symmetry.cpp:    Symm_Other::print1(this->pbrav, this->pcel_const, GlobalV::ofs_running);
module_cell/module_symmetry/symmetry.cpp:    GlobalV::ofs_running<<"optimized lattice volume: "<<this->optlat.Det()<<std::endl;
module_cell/module_symmetry/symmetry.cpp:    GlobalV::ofs_running<<"optimized primitive cell volume: "<<this->plat.Det()<<std::endl;
module_cell/module_symmetry/symmetry.cpp:    double ncell_double = std::abs(this->optlat.Det()/this->plat.Det());
module_cell/module_symmetry/symmetry.cpp:    this->ncell=floor(ncell_double+0.5);
module_cell/module_symmetry/symmetry.cpp:        this->ncell = 1;
module_cell/module_symmetry/symmetry.cpp:        this->ptrans = std::vector<ModuleBase::Vector3<double> >(1, ModuleBase::Vector3<double>(0, 0, 0));
module_cell/module_symmetry/symmetry.cpp:    if (this->ncell != ntrans)
module_cell/module_symmetry/symmetry.cpp:    if(std::abs(ncell_double-double(this->ncell)) > this->epsilon*100)
module_cell/module_symmetry/symmetry.cpp:    GlobalV::ofs_running<<"Original cell was built up by "<<this->ncell<<" primitive cells."<<std::endl;
module_cell/module_symmetry/symmetry.cpp:    this->gtrans_convert(ptrans.data(), ptrans.data(), ntrans, this->optlat, inputlat );
module_cell/module_symmetry/symmetry.cpp:    ModuleBase::Matrix3 nummat0=this->optlat*this->plat.Inverse();
module_cell/module_symmetry/symmetry.cpp:    if(n1*n2*n3 != this->ncell) 
module_cell/module_symmetry/symmetry.cpp:                        this->rotate(gmatrix[isym], gtrans[isym], i, j, k, nr1, nr2, nr3, ri[isym], rj[isym], rk[isym]);
module_cell/module_symmetry/symmetry.cpp:    this->gmatrix_invmap(kgmatrix, nrotk, invmap);
module_cell/module_symmetry/symmetry.cpp:                    for (int ipt = 0;ipt < ((ModuleSymmetry::Symmetry::pricell_loop) ? this->ncell : 1);++ipt)
module_cell/module_symmetry/symmetry.cpp:    if (this->isym_rotiat_.size() == this->nrotk) return;
module_cell/module_symmetry/symmetry.cpp:    this->isym_rotiat_.resize(this->nrotk);
module_cell/module_symmetry/symmetry.cpp:    for (int i = 0; i < this->nrotk; ++i)this->isym_rotiat_[i].resize(this->nat, -1);
module_cell/module_symmetry/symmetry.cpp:    double* pos = this->newpos;
module_cell/module_symmetry/symmetry.cpp:    double* rotpos = this->rotpos;
module_cell/module_symmetry/symmetry.cpp:    ModuleBase::GlobalFunc::ZEROS(pos, this->nat * 3);
module_cell/module_symmetry/symmetry.cpp:    for (int it = 0; it < this->ntype; it++)
module_cell/module_symmetry/symmetry.cpp:        for (int ia = 0; ia < this->na[it]; ia++)
module_cell/module_symmetry/symmetry.cpp:                this->check_translation(pos[iat * 3 + k], -floor(pos[iat * 3 + k]));
module_cell/module_symmetry/symmetry.cpp:                this->check_boundary(pos[iat * 3 + k]);
module_cell/module_symmetry/symmetry.cpp:    for (int it = 0; it < this->ntype; it++)
module_cell/module_symmetry/symmetry.cpp:            for (int k = 0;k < this->nrotk;++k)
module_cell/module_symmetry/symmetry.cpp:                        this->isym_rotiat_[k][ia] = ja;
module_cell/module_symmetry/symmetry.cpp:            int l = this->isym_rotiat_[k][j];
module_cell/module_symmetry/symmetry.h:        this->epsilon = 1e-6;
module_cell/module_symmetry/symmetry.h:        this->tab = 12;
module_cell/module_symmetry/symmetry.h:        this->available = true;
module_cell/module_symmetry/symmetry_basic.cpp:	//this->heapsort_pos(natom, posi, subindex);
module_cell/module_symmetry/symmetry_basic.cpp:	this->order_atoms(posi, natom, subindex);
module_cell/module_symmetry/symmetry_basic.cpp:			this->order_y(&posi[oldpos*3], oldpos, newpos);
module_cell/module_symmetry/symmetry_basic.cpp:			this->order_y(&posi[oldpos*3], oldpos, newpos+1);	
module_cell/module_symmetry/symmetry_basic.cpp:	this->order_atoms(pos1,nat1,index1);
module_cell/module_symmetry/symmetry_basic.cpp:			this->order_z(&pos1[oldpos2*3], oldpos2, newpos2);
module_cell/module_symmetry/symmetry_basic.cpp:			this->order_z(&pos1[oldpos2*3], oldpos2, newpos2+1);
module_cell/module_symmetry/symmetry_basic.cpp:	this->order_atoms(pos2,nat2,index2);
module_cell/module_symmetry/symmetry_basic.cpp:	//this->recip(1.0, new1, new2, new3, rb1, rb2, rb3);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 1, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 2, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 2, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:		this->matrigen(symgen, 3, symop, nop);
module_cell/module_symmetry/symmetry_basic.cpp:    pgnumber = this->subgroup(nrot, ninv, nc2, nc3, nc4, nc6, ns1, ns3, ns4, ns6);
module_cell/module_symmetry/symmetry_basic.cpp:    this->valid_group = false;
module_cell/module_symmetry/symmetry_basic.cpp:	this->order_atoms(posi, natom, subindex);
module_cell/module_symmetry/symmetry_basic.cpp:			this->order_atoms(&posi[i*3], nxequal, subindex);
module_cell/module_symmetry/symmetry_basic.cpp:	this->atom_ordering_new(posi, natom, subindex);
module_cell/parallel_kpoints.cpp:    this->get_nks_pool(nkstot);
module_cell/parallel_kpoints.cpp:    this->get_startk_pool(nkstot);
module_cell/parallel_kpoints.cpp:    this->get_whichpool(nkstot);
module_cell/parallel_kpoints.cpp:    this->kpar = GlobalV::KPAR;
module_cell/parallel_kpoints.cpp:    this->nkstot_np = nkstot;
module_cell/parallel_kpoints.cpp:    this->nks_np = this->nks_pool[GlobalV::MY_POOL];
module_cell/parallel_kpoints.cpp:    this->kpar = 1;
module_cell/parallel_kpoints.cpp:    this->nkstot_np = nkstot;
module_cell/parallel_kpoints.cpp:    this->nks_np = nkstot;
module_cell/parallel_kpoints.cpp:    this->whichpool = new int[nkstot];
module_cell/parallel_kpoints.cpp:        for (int ik=0; ik< this->nks_pool[i]; ik++)
module_cell/parallel_kpoints.cpp:            this->whichpool[k_now] = i;
module_cell/parallel_kpoints.cpp:    this->nks_pool = new int[GlobalV::KPAR];
module_cell/parallel_kpoints.cpp:        this->nks_pool[i] = nks_ave;
module_cell/parallel_kpoints.cpp:    vec_global.resize(this->nkstot_np, ModuleBase::Vector3<double>(0.0, 0.0, 0.0));
module_cell/parallel_kpoints.cpp:    for (int i = 0; i < this->nks_np; ++i)
module_cell/parallel_kpoints.cpp:    MPI_Allreduce(MPI_IN_PLACE, &vec_global[0], 3 * this->nkstot_np, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
module_cell/parallel_kpoints.cpp:        const int ik_now = ik - this->startk_pool[GlobalV::MY_POOL];
module_cell/parallel_kpoints.cpp:        if (this->whichpool[ik] == GlobalV::MY_POOL)
module_cell/parallel_kpoints.cpp:                const int iproc = this->startpro_pool[ this->whichpool[ik] ];
module_cell/parallel_kpoints.cpp:    const int ik_now = ik - this->startk_pool[GlobalV::MY_POOL];
module_cell/parallel_kpoints.cpp:    const int pool = this->whichpool[ik];
module_cell/parallel_kpoints.cpp:                MPI_Recv(valuea, dim, MPI_DOUBLE, this->startpro_pool[pool], ik*2+0, MPI_COMM_WORLD,&ierror);
module_cell/parallel_kpoints.cpp:                MPI_Recv(valueb, dim, MPI_DOUBLE, this->startpro_pool[pool], ik*2+1, MPI_COMM_WORLD,&ierror);
module_cell/parallel_kpoints.cpp:    	if(this->whichpool[ik] == GlobalV::MY_POOL)
module_cell/parallel_kpoints.cpp:    			const int iproc = this->startpro_pool[ this->whichpool[ik] ];
module_cell/parallel_kpoints.cpp:    const int ik_now = ik - this->startk_pool[GlobalV::MY_POOL];
module_cell/parallel_kpoints.cpp:    if(GlobalV::NSPIN != 2) pool = this->whichpool[ik];
module_cell/parallel_kpoints.cpp:                MPI_Recv(value, dim, MPI_DOUBLE, this->startpro_pool[pool], ik*2+0, MPI_COMM_WORLD,&ierror);
module_cell/pseudo.cpp:    this->set_pseudo_h(upf);
module_cell/pseudo.cpp:	this->set_pseudo_atom(upf);
module_cell/pseudo.cpp:	this->set_pseudo_vl(upf);
module_cell/pseudo.cpp:	this->nv = upf.nv;// UPF file version number
module_cell/pseudo.cpp:	this->psd = upf.psd;
module_cell/pseudo.cpp:	this->pp_type = upf.pp_type;
module_cell/pseudo.cpp:	this->tvanp = upf.tvanp;// if USPP
module_cell/pseudo.cpp:	this->nlcc = upf.nlcc;// Non linear core corrections( bool ?)
module_cell/pseudo.cpp:	this->xc_func = upf.xc_func;
module_cell/pseudo.cpp:	this->zv = upf.zp;
module_cell/pseudo.cpp:	this->etotps = upf.etotps;
module_cell/pseudo.cpp:	this->ecutwfc = upf.ecutwfc;
module_cell/pseudo.cpp:	this->ecutrho = upf.ecutrho;
module_cell/pseudo.cpp:	this->lmax = upf.lmax;
module_cell/pseudo.cpp:	this->mesh = upf.mesh;
module_cell/pseudo.cpp:	if (this->mesh > ndmx)
module_cell/pseudo.cpp:	this->nchi = upf.nwfc;
module_cell/pseudo.cpp:	this->nbeta = upf.nbeta;
module_cell/pseudo.cpp:    this->kkbeta = upf.kkbeta;
module_cell/pseudo.cpp:    this->els = new std::string[nchi];
module_cell/pseudo.cpp:    assert(this->els != 0);
module_cell/pseudo.cpp:    this->lchi = new int[this->nchi];
module_cell/pseudo.cpp:    assert(this->lchi != 0);
module_cell/pseudo.cpp:    this->oc = new double[nchi];
module_cell/pseudo.cpp:    assert(this->oc != 0);
module_cell/pseudo.cpp:        this->els[i] = upf.els[i];
module_cell/pseudo.cpp:        this->lchi[i] = upf.lchi[i];
module_cell/pseudo.cpp:        this->oc[i] = upf.oc[i];
module_cell/pseudo.cpp:    this->jjj = new double[nbeta];
module_cell/pseudo.cpp:    assert(this->jjj != 0);
module_cell/pseudo.cpp:	this->nn = new int[nchi];
module_cell/pseudo.cpp:	assert(this->nn != 0);
module_cell/pseudo.cpp:	this->jchi = new double[nchi];
module_cell/pseudo.cpp:	assert(this->jchi != 0);
module_cell/pseudo.cpp:	this->has_so = upf.has_so;//added by zhengdy-soc
module_cell/pseudo.cpp:	if (this->has_so)
module_cell/pseudo.cpp:			this->nn[i] = upf.nn[i];
module_cell/pseudo.cpp:			this->jchi[i] = upf.jchi[i];
module_cell/pseudo.cpp:			this->jjj[i]  = upf.jjj [i];
module_cell/pseudo.cpp:			this->nn[i] = 0;
module_cell/pseudo.cpp:			this->jchi[i] = 0;
module_cell/pseudo.cpp:			this->jjj[i]  = 0;
module_cell/pseudo.cpp:        this->nqlc = upf.nqlc;
module_cell/pseudo.cpp:        this->qfuncl.create(nqlc, nbeta * (nbeta + 1) / 2, mesh);
module_cell/pseudo.cpp:        this->qfuncl = upf.qfuncl;
module_cell/pseudo.cpp:        this->qqq.create(nbeta, nbeta);
module_cell/pseudo.cpp:        this->qqq = upf.qqq;
module_cell/pseudo.cpp:	this->rcut = GlobalV::PSEUDORCUT;//(a.u.);
module_cell/pseudo.cpp:	this->msh = 0;
module_cell/read_atoms.cpp:	this->atom_mass  = new double[ntype]; //atom masses
module_cell/read_atoms.cpp:	this->atom_label = new std::string[ntype]; //atom labels
module_cell/read_atoms.cpp:	this->pseudo_fn  = new std::string[ntype]; //file name of pseudopotential
module_cell/read_atoms.cpp:	this->pseudo_type = new std::string[ntype]; // type of pseudopotential
module_cell/read_atoms.cpp:    this->orbital_fn = new std::string[ntype]; // filename of orbitals
module_cell/read_atoms.cpp:				this->atoms[i].flag_empty_element = 
module_cell/read_atoms.cpp:		this->tpiba  = ModuleBase::TWO_PI / lat0;
module_cell/read_atoms.cpp:		this->tpiba2 = tpiba * tpiba;
module_cell/read_atoms.cpp:		this->nat = 0;
module_cell/read_atoms.cpp:			if(this->atoms[it].label != this->atom_label[it])
module_cell/read_atoms.cpp:				ofs_warning << " Label read from ATOMIC_POSITIONS is " << this->atoms[it].label << std::endl; 
module_cell/read_atoms.cpp:				ofs_warning << " Label from ATOMIC_SPECIES is " << this->atom_label[it] << std::endl;
module_cell/read_atoms.cpp:				this->read_orb_file(it, orbital_file, ofs_running, &(atoms[it]));
module_cell/read_atoms.cpp:					this->read_orb_file(it, orbital_file, ofs_running, &(atoms[it]));
module_cell/read_atoms.cpp:					this->atoms[it].nw = 0;
module_cell/read_atoms.cpp:					this->atoms[it].nwl = 2;
module_cell/read_atoms.cpp:						this->atoms[it].nwl = lmaxmax;
module_cell/read_atoms.cpp:					delete[] this->atoms[it].l_nchi;
module_cell/read_atoms.cpp:					this->atoms[it].l_nchi = new int[ this->atoms[it].nwl+1];
module_cell/read_atoms.cpp:						this->atoms[it].l_nchi[L] = 1;
module_cell/read_atoms.cpp:						this->atoms[it].nw += (2*L + 1) * this->atoms[it].l_nchi[L];
module_cell/read_atoms.cpp:			this->atoms[it].na = na;
module_cell/read_atoms.cpp:			this->nat += na;
module_cell/read_atoms.cpp:				atoms[it].mass = this->atom_mass[it]; //mohan add 2011-11-07 
module_cell/read_atoms.cpp:			for (int ia = 0;ia < this->atoms[it].na; ia++)
module_cell/read_atoms.cpp:					for (int ia = 0;ia < this->atoms[it].na; ia++)
module_cell/read_atoms.cpp:					for (int ia = 0;ia < this->atoms[it].na; ia++)
module_cell/read_atoms.cpp:	if(!this->if_atoms_can_move() && GlobalV::CALCULATION=="md" && GlobalV::ESOLVER_TYPE!="tddft")
module_cell/read_atoms.cpp:	//this->print_cell_xyz("STRU_READIN.xyz");
module_cell/read_atoms.cpp:	this->check_dtau();
module_cell/read_atoms.cpp:	if ( this->check_tau() )
module_cell/read_atoms.cpp:	this->print_tau();
module_cell/read_atoms.cpp:	//this->print_cell_xyz("STRU_READIN_ADJUST.xyz");
module_cell/read_atoms.cpp:	this->print_cell_cif("STRU_READIN_ADJUST.cif");
module_cell/read_atoms.cpp:	for(int T1=0; T1< this->ntype; T1++)
module_cell/read_atoms.cpp:		for(int I1=0; I1< this->atoms[T1].na; I1++)
module_cell/read_atoms.cpp:			for(int T2=0; T2<this->ntype; T2++)
module_cell/read_atoms.cpp:				for(int I2=0; I2<this->atoms[T2].na; I2++)
module_cell/read_atoms.cpp:							GlobalV::ofs_warning << " type:" << this->atoms[T1].label << " atom " << I1 + 1 << std::endl; 
module_cell/read_atoms.cpp:							GlobalV::ofs_warning << " type:" << this->atoms[T2].label << " atom " << I2 + 1 << std::endl; 
module_cell/read_cell_pseudopots.cpp:        upf.coulomb_potential=this->atoms[i].coulomb_potential;
module_cell/read_cell_pseudopots.cpp:			pp_address = pp_dir + this->pseudo_fn[i];
module_cell/read_cell_pseudopots.cpp:			error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); //xiaohui add 2013-06-23
module_cell/read_cell_pseudopots.cpp:				if(this->atoms[i].flag_empty_element)	// Peize Lin add for bsse 2021.04.07
module_cell/read_cell_pseudopots.cpp:            this->atoms[i].coulomb_potential = upf.coulomb_potential;
module_cell/read_cell_pseudopots.cpp:	this->print_cell(ofs);
module_cell/read_pp.cpp:	if(!this->has_so && GlobalV::LSPINORB) 
module_cell/read_pp.cpp:	if(!this->has_so || (GlobalV::LSPINORB && std::abs(lambda_ - 1.0) < 1.0e-8) )
module_cell/read_pp.cpp:		for(int nb=0; nb< this->nbeta; nb++)
module_cell/read_pp.cpp:			if(this->lll[nb] != 0 && std::abs(this->jjj[nb] - this->lll[nb] - 0.5) < 1e-6) //two J = l +- 0.5 average to one
module_cell/read_pp.cpp:		this->nbeta = new_nbeta;
module_cell/read_pp.cpp:		dion_new.create(this->nbeta, this->nbeta);
module_cell/read_pp.cpp:		for(int nb=0; nb<this->nbeta; nb++)
module_cell/read_pp.cpp:			int l = this->lll[old_nbeta];
module_cell/read_pp.cpp:				if(std::abs(this->jjj[old_nbeta] - this->lll[old_nbeta] + 0.5) < 1e-6)
module_cell/read_pp.cpp:					if(std::abs(this->jjj[old_nbeta+1]-this->lll[old_nbeta+1]-0.5)>1e-6) 
module_cell/read_pp.cpp:					if(std::abs(this->jjj[old_nbeta+1]-this->lll[old_nbeta+1]+0.5)>1e-6)
module_cell/read_pp.cpp:				double vion1 = ((l+1.0) * this->dion(ind,ind) + l * this->dion(ind1,ind1)) / (2.0*l+1.0);
module_cell/read_pp.cpp:				for(int ir = 0; ir<this->mesh;ir++)
module_cell/read_pp.cpp:					this->beta(nb, ir) = 1.0 / (2.0 * l + 1.0) * 
module_cell/read_pp.cpp:							( (l + 1.0) * sqrt(std::abs(this->dion(ind,ind) / vion1)) *
module_cell/read_pp.cpp:							this->beta(ind, ir) + 
module_cell/read_pp.cpp:							l * sqrt(std::abs(this->dion(ind1,ind1) / vion1)) *
module_cell/read_pp.cpp:							this->beta(ind1, ir) ) ;
module_cell/read_pp.cpp:				this->dion(nb, nb) = vion1;
module_cell/read_pp.cpp:				for(int ir = 0; ir<this->mesh;ir++)
module_cell/read_pp.cpp:					this->beta(nb, ir) = this->beta(old_nbeta, ir);
module_cell/read_pp.cpp:				this->dion(nb, nb) = this->dion(old_nbeta, old_nbeta);
module_cell/read_pp.cpp:			this->lll[nb] = this->lll[old_nbeta]; //reset the lll index, ignore jjj index
module_cell/read_pp.cpp:		for(int i=0;i<this->nbeta; i++)
module_cell/read_pp.cpp:			for(int j=0;j<this->nbeta;j++)
module_cell/read_pp.cpp:				dion_new(i,j) = this->dion(i,j);
module_cell/read_pp.cpp:		this->dion = dion_new;
module_cell/read_pp.cpp:	//	this->dion.create(this->nbeta, this->nbeta);
module_cell/read_pp.cpp:	//	for(int i=0;i<this->nbeta; i++)
module_cell/read_pp.cpp:	//		for(int j=0;j<this->nbeta;j++)
module_cell/read_pp.cpp:	//			this->dion(i,j) = dion_new(i,j);
module_cell/read_pp.cpp:		for(int nb=0; nb<this->nwfc; nb++)
module_cell/read_pp.cpp:			if(this->lchi[nb] != 0 && std::abs(this->jchi[nb] - this->lchi[nb] - 0.5)<1e-6)
module_cell/read_pp.cpp:		this->nwfc = new_nwfc;
module_cell/read_pp.cpp:		for(int nb=0; nb<this->nwfc; nb++)
module_cell/read_pp.cpp:			int l = this->lchi[old_nwfc];
module_cell/read_pp.cpp:				if(std::abs(this->jchi[old_nwfc] - this->lchi[old_nwfc] + 0.5) < 1e-6)
module_cell/read_pp.cpp:					if(std::abs(this->jchi[old_nwfc+1]-this->lchi[old_nwfc+1]-0.5)>1e-6) 
module_cell/read_pp.cpp:					if(std::abs(this->jchi[old_nwfc+1]-this->lchi[old_nwfc+1]+0.5)>1e-6)
module_cell/read_pp.cpp:				for(int ir = 0; ir<this->mesh;ir++)
module_cell/read_pp.cpp:					this->chi(nb, ir) = 1.0 / (2.0 * l + 1.0) *
module_cell/read_pp.cpp:						( (l+1.0)*this->chi(ind,ir) + (l*this->chi(ind1,ir)) );
module_cell/read_pp.cpp:				for(int ir = 0; ir<this->mesh;ir++)
module_cell/read_pp.cpp:					this->chi(nb, ir) = this->chi(old_nwfc, ir);
module_cell/read_pp.cpp:			this->lchi[nb] = this->lchi[old_nwfc]; //reset lchi index
module_cell/read_pp.cpp:		this->has_so = 0;	
module_cell/read_pp.cpp:		for(int nb=0; nb<this->nbeta; nb++)
module_cell/read_pp.cpp:			int l = this->lll[nb];
module_cell/read_pp.cpp:				if(std::abs(this->jjj[nb] - this->lll[nb] + 0.5) < 1e-6)
module_cell/read_pp.cpp:					if(std::abs(this->jjj[nb+1]-this->lll[nb+1]-0.5)>1e-6) 
module_cell/read_pp.cpp:					if(std::abs(this->jjj[nb+1]-this->lll[nb+1]+0.5)>1e-6)
module_cell/read_pp.cpp:				double vion1 = ((l+1.0) * this->dion(ind,ind) + l * this->dion(ind1,ind1)) / (2.0*l+1.0);
module_cell/read_pp.cpp:				const double sqrtDplus = sqrt(std::abs(this->dion(ind,ind) / vion1));
module_cell/read_pp.cpp:				const double sqrtDminus = sqrt(std::abs(this->dion(ind1,ind1) / vion1));
module_cell/read_pp.cpp:				this->dion(ind, ind) = vion1;
module_cell/read_pp.cpp:				this->dion(ind1, ind1) = vion1;
module_cell/read_pp.cpp:				for(int ir = 0; ir<this->mesh;ir++)
module_cell/read_pp.cpp:							this->beta(ind, ir) + 
module_cell/read_pp.cpp:							this->beta(ind1, ir) ) ;
module_cell/read_pp.cpp:							this->beta(ind, ir) - 
module_cell/read_pp.cpp:							this->beta(ind1, ir) ) ;
module_cell/read_pp.cpp:					this->beta(ind, ir) = (avera + l * delta * lambda_) ;
module_cell/read_pp.cpp:					this->beta(ind1, ir) = (avera - (l + 1) * delta * lambda_); 
module_cell/read_pp.cpp:		for(int nb=0; nb<this->nwfc; nb++)
module_cell/read_pp.cpp:			int l = this->lchi[nb];
module_cell/read_pp.cpp:				if(std::abs(this->jchi[nb] - this->lchi[nb] + 0.5) < 1e-6)
module_cell/read_pp.cpp:					if(std::abs(this->jchi[nb+1]-this->lchi[nb+1]-0.5)>1e-6) 
module_cell/read_pp.cpp:					if(std::abs(this->jchi[nb+1]-this->lchi[nb+1]+0.5)>1e-6)
module_cell/read_pp.cpp:				for(int ir = 0; ir<this->mesh;ir++)
module_cell/read_pp.cpp:						( this->chi(ind,ir) + this->chi(ind1,ir) );
module_cell/read_pp.cpp:						( this->chi(ind,ir) - this->chi(ind1,ir) );
module_cell/read_pp.cpp:					this->chi(ind, ir) = avera + delta * lambda_ ; 
module_cell/read_pp.cpp:					this->chi(ind1, ir) = avera - delta * lambda_ ; 
module_cell/read_pp.cpp:	this->zp = 0;
module_cell/read_pp.cpp:		this->vloc[ir] = 0;
module_cell/read_pp.cpp:			this->dion(i,j) = 0;
module_cell/read_pp.cpp:		this->rho_at[ir] = 0;
module_cell/read_pp.cpp:                        this->setqfnew(nqf, ilast, l, 2, &qfcoef(nb, mb, l, 0), r, &qfuncl(l, nmb, 0));
module_cell/read_pp_blps.cpp:    this->nlcc = false;
module_cell/read_pp_blps.cpp:    this->tvanp = false;
module_cell/read_pp_blps.cpp:    this->has_so = false;
module_cell/read_pp_blps.cpp:    this->nbeta = 0;
module_cell/read_pp_blps.cpp:    this->kkbeta = 0;
module_cell/read_pp_blps.cpp:    this->kbeta = nullptr;
module_cell/read_pp_blps.cpp:    this->lll = nullptr;
module_cell/read_pp_blps.cpp:    this->beta.create(1, 1);
module_cell/read_pp_blps.cpp:    this->dion.create(1, 1);
module_cell/read_pp_blps.cpp:    this->nwfc = 0;
module_cell/read_pp_blps.cpp:    this->nn = new int[1];
module_cell/read_pp_blps.cpp:    this->jchi = new double[1];
module_cell/read_pp_blps.cpp:    this->jjj = new double[1];
module_cell/read_pp_blps.cpp:    ifs >> this->psd;
module_cell/read_pp_blps.cpp:    this->zp = static_cast<int>(zion);
module_cell/read_pp_blps.cpp:            this->psd = each_type;
module_cell/read_pp_blps.cpp:    ifs >> pspcod >> pspxc >> this->lmax >> lloc >> this->mesh >> r2well;
module_cell/read_pp_blps.cpp:        this->xc_func = "PZ";
module_cell/read_pp_blps.cpp:        this->xc_func = "PBE";
module_cell/read_pp_blps.cpp:    this->r = new double[mesh]; // Bohr
module_cell/read_pp_blps.cpp:    this->rab = new double[mesh];
module_cell/read_pp_blps.cpp:    this->vloc = new double[mesh]; // Hartree
module_cell/read_pp_blps.cpp:            ifs >> num >> this->r[i] >> this->vloc[i];
module_cell/read_pp_blps.cpp:            this->vloc[i] = this->vloc[i]*2; // Hartree to Ry
module_cell/read_pp_blps.cpp:            ifs >> num >> this->r[i] >> temp >> this->vloc[i];
module_cell/read_pp_blps.cpp:            this->vloc[i] = this->vloc[i]*2; // Hartree to Ry
module_cell/read_pp_blps.cpp:    this->rho_at = new double[mesh];
module_cell/read_pp_upf100.cpp:	this->has_so = false;
module_cell/read_pp_upf100.cpp:	if (this->nlcc)
module_cell/read_pp_upf100.cpp:    if (!this->coulomb_potential)
module_cell/read_pp_upf100.cpp:	ModuleBase::GlobalFunc::READ_VALUE(ifs, this->nv);// Version number
module_cell/read_pp_upf100.cpp:	ModuleBase::GlobalFunc::READ_VALUE(ifs, this->psd);// Element label
module_cell/read_pp_upf100.cpp:	ModuleBase::GlobalFunc::READ_VALUE(ifs, this->pp_type);
module_cell/read_pp_upf100.cpp:		this->tvanp = true;
module_cell/read_pp_upf100.cpp:		this->tvanp = false;
module_cell/read_pp_upf100.cpp:		this->tvanp = false;
module_cell/read_pp_upf100.cpp:		this->coulomb_potential = true;
module_cell/read_pp_upf100.cpp:		this->nlcc = true;
module_cell/read_pp_upf100.cpp:		this->nlcc = false;
module_cell/read_pp_upf100.cpp:    ModuleBase::GlobalFunc::READ_VALUE(ifs, this->zp);
module_cell/read_pp_upf100.cpp:	ModuleBase::GlobalFunc::READ_VALUE(ifs, this->etotps);
module_cell/read_pp_upf100.cpp:	ifs >> this->ecutwfc >> this->ecutrho;
module_cell/read_pp_upf100.cpp:	ModuleBase::GlobalFunc::READ_VALUE(ifs, this->lmax);
module_cell/read_pp_upf100.cpp:	ModuleBase::GlobalFunc::READ_VALUE(ifs, this->mesh);
module_cell/read_pp_upf100.cpp:	ifs >> this->nwfc >> this->nbeta ;
module_cell/read_pp_upf100.cpp:	this->els = new std::string[nwfc];
module_cell/read_pp_upf100.cpp:	this->lchi = new int[nwfc];
module_cell/read_pp_upf100.cpp:	this->oc = new double[nwfc];
module_cell/read_pp_upf100.cpp:		ifs >> els[i] >> this->lchi[i] >> this->oc[i];
module_cell/read_pp_upf100.cpp:	if (this->coulomb_potential)
module_cell/read_pp_upf100.cpp:		this->nbeta = 0;
module_cell/read_pp_upf100.cpp:        this->lmax = 0;
module_cell/read_pp_upf100.cpp:        this->lloc = 0;
module_cell/read_pp_upf100.cpp:	this->r = new double[mesh];
module_cell/read_pp_upf100.cpp:	this->rab = new double[mesh];
module_cell/read_pp_upf100.cpp:			ifs >> this->r[ir];
module_cell/read_pp_upf100.cpp:			ifs >> this->rab[ir];
module_cell/read_pp_upf100.cpp:	this->rho_atc = new double[mesh];
module_cell/read_pp_upf100.cpp:		ifs >> this->rho_atc[ir];
module_cell/read_pp_upf100.cpp:	this->vloc = new double[mesh];
module_cell/read_pp_upf100.cpp:		ifs >> this->vloc[ir];
module_cell/read_pp_upf100.cpp:        this->kbeta = nullptr;
module_cell/read_pp_upf100.cpp:        this->lll = nullptr;
module_cell/read_pp_upf100.cpp:        this->beta.create(1, 1);
module_cell/read_pp_upf100.cpp:        this->dion.create(1, 1);
module_cell/read_pp_upf100.cpp:        this->kbeta = new int[nbeta];
module_cell/read_pp_upf100.cpp:        this->lll = new int[nbeta]; 
module_cell/read_pp_upf100.cpp:		this->beta.create(nbeta , mesh);
module_cell/read_pp_upf100.cpp:		this->dion.create(nbeta , nbeta);
module_cell/read_pp_upf100.cpp:            ModuleBase::GlobalFunc::READ_VALUE(ifs, this->lll[i]);// nl_1
module_cell/read_pp_upf100.cpp:            ModuleBase::GlobalFunc::READ_VALUE(ifs, this->kbeta[i]); // nl_2
module_cell/read_pp_upf100.cpp:				ifs >> this->beta(i, ir);// nl_3
module_cell/read_pp_upf100.cpp:        ModuleBase::GlobalFunc::READ_VALUE(ifs, this->nd); // nl_4
module_cell/read_pp_upf100.cpp:        for (int i = 0; i < this->nd; i++)
module_cell/read_pp_upf100.cpp:			this->dion(mb, nb) = swap;// nl_5
module_cell/read_pp_upf100.cpp:			this->dion(nb, mb) = swap;
module_cell/read_pp_upf100.cpp:	this->chi.create(this->nwfc, this->mesh);
module_cell/read_pp_upf100.cpp:			ifs >> this->chi(i, ir);
module_cell/read_pp_upf100.cpp:	this->rho_at = new double[mesh];
module_cell/read_pp_upf100.cpp:		ifs >> this->rho_at[ir];
module_cell/read_pp_upf100.cpp:       if(!this->has_so) return;
module_cell/read_pp_upf100.cpp:       this->nn = new int[nwfc];
module_cell/read_pp_upf100.cpp:       this->jchi = new double[nwfc];
module_cell/read_pp_upf100.cpp:       this->jjj = new double[nbeta];
module_cell/read_pp_upf100.cpp:             ifs >> this->els[nw] >>this->nn[nw] >> this->lchi[nw] >> this->jchi[nw] >> this->oc[nw];
module_cell/read_pp_upf100.cpp:             if(this->lchi[nw]-this->jchi[nw]-0.5>1e-7 && this->lchi[nw]-this->jchi[nw]-0.5<1e-7)
module_cell/read_pp_upf100.cpp:                  this->has_so = 0;
module_cell/read_pp_upf100.cpp:             ifs >> this->lll[nb] >> this->jjj[nb];
module_cell/read_pp_upf100.cpp:             if(this->lll[nb]-this->jjj[nb]-0.5>1e-7 && this->lll[nb]-this->jjj[nb]-0.5<1e-7)
module_cell/read_pp_upf100.cpp:                  this->has_so = 0;
module_cell/read_pp_upf201.cpp:    this->read_pseudo_upf201_header(ifs);
module_cell/read_pp_upf201.cpp:    this->read_pseudo_upf201_mesh(ifs);
module_cell/read_pp_upf201.cpp:    if (this->nlcc)
module_cell/read_pp_upf201.cpp:        this->rho_atc = new double[mesh];
module_cell/read_pp_upf201.cpp:            ifs >> this->rho_atc[ir];
module_cell/read_pp_upf201.cpp:    if (!this->coulomb_potential)
module_cell/read_pp_upf201.cpp:        this->vloc = new double[mesh];
module_cell/read_pp_upf201.cpp:            ifs >> this->vloc[ir];
module_cell/read_pp_upf201.cpp:    this->read_pseudo_upf201_nonlocal(ifs);
module_cell/read_pp_upf201.cpp:    this->read_pseudo_upf201_pswfc(ifs);
module_cell/read_pp_upf201.cpp:    //     this->read_pseudo_upf201_fullwfc(ifs);
module_cell/read_pp_upf201.cpp:    this->rho_at = new double[mesh];
module_cell/read_pp_upf201.cpp:        ifs >> this->rho_at[ir];
module_cell/read_pp_upf201.cpp:        this->read_pseudo_upf201_so(ifs);
module_cell/read_pp_upf201.cpp:    this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_upf201.cpp:                this->coulomb_potential = true;
module_cell/read_pp_upf201.cpp:    if (this->coulomb_potential)
module_cell/read_pp_upf201.cpp:        this->nbeta = 0;
module_cell/read_pp_upf201.cpp:        this->lmax = 0;
module_cell/read_pp_upf201.cpp:        this->lloc = 0;
module_cell/read_pp_upf201.cpp:        this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_upf201.cpp:    this->r = new double[mesh];
module_cell/read_pp_upf201.cpp:    this->rab = new double[mesh];
module_cell/read_pp_upf201.cpp:        ifs >> this->r[ir];
module_cell/read_pp_upf201.cpp:        ifs >> this->rab[ir];
module_cell/read_pp_upf201.cpp:    this->kbeta = new int[nbeta];
module_cell/read_pp_upf201.cpp:    this->lll = new int[nbeta];
module_cell/read_pp_upf201.cpp:    this->els_beta = new std::string[nbeta];
module_cell/read_pp_upf201.cpp:    this->rcut = new double[nbeta];
module_cell/read_pp_upf201.cpp:    this->rcutus = new double[nbeta];
module_cell/read_pp_upf201.cpp:    this->beta.create(nbeta, mesh);
module_cell/read_pp_upf201.cpp:    this->dion.create(nbeta, nbeta);
module_cell/read_pp_upf201.cpp:        this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_upf201.cpp:            ifs >> this->beta(ib, ir);
module_cell/read_pp_upf201.cpp:    this->nd = nbeta * nbeta;
module_cell/read_pp_upf201.cpp:        this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_upf201.cpp:        this->qqq.create(nbeta, nbeta);
module_cell/read_pp_upf201.cpp:        this->rinner = new double[nqlc];
module_cell/read_pp_upf201.cpp:            this->qfcoef.create(1, 1, 1, 1);
module_cell/read_pp_upf201.cpp:            this->qfcoef.create(nbeta, nbeta, nqlc, nqf);
module_cell/read_pp_upf201.cpp:            this->qfuncl.create(2 * lmax + 1, nbeta * (nbeta + 1) / 2, mesh);
module_cell/read_pp_upf201.cpp:            this->qfunc.create(nbeta * (nbeta + 1) / 2, mesh);
module_cell/read_pp_upf201.cpp:    this->els = new std::string[nwfc];
module_cell/read_pp_upf201.cpp:    this->lchi = new int[nwfc];
module_cell/read_pp_upf201.cpp:    this->nchi = new int[nwfc];
module_cell/read_pp_upf201.cpp:    this->oc = new double[nwfc];
module_cell/read_pp_upf201.cpp:    this->epseu = new double[nwfc];
module_cell/read_pp_upf201.cpp:    this->rcut_chi = new double[nwfc];
module_cell/read_pp_upf201.cpp:    this->rcutus_chi = new double[nwfc];
module_cell/read_pp_upf201.cpp:    this->chi.create(this->nwfc, this->mesh);
module_cell/read_pp_upf201.cpp:        this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_upf201.cpp:            ifs >> this->chi(iw, ir);
module_cell/read_pp_upf201.cpp:    this->aewfc.create(this->nbeta, this->mesh);
module_cell/read_pp_upf201.cpp:    this->pswfc.create(this->nbeta, this->mesh);
module_cell/read_pp_upf201.cpp:    this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_upf201.cpp:            ifs >> this->aewfc(ib, ir);
module_cell/read_pp_upf201.cpp:            ifs >> this->pswfc(ib, ir);
module_cell/read_pp_upf201.cpp:    delete[] this->jchi;
module_cell/read_pp_upf201.cpp:    delete[] this->jjj;
module_cell/read_pp_upf201.cpp:    delete[] this->nn;
module_cell/read_pp_upf201.cpp:    this->jchi = new double[nwfc];
module_cell/read_pp_upf201.cpp:    this->jjj = new double[nbeta];
module_cell/read_pp_upf201.cpp:    this->nn = new int[nwfc];
module_cell/read_pp_upf201.cpp:        this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_upf201.cpp:        this->getnameval(ifs, nparameter, name, val);
module_cell/read_pp_vwr.cpp:	this->xc_func="PZ";
module_cell/read_pp_vwr.cpp:	this->pp_type="NC";
module_cell/read_pp_vwr.cpp:    this->tvanp = false;
module_cell/read_pp_vwr.cpp:	this->nwfc = 0;
module_cell/read_pp_vwr.cpp:	delete[] this->oc;
module_cell/read_pp_vwr.cpp:	this->oc = new double[nwfc];
module_cell/read_pp_vwr.cpp:	this->r = new double[mesh];
module_cell/read_pp_vwr.cpp:	this->rab = new double[mesh];
module_cell/read_pp_vwr.cpp:	this->vloc = new double[mesh];
module_cell/read_pp_vwr.cpp:	this->chi.create(nwfc,mesh);
module_cell/read_pp_vwr.cpp:	this->nbeta = 0;
module_cell/read_pp_vwr.cpp:	this->nd = this->nbeta;
module_cell/setup_nonlocal.cpp:    this->Beta = new Numerical_Nonlocal[1];
module_cell/setup_nonlocal.cpp:	this->nproj = nullptr;
module_cell/setup_nonlocal.cpp:    this->nprojmax = 0;
module_cell/setup_nonlocal.cpp:    this->rcutmax_Beta = 0.0;
module_cell/setup_nonlocal.cpp:		this->Beta[it].set_type_info(
module_cell/setup_nonlocal.cpp://		std::cout << this->kmesh << std::endl;
module_cell/setup_nonlocal.cpp:	this->Beta[it].set_type_info(
module_cell/setup_nonlocal.cpp:		delete[] this->Beta;
module_cell/setup_nonlocal.cpp:		this->Beta = new Numerical_Nonlocal[ntype];
module_cell/setup_nonlocal.cpp:		delete[] this->nproj;
module_cell/setup_nonlocal.cpp:		this->nproj = new int[ntype];
module_cell/setup_nonlocal.cpp:		ModuleBase::GlobalFunc::ZEROS(this->nproj, ntype);
module_cell/setup_nonlocal.cpp:		this->nprojmax = 0;
module_cell/setup_nonlocal.cpp:				this->Read_NonLocal(
module_cell/setup_nonlocal.cpp:					this->nproj[it], 
module_cell/setup_nonlocal.cpp:				this->Set_NonLocal(
module_cell/setup_nonlocal.cpp:					this->nproj[it],
module_cell/setup_nonlocal.cpp:			this->nprojmax = std::max(this->nprojmax, this->nproj[it]);
module_cell/setup_nonlocal.cpp:			this->rcutmax_Beta = std::max(this->rcutmax_Beta, this->Beta[it].get_rcut_max());
module_cell/setup_nonlocal.cpp:		log << " max number of nonlocal projetors among all species is " << this->nprojmax << std::endl; 
module_cell/test/prepare_unitcell.h:		this->ntype = this->elements.size();
module_cell/test/prepare_unitcell.h:		ucell->setup(this->latname,
module_cell/test/prepare_unitcell.h:				this->ntype,
module_cell/test/prepare_unitcell.h:				this->lmaxmax,
module_cell/test/prepare_unitcell.h:				this->init_vel,
module_cell/test/prepare_unitcell.h:				this->fixed_axes);
module_cell/test/prepare_unitcell.h:			ucell->atom_label[it] = this->elements[it];
module_cell/test/prepare_unitcell.h:			ucell->atom_mass[it] = this->atomic_mass[it];
module_cell/test/prepare_unitcell.h:			ucell->pseudo_fn[it] = this->pp_files[it];
module_cell/test/prepare_unitcell.h:			ucell->pseudo_type[it] = this->pp_types[it];
module_cell/test/prepare_unitcell.h:			ucell->orbital_fn[it] = this->orb_files[it];
module_cell/test/prepare_unitcell.h:		ucell->lat0 = this->lat0;
module_cell/test/prepare_unitcell.h:		ucell->latvec.e11 = this->latvec[0];
module_cell/test/prepare_unitcell.h:		ucell->latvec.e12 = this->latvec[1];
module_cell/test/prepare_unitcell.h:		ucell->latvec.e13 = this->latvec[2];
module_cell/test/prepare_unitcell.h:		ucell->latvec.e21 = this->latvec[3];
module_cell/test/prepare_unitcell.h:		ucell->latvec.e22 = this->latvec[4];
module_cell/test/prepare_unitcell.h:	       	ucell->latvec.e23 = this->latvec[5];
module_cell/test/prepare_unitcell.h:		ucell->latvec.e31 = this->latvec[6];
module_cell/test/prepare_unitcell.h:		ucell->latvec.e32 = this->latvec[7];
module_cell/test/prepare_unitcell.h:		ucell->latvec.e33 = this->latvec[8];
module_cell/test/prepare_unitcell.h:		ucell->Coordinate = this->coor_type;
module_cell/test/prepare_unitcell.h:		this->atomic_index = 0;
module_cell/test/prepare_unitcell.h:			ucell->atoms[it].label = this->elements[it];
module_cell/test/prepare_unitcell.h:			ucell->atoms[it].na = this->natom[it];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].x = this->coordinates[this->atomic_index*3+0];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].y = this->coordinates[this->atomic_index*3+1];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].z = this->coordinates[this->atomic_index*3+2];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].x = this->coordinates[this->atomic_index*3+0];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].y = this->coordinates[this->atomic_index*3+1];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].z = this->coordinates[this->atomic_index*3+2];
module_cell/test/prepare_unitcell.h:				if(this->init_vel)
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].x = this->velocity[this->atomic_index*3+0];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].y = this->velocity[this->atomic_index*3+1];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].z = this->velocity[this->atomic_index*3+2];
module_cell/test/prepare_unitcell.h:				if(this->selective_dynamics)
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].x = this->mbl[this->atomic_index*3+0];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].y = this->mbl[this->atomic_index*3+1];
module_cell/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].z = this->mbl[this->atomic_index*3+2];
module_cell/test/prepare_unitcell.h:				++(this->atomic_index);
module_cell/test/prepare_unitcell.h:		ucell->nat = this->natom.sum();
module_cell/test/unitcell_test.cpp:	this->tot_magnetization = 0.0;
module_cell/test/unitcell_test.cpp:	this->abs_magnetization = 0.0;
module_cell/test/unitcell_test.cpp:	this->start_magnetization = nullptr;
module_cell/test/unitcell_test.cpp:	delete[] this->start_magnetization;
module_cell/test/unitcell_test_para.cpp:	this->tot_magnetization = 0.0;
module_cell/test/unitcell_test_para.cpp:	this->abs_magnetization = 0.0;
module_cell/test/unitcell_test_para.cpp:	this->start_magnetization = nullptr;
module_cell/test/unitcell_test_para.cpp:	delete[] this->start_magnetization;
module_cell/test/unitcell_test_readpp.cpp:	this->tot_magnetization = 0.0;
module_cell/test/unitcell_test_readpp.cpp:	this->abs_magnetization = 0.0;
module_cell/test/unitcell_test_readpp.cpp:	this->start_magnetization = nullptr;
module_cell/test/unitcell_test_readpp.cpp:	delete[] this->start_magnetization;
module_cell/test/unitcell_test_setupcell.cpp:	this->tot_magnetization = 0.0;
module_cell/test/unitcell_test_setupcell.cpp:	this->abs_magnetization = 0.0;
module_cell/test/unitcell_test_setupcell.cpp:	this->start_magnetization = nullptr;
module_cell/test/unitcell_test_setupcell.cpp:	delete[] this->start_magnetization;
module_cell/test_pw/unitcell_test_pw.cpp:	this->tot_magnetization = 0.0;
module_cell/test_pw/unitcell_test_pw.cpp:	this->abs_magnetization = 0.0;
module_cell/test_pw/unitcell_test_pw.cpp:	this->start_magnetization = nullptr;
module_cell/test_pw/unitcell_test_pw.cpp:	delete[] this->start_magnetization;
module_cell/unitcell.cpp:    this->iat2it = new int[nat];
module_cell/unitcell.cpp:    this->iat2ia = new int[nat];
module_cell/unitcell.cpp:            this->iat2it[iat] = it;
module_cell/unitcell.cpp:            this->iat2ia[iat] = ia;
module_cell/unitcell.cpp:	for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:		atomCounts.insert(std::pair<int, int>(it, this->atoms[it].na));
module_cell/unitcell.cpp:	for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:		orbitalCounts.insert(std::pair<int, int>(it, this->atoms[it].nw));
module_cell/unitcell.cpp:    for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:        for (int L = 0; L < this->atoms[it].nwl + 1; L++)
module_cell/unitcell.cpp:            int l_nchi = this->atoms[it].l_nchi[L];
module_cell/unitcell.cpp:    for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:        Atom* atom = &this->atoms[it];
module_cell/unitcell.cpp:                    atom->dis[ia][ik] = pos[3 * iat + ik] / this->lat0 - atom->tau[ia][ik];
module_cell/unitcell.cpp:                    atom->tau[ia][ik] = pos[3 * iat + ik] / this->lat0;
module_cell/unitcell.cpp:            atom->dis[ia] = atom->dis[ia] * this->GT;
module_cell/unitcell.cpp:            atom->taud[ia] = atom->tau[ia] * this->GT;
module_cell/unitcell.cpp:    assert(iat == this->nat);
module_cell/unitcell.cpp:    this->periodic_boundary_adjustment();
module_cell/unitcell.cpp:    this->bcast_atoms_tau();
module_cell/unitcell.cpp:    for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:        Atom* atom = &this->atoms[it];
module_cell/unitcell.cpp:    assert(iat == this->nat);
module_cell/unitcell.cpp:    this->periodic_boundary_adjustment();
module_cell/unitcell.cpp:    this->bcast_atoms_tau();
module_cell/unitcell.cpp:    for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:        Atom* atom = &this->atoms[it];
module_cell/unitcell.cpp:    assert(iat == this->nat);
module_cell/unitcell.cpp:    this->periodic_boundary_adjustment();
module_cell/unitcell.cpp:    this->bcast_atoms_tau();
module_cell/unitcell.cpp:    for (int it = 0; it < this->ntype; ++it)
module_cell/unitcell.cpp:        Atom* atom = &this->atoms[it];
module_cell/unitcell.cpp:            this->atoms[it].vel[ia] = vel_in[iat];
module_cell/unitcell.cpp:    assert(iat == this->nat);
module_cell/unitcell.cpp:    for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:        Atom* atom = &this->atoms[it];
module_cell/unitcell.cpp:            atom->tau[ia] = atom->taud[ia] * this->latvec;
module_cell/unitcell.cpp:	magnet.start_magnetization = new double[this->ntype];
module_cell/unitcell.cpp:	this->atoms = new Atom[this->ntype]; // atom species.
module_cell/unitcell.cpp:	this->set_atom_flag = true;
module_cell/unitcell.cpp:			const int error = this->read_atom_species(ifa, log);
module_cell/unitcell.cpp:			ok2 = this->read_atom_positions(ifa, log, GlobalV::ofs_warning);
module_cell/unitcell.cpp:	this->bcast_unitcell();
module_cell/unitcell.cpp:		for(int it = 0;it<this->ntype; it++)
module_cell/unitcell.cpp:			for(int ia = 0; ia<this->atoms[it].na; ia++)
module_cell/unitcell.cpp:				GlobalV::nupdown += this->atoms[it].mag[ia];
module_cell/unitcell.cpp:	this->omega = std::abs( latvec.Det() ) * this->lat0 * lat0 * lat0 ;
module_cell/unitcell.cpp:	if(this->omega<=0)
module_cell/unitcell.cpp:		std::cout << "The volume is negative: " << this->omega<<std::endl;
module_cell/unitcell.cpp:		ModuleBase::GlobalFunc::OUT(log,"Volume (Bohr^3)", this->omega);
module_cell/unitcell.cpp:		ModuleBase::GlobalFunc::OUT(log,"Volume (A^3)", this->omega * pow(ModuleBase::BOHR_TO_A, 3));
module_cell/unitcell.cpp:	this->GT = latvec.Inverse();
module_cell/unitcell.cpp:	this->G  = GT.Transpose();
module_cell/unitcell.cpp:	this->GGT = G * GT;
module_cell/unitcell.cpp:	this->invGGT = GGT.Inverse();
module_cell/unitcell.cpp:    this->GT0 = latvec.Inverse();
module_cell/unitcell.cpp:    this->G0  = GT.Transpose();
module_cell/unitcell.cpp:    this->GGT0 = G * GT;
module_cell/unitcell.cpp:    this->invGGT0 = GGT.Inverse();
module_cell/unitcell.cpp:    this->set_iat2itia();
module_cell/unitcell.cpp:        for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:            for(int i=0;i<this->ntype;i++)
module_cell/unitcell.cpp:            	ModuleBase::Global_File::make_dir_atom( this->atoms[i].label );
module_cell/unitcell.cpp:		this->atoms[it].set_index();
module_cell/unitcell.cpp:	this->namax = 0;
module_cell/unitcell.cpp:	this->nwmax = 0;
module_cell/unitcell.cpp:		this->namax = std::max( atoms[it].na, namax );
module_cell/unitcell.cpp:		this->nwmax = std::max( atoms[it].nw, nwmax );
module_cell/unitcell.cpp:	this->iwt2iat = new int[GlobalV::NLOCAL];
module_cell/unitcell.cpp:	this->iwt2iw = new int[GlobalV::NLOCAL];
module_cell/unitcell.cpp:	this->itia2iat.create(ntype, namax);
module_cell/unitcell.cpp:	//this->itiaiw2iwt.create(ntype, namax, nwmax*GlobalV::NPOL);
module_cell/unitcell.cpp:	this->set_iat2iwt(GlobalV::NPOL);
module_cell/unitcell.cpp:			this->itia2iat(it, ia) = iat;
module_cell/unitcell.cpp:			//this->iat2ia[iat] = ia;
module_cell/unitcell.cpp:				//this->itiaiw2iwt(it, ia, iw) = iwt;
module_cell/unitcell.cpp:				this->iwt2iat[iwt] = iat;
module_cell/unitcell.cpp:				this->iwt2iw[iwt] = iw;
module_cell/unitcell.cpp:	this->lmax = 0;	
module_cell/unitcell.cpp:	this->nmax = 0;
module_cell/unitcell.cpp:		this->nmax_total = std::max(nmax_total, nchi);
module_cell/unitcell.cpp:	this->lmax_ppwf = 0;
module_cell/unitcell.cpp:				this->lmax_ppwf = atoms[it].ncpp.lchi[ic]; 
module_cell/unitcell.cpp:	assert(this->nat > 0);
module_cell/unitcell.cpp:	assert(this->ntype > 0);
module_cell/unitcell.cpp:	this->iat2iwt.resize(this->nat);
module_cell/unitcell.cpp:	this->npol = npol_in;
module_cell/unitcell.cpp:	for(int it = 0;it < this->ntype; it++)
module_cell/unitcell.cpp:			this->iat2iwt[iat] = iwt;
module_cell/unitcell.cpp:			iwt += atoms[it].nw * this->npol;
module_cell/unitcell.cpp:	this->meshx = 0;
module_cell/unitcell.cpp:	for (int it = 0;it < this->ntype;it++)
module_cell/unitcell.cpp:		const int mesh = this->atoms[it].ncpp.msh;
module_cell/unitcell.cpp:		if (mesh > this->meshx)
module_cell/unitcell.cpp:			this->meshx = mesh;
module_cell/unitcell.cpp:	this->natomwfc = 0;
module_cell/unitcell.cpp:    this->omega = std::abs(latvec.Det()) * this->lat0 * lat0 * lat0;
module_cell/unitcell.cpp:    if(this->omega <= 0)
module_cell/unitcell.cpp:        ModuleBase::GlobalFunc::OUT(log, "Volume (Bohr^3)", this->omega);
module_cell/unitcell.cpp:        ModuleBase::GlobalFunc::OUT(log, "Volume (A^3)", this->omega * pow(ModuleBase::BOHR_TO_A, 3));
module_cell/unitcell.cpp:    this->GT = latvec.Inverse();
module_cell/unitcell.cpp:    this->G  = GT.Transpose();
module_cell/unitcell.cpp:    this->GGT = G * GT;
module_cell/unitcell.cpp:    this->invGGT = GGT.Inverse();
module_cell/unitcell.cpp:    this->bcast_unitcell();
module_cell/unitcell.cpp:	for(int it=0; it<this->ntype; it++)
module_cell/unitcell.cpp:	if(this->lc[0]||this->lc[1]||this->lc[2])
module_cell/unitcell.cpp:	this->latName = latname_in;
module_cell/unitcell.cpp:	this->ntype = ntype_in;
module_cell/unitcell.cpp:	this->lmaxmax = lmaxmax_in;
module_cell/unitcell.cpp:	this->init_vel = init_vel_in;
module_cell/unitcell.cpp:		this->lc[0] = 1;
module_cell/unitcell.cpp:		this->lc[1] = 1;
module_cell/unitcell.cpp:		this->lc[2] = 1;
module_cell/unitcell.cpp:		this->lc[0] = 1;
module_cell/unitcell.cpp:		this->lc[1] = 1;
module_cell/unitcell.cpp:		this->lc[2] = 1;
module_cell/unitcell.cpp:		this->lc[0] = 1;
module_cell/unitcell.cpp:		this->lc[1] = 1;
module_cell/unitcell.cpp:		this->lc[2] = 1;
module_cell/unitcell.cpp:		this->lc[0] = 0;
module_cell/unitcell.cpp:		this->lc[1] = 1;
module_cell/unitcell.cpp:		this->lc[2] = 1;
module_cell/unitcell.cpp:		this->lc[0] = 1;
module_cell/unitcell.cpp:		this->lc[1] = 0;
module_cell/unitcell.cpp:		this->lc[2] = 1;
module_cell/unitcell.cpp:		this->lc[0] = 1;
module_cell/unitcell.cpp:		this->lc[1] = 1;
module_cell/unitcell.cpp:		this->lc[2] = 0;
module_cell/unitcell.cpp:		this->lc[0] = 0;
module_cell/unitcell.cpp:		this->lc[1] = 0;
module_cell/unitcell.cpp:		this->lc[2] = 1;
module_cell/unitcell.cpp:		this->lc[0] = 0;
module_cell/unitcell.cpp:		this->lc[1] = 1;
module_cell/unitcell.cpp:		this->lc[2] = 0;
module_cell/unitcell.cpp:		this->lc[0] = 1;
module_cell/unitcell.cpp:		this->lc[1] = 0;
module_cell/unitcell.cpp:		this->lc[2] = 0;
module_cell/unitcell.cpp:		this->lc[0] = 0;
module_cell/unitcell.cpp:		this->lc[1] = 0;
module_cell/unitcell.cpp:		this->lc[2] = 0;
module_cell/unitcell.cpp:		std::string symbol1 = this->atoms[it1].ncpp.psd;
module_cell/unitcell.cpp:		for (int ia1 =0;ia1 <this->atoms[it1].na;ia1++)
module_cell/unitcell.cpp:			double x1 = this->atoms[it1].taud[ia1].x;
module_cell/unitcell.cpp:			double y1 = this->atoms[it1].taud[ia1].y;
module_cell/unitcell.cpp:			double z1 = this->atoms[it1].taud[ia1].z;
module_cell/unitcell.cpp:				std::string symbol2 = this->atoms[it2].ncpp.psd;
module_cell/unitcell.cpp:				for (int ia2 =0;ia2 <this->atoms[it2].na;ia2++)
module_cell/unitcell.cpp:								double x2 = this->atoms[it2].taud[ia2].x + a;
module_cell/unitcell.cpp:								double y2 = this->atoms[it2].taud[ia2].y + b;
module_cell/unitcell.cpp:								double z2 = this->atoms[it2].taud[ia2].z + c;
module_cell/unitcell.cpp:								double bond_length = sqrt(pow((x2-x1)*this->a1.x + (y2-y1)*this->a2.x + (z2-z1)*this->a3.x,2) + 
module_cell/unitcell.cpp:														  pow((x2-x1)*this->a1.y + (y2-y1)*this->a2.y + (z2-z1)*this->a3.y,2) +
module_cell/unitcell.cpp:														  pow((x2-x1)*this->a1.z + (y2-y1)*this->a2.z + (z2-z1)*this->a3.z,2) ) * this->lat0;
module_cell/unitcell.cpp:									errorlog << std::setw(3) << ia1+1 << "-th " << std::setw(3) << this->atoms[it1].label << ", "; 
module_cell/unitcell.cpp:									errorlog << std::setw(3) << ia2+1 << "-th " << std::setw(3) << this->atoms[it2].label;
module_cell/unitcell.cpp:			for(int it = 0; it < this->ntype; it ++)
module_cell/unitcell.cpp:				const int nelec_it = GlobalC::paw_cell.get_val(it) * this->atoms[it].na;
module_cell/unitcell.cpp:			for (int it = 0; it < this->ntype; it++)
module_cell/unitcell.cpp:				ss1 << "electron number of element " << this->atoms[it].label;
module_cell/unitcell.cpp:				const int nelec_it = this->atoms[it].ncpp.zv * this->atoms[it].na;
module_cell/unitcell.cpp:				ss2 << "total electron number of element " << this->atoms[it].label;
module_cell/unitcell.cpp:				ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, ss1.str(), this->atoms[it].ncpp.zv);
module_cell/unitcell.h:        return Tiait(this->iat2iwt[this->itia2iat(it, ia)] + iw);
module_elecstate/elecstate.cpp:    // hamilt::MatrixBlock<double> temp{&(this->charge->rho[spin][0]), 1, this->charge->nrxx}; //
module_elecstate/elecstate.cpp:    // this->chr->get_nspin(), this->chr->get_nrxx()};
module_elecstate/elecstate.cpp:    return &(this->charge->rho[spin][0]);
module_elecstate/elecstate.cpp:    num = this->klist->nks * GlobalV::NBANDS;
module_elecstate/elecstate.cpp:    for (int ik = 0; ik < this->wg.nr; ik++)
module_elecstate/elecstate.cpp:        for (int ib = 0; ib < this->wg.nc; ib++)
module_elecstate/elecstate.cpp:            this->wg(ik, ib) = ocp_kb[ik * this->wg.nc + ib];
module_elecstate/elecstate.cpp:    this->skip_weights = true;
module_elecstate/elecstate.cpp:    this->nelec_spin.resize(GlobalV::NSPIN);
module_elecstate/elecstate.cpp:        this->nelec_spin[0] = (GlobalV::nelec + GlobalV::nupdown) / 2.0;
module_elecstate/elecstate.cpp:        this->nelec_spin[1] = (GlobalV::nelec - GlobalV::nupdown) / 2.0;
module_elecstate/elecstate.cpp:    if (this->skip_weights)
module_elecstate/elecstate.cpp:    int nbands = this->ekb.nc;
module_elecstate/elecstate.cpp:    int nks = this->ekb.nr;
module_elecstate/elecstate.cpp:                             this->klist->wk,
module_elecstate/elecstate.cpp:                             this->nelec_spin[0],
module_elecstate/elecstate.cpp:                             this->ekb,
module_elecstate/elecstate.cpp:                             this->eferm.ef_up,
module_elecstate/elecstate.cpp:                             this->wg,
module_elecstate/elecstate.cpp:                             this->klist->isk);
module_elecstate/elecstate.cpp:                             this->klist->wk,
module_elecstate/elecstate.cpp:                             this->nelec_spin[1],
module_elecstate/elecstate.cpp:                             this->ekb,
module_elecstate/elecstate.cpp:                             this->eferm.ef_dw,
module_elecstate/elecstate.cpp:                             this->wg,
module_elecstate/elecstate.cpp:                             this->klist->isk);
module_elecstate/elecstate.cpp:                             this->klist->wk,
module_elecstate/elecstate.cpp:                             this->ekb,
module_elecstate/elecstate.cpp:                             this->eferm.ef,
module_elecstate/elecstate.cpp:                             this->wg,
module_elecstate/elecstate.cpp:                             this->klist->isk);
module_elecstate/elecstate.cpp:                             this->klist->wk,
module_elecstate/elecstate.cpp:                             this->nelec_spin[0],
module_elecstate/elecstate.cpp:                             this->ekb,
module_elecstate/elecstate.cpp:                             this->eferm.ef_up,
module_elecstate/elecstate.cpp:                             this->wg,
module_elecstate/elecstate.cpp:                             this->klist->isk);
module_elecstate/elecstate.cpp:                             this->klist->wk,
module_elecstate/elecstate.cpp:                             this->nelec_spin[1],
module_elecstate/elecstate.cpp:                             this->ekb,
module_elecstate/elecstate.cpp:                             this->eferm.ef_dw,
module_elecstate/elecstate.cpp:                             this->wg,
module_elecstate/elecstate.cpp:                             this->klist->isk);
module_elecstate/elecstate.cpp:            this->f_en.demet = demet_up + demet_dw;
module_elecstate/elecstate.cpp:                             this->klist->wk,
module_elecstate/elecstate.cpp:                             this->ekb,
module_elecstate/elecstate.cpp:                             this->eferm.ef,
module_elecstate/elecstate.cpp:                             this->f_en.demet,
module_elecstate/elecstate.cpp:                             this->wg,
module_elecstate/elecstate.cpp:                             this->klist->isk);
module_elecstate/elecstate.cpp:        Parallel_Reduce::reduce_double_allpool(this->f_en.demet);
module_elecstate/elecstate.cpp:    for (int ik = 0; ik < this->ekb.nr; ++ik)
module_elecstate/elecstate.cpp:        for (int ibnd = 0; ibnd < this->ekb.nc; ibnd++)
module_elecstate/elecstate.cpp:            eband += this->ekb(ik, ibnd) * this->wg(ik, ibnd);
module_elecstate/elecstate.cpp:    this->f_en.eband = eband;
module_elecstate/elecstate.cpp:        this->f_en.eband /= GlobalV::NPROC_IN_POOL;
module_elecstate/elecstate.cpp:        Parallel_Reduce::reduce_all(this->f_en.eband);
module_elecstate/elecstate.cpp:        this->charge->set_rho_core(strucfac);
module_elecstate/elecstate.cpp:        this->charge->set_rho_core_paw();
module_elecstate/elecstate.cpp:        this->charge->init_rho(this->eferm, strucfac, this->bigpw->nbz, this->bigpw->bz);
module_elecstate/elecstate.cpp:        this->charge->check_rho(); // check the rho
module_elecstate/elecstate.cpp:    this->charge->renormalize_rho();
module_elecstate/elecstate.cpp:    this->pot->init_pot(istep, this->charge);
module_elecstate/elecstate.cpp:    this->charge = chg_in;
module_elecstate/elecstate.cpp:    this->klist = klist_in;
module_elecstate/elecstate.cpp:    this->charge->set_rhopw(rhopw_in);
module_elecstate/elecstate.cpp:    this->bigpw = bigpw_in;
module_elecstate/elecstate.cpp:    this->init_nelec_spin();
module_elecstate/elecstate.cpp:    this->cal_nbands();
module_elecstate/elecstate.cpp:    this->ekb.create(nk_in, GlobalV::NBANDS);
module_elecstate/elecstate.cpp:    this->wg.create(nk_in, GlobalV::NBANDS);
module_elecstate/elecstate.cpp:    // std::cout << "nbands(this-> = " <<GlobalV::NBANDS <<std::endl;
module_elecstate/elecstate.cpp:            const double max_occ = std::max(this->nelec_spin[0], this->nelec_spin[1]);
module_elecstate/elecstate.cpp:            if (GlobalV::NBANDS < this->nelec_spin[0])
module_elecstate/elecstate.cpp:                ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, "nelec_up", this->nelec_spin[0]);
module_elecstate/elecstate.cpp:            if (GlobalV::NBANDS < this->nelec_spin[1])
module_elecstate/elecstate.cpp:                ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, "nelec_down", this->nelec_spin[1]);
module_elecstate/elecstate.h:        this->charge = charge_in;
module_elecstate/elecstate.h:        this->charge->set_rhopw(rhopw_in);
module_elecstate/elecstate.h:        this->bigpw = bigpw_in;
module_elecstate/elecstate.h:        this->eferm.two_efermi = GlobalV::TWO_EFERMI;
module_elecstate/elecstate.h:        if(this->pot != nullptr) 
module_elecstate/elecstate.h:            delete this->pot;
module_elecstate/elecstate.h:            this->pot = nullptr;
module_elecstate/elecstate_energy.cpp:    if (this->ekb.nr == 0 || this->ekb.nc == 0)
module_elecstate/elecstate_energy.cpp:        this->bandgap = 0.0;
module_elecstate/elecstate_energy.cpp:    int nks = this->klist->nks;
module_elecstate/elecstate_energy.cpp:    double homo = this->ekb(0, 0);
module_elecstate/elecstate_energy.cpp:    double lumo = this->ekb(0, nbands - 1);
module_elecstate/elecstate_energy.cpp:            if (!(this->ekb(ik, ib) - this->eferm.ef > 1e-5) && homo < this->ekb(ik, ib))
module_elecstate/elecstate_energy.cpp:                homo = this->ekb(ik, ib);
module_elecstate/elecstate_energy.cpp:            if (this->ekb(ik, ib) - this->eferm.ef > 1e-5 && lumo > this->ekb(ik, ib))
module_elecstate/elecstate_energy.cpp:                lumo = this->ekb(ik, ib);
module_elecstate/elecstate_energy.cpp:    this->bandgap = lumo - homo;
module_elecstate/elecstate_energy.cpp:    if (this->ekb.nr == 0 || this->ekb.nc == 0)
module_elecstate/elecstate_energy.cpp:        this->bandgap_up = 0.0;
module_elecstate/elecstate_energy.cpp:        this->bandgap_dw = 0.0;
module_elecstate/elecstate_energy.cpp:    int nks = this->klist->nks;
module_elecstate/elecstate_energy.cpp:    double homo_up = this->ekb(0, 0);
module_elecstate/elecstate_energy.cpp:    double lumo_up = this->ekb(0, nbands - 1);
module_elecstate/elecstate_energy.cpp:    double homo_dw = this->ekb(0, 0);
module_elecstate/elecstate_energy.cpp:    double lumo_dw = this->ekb(0, nbands - 1);
module_elecstate/elecstate_energy.cpp:            if (this->klist->isk[ik] == 0)
module_elecstate/elecstate_energy.cpp:                if (!(this->ekb(ik, ib) - this->eferm.ef_up > 1e-5) && homo_up < this->ekb(ik, ib))
module_elecstate/elecstate_energy.cpp:                    homo_up = this->ekb(ik, ib);
module_elecstate/elecstate_energy.cpp:                if (this->ekb(ik, ib) - this->eferm.ef_up > 1e-5 && lumo_up > this->ekb(ik, ib))
module_elecstate/elecstate_energy.cpp:                    lumo_up = this->ekb(ik, ib);
module_elecstate/elecstate_energy.cpp:            if (this->klist->isk[ik] == 1)
module_elecstate/elecstate_energy.cpp:                if (!(this->ekb(ik, ib) - this->eferm.ef_dw > 1e-5) && homo_dw < this->ekb(ik, ib))
module_elecstate/elecstate_energy.cpp:                    homo_dw = this->ekb(ik, ib);
module_elecstate/elecstate_energy.cpp:                if (this->ekb(ik, ib) - this->eferm.ef_dw > 1e-5 && lumo_dw > this->ekb(ik, ib))
module_elecstate/elecstate_energy.cpp:                    lumo_dw = this->ekb(ik, ib);
module_elecstate/elecstate_energy.cpp:    this->bandgap_up = lumo_up - homo_up;
module_elecstate/elecstate_energy.cpp:    this->bandgap_dw = lumo_dw - homo_dw;
module_elecstate/elecstate_energy.cpp:    const double* v_eff = this->pot->get_effective_v(0);
module_elecstate/elecstate_energy.cpp:    const double* v_fixed = this->pot->get_fixed_v();
module_elecstate/elecstate_energy.cpp:            = XC_Functional::v_xc(this->charge->nrxx, this->charge, &GlobalC::ucell);
module_elecstate/elecstate_energy.cpp:        for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:            deband_aux -= this->charge->rho[0][ir] * v_xc(0,ir);
module_elecstate/elecstate_energy.cpp:            for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:                deband_aux -= this->charge->rho[1][ir] * v_xc(1,ir);
module_elecstate/elecstate_energy.cpp:            v_ofk = this->pot->get_effective_vofk(0);
module_elecstate/elecstate_energy.cpp:        for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:            deband_aux -= this->charge->rho[0][ir] * (v_eff[ir] - v_fixed[ir]);
module_elecstate/elecstate_energy.cpp:                deband_aux -= this->charge->kin_r[0][ir] * v_ofk[ir];
module_elecstate/elecstate_energy.cpp:            v_eff = this->pot->get_effective_v(1);
module_elecstate/elecstate_energy.cpp:            v_ofk = this->pot->get_effective_vofk(1);
module_elecstate/elecstate_energy.cpp:            for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:                deband_aux -= this->charge->rho[1][ir] * (v_eff[ir] - v_fixed[ir]);
module_elecstate/elecstate_energy.cpp:                    deband_aux -= this->charge->kin_r[1][ir] * v_ofk[ir];
module_elecstate/elecstate_energy.cpp:                v_eff = this->pot->get_effective_v(is);
module_elecstate/elecstate_energy.cpp:                for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:                    deband_aux -= this->charge->rho[is][ir] * v_eff[ir];
module_elecstate/elecstate_energy.cpp:    deband0 *= this->omega / this->charge->rhopw->nxyz;
module_elecstate/elecstate_energy.cpp:    deband0 -= 2 * this->f_en.exx; // Peize Lin add 2017-10-16
module_elecstate/elecstate_energy.cpp:    const double* v_eff = this->pot->get_effective_v(0);
module_elecstate/elecstate_energy.cpp:    const double* v_fixed = this->pot->get_fixed_v();
module_elecstate/elecstate_energy.cpp:        v_ofk = this->pot->get_effective_vofk(0);
module_elecstate/elecstate_energy.cpp:    for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:        descf -= (this->charge->rho[0][ir] - this->charge->rho_save[0][ir]) * (v_eff[ir] - v_fixed[ir]);
module_elecstate/elecstate_energy.cpp:            descf -= (this->charge->kin_r[0][ir] - this->charge->kin_r_save[0][ir]) * v_ofk[ir];
module_elecstate/elecstate_energy.cpp:        v_eff = this->pot->get_effective_v(1);
module_elecstate/elecstate_energy.cpp:            v_ofk = this->pot->get_effective_vofk(1);
module_elecstate/elecstate_energy.cpp:        for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:            descf -= (this->charge->rho[1][ir] - this->charge->rho_save[1][ir]) * (v_eff[ir] - v_fixed[ir]);
module_elecstate/elecstate_energy.cpp:                descf -= (this->charge->kin_r[1][ir] - this->charge->kin_r_save[1][ir]) * v_ofk[ir];
module_elecstate/elecstate_energy.cpp:            v_eff = this->pot->get_effective_v(is);
module_elecstate/elecstate_energy.cpp:            for (int ir = 0; ir < this->charge->rhopw->nrxx; ir++)
module_elecstate/elecstate_energy.cpp:                descf -= (this->charge->rho[is][ir] - this->charge->rho_save[is][ir]) * v_eff[ir];
module_elecstate/elecstate_energy.cpp:    descf *= this->omega / this->charge->rhopw->nxyz;
module_elecstate/elecstate_energy.cpp:    this->pot->get_vnew(this->charge, this->vnew);
module_elecstate/elecstate_energy.cpp:    this->vnew_exist = true;
module_elecstate/elecstate_energy.cpp:    this->f_en.descf = 0.0;
module_elecstate/elecstate_energy.cpp:    this->f_en.hartree_energy = get_hartree_energy();
module_elecstate/elecstate_energy.cpp:    this->f_en.efield = get_etot_efield();
module_elecstate/elecstate_energy.cpp:    this->f_en.gatefield = get_etot_gatefield();
module_elecstate/elecstate_energy.cpp:        this->f_en.esol_el = get_solvent_model_Ael();
module_elecstate/elecstate_energy.cpp:        this->f_en.esol_cav = get_solvent_model_Acav();
module_elecstate/elecstate_energy.cpp:        this->f_en.escon = get_spin_constrain_energy();
module_elecstate/elecstate_energy.cpp:        this->f_en.edftu = get_dftu_energy();
module_elecstate/elecstate_energy.cpp:        this->f_en.edeepks_scf = get_deepks_E_delta() - get_deepks_E_delta_band();
module_elecstate/elecstate_energy.cpp:        this->f_en.calculate_harris();
module_elecstate/elecstate_energy.cpp:        this->f_en.calculate_etot();
module_elecstate/elecstate_energy_terms.cpp:    return GlobalC::solvent_model.cal_Ael(GlobalC::ucell, this->charge->nrxx, this->charge->nxyz);
module_elecstate/elecstate_energy_terms.cpp:    return GlobalC::solvent_model.cal_Acav(GlobalC::ucell, this->charge->nxyz);
module_elecstate/elecstate_exx.cpp:        this->f_en.exx = GlobalC::exx_info.info_global.hybrid_alpha * Eexx;
module_elecstate/elecstate_lcao.cpp:    this->lowf->wfc_2d_to_grid(istep, out_wfc_flag, psi_in.get_pointer(), wfc_grid, this->ekb, this->wg);
module_elecstate/elecstate_lcao.cpp:        wfc_grid = this->lowf->wfc_k_grid[ik];
module_elecstate/elecstate_lcao.cpp:    this->lowf->wfc_2d_to_grid(istep,
module_elecstate/elecstate_lcao.cpp:                               this->ekb,
module_elecstate/elecstate_lcao.cpp:                               this->wg,
module_elecstate/elecstate_lcao.cpp:                               this->klist->kvec_c);
module_elecstate/elecstate_lcao.cpp:            this->lowf->wfc_k_grid[ik][ib][iw] = psi_in(ib, iw);
module_elecstate/elecstate_lcao.cpp:        int row = this->lowf->gridt->lgd;
module_elecstate/elecstate_lcao.cpp:                tmp[iw] = this->lowf->wfc_k_grid[ik][ib][iw * GlobalV::NPOL];
module_elecstate/elecstate_lcao.cpp:                tmp[iw + row / GlobalV::NPOL] = this->lowf->wfc_k_grid[ik][ib][iw * GlobalV::NPOL + 1];
module_elecstate/elecstate_lcao.cpp:                this->lowf->wfc_k_grid[ik][ib][iw] = tmp[iw];
module_elecstate/elecstate_lcao.cpp:    this->calculate_weights();
module_elecstate/elecstate_lcao.cpp:    this->calEBand();
module_elecstate/elecstate_lcao.cpp:        //cal_dm(this->loc->ParaV, this->wg, psi, this->loc->dm_k);
module_elecstate/elecstate_lcao.cpp:        elecstate::cal_dm_psi(this->DM->get_paraV_pointer(), this->wg, psi, *(this->DM));
module_elecstate/elecstate_lcao.cpp:        this->DM->cal_DMR();
module_elecstate/elecstate_lcao.cpp:            const K_Vectors* kv = this->DM->get_kv_pointer();
module_elecstate/elecstate_lcao.cpp:            this->loc->dm_k.resize(kv->nks);
module_elecstate/elecstate_lcao.cpp:                this->loc->set_dm_k(ik, this->DM->get_DMK_pointer(ik));         
module_elecstate/elecstate_lcao.cpp:            this->print_psi(psi);
module_elecstate/elecstate_lcao.cpp:    //this->loc->cal_dk_k(*this->lowf->gridt, this->wg, (*this->klist));
module_elecstate/elecstate_lcao.cpp:        ModuleBase::GlobalFunc::ZEROS(this->charge->rho[is], this->charge->nrxx); // mohan 2009-11-10
module_elecstate/elecstate_lcao.cpp:    this->gint_k->transfer_DM2DtoGrid(this->DM->get_DMR_vector()); // transfer DM2D to DM_grid in gint
module_elecstate/elecstate_lcao.cpp:    Gint_inout inout(this->loc->DM_R, this->charge->rho, Gint_Tools::job_type::rho);
module_elecstate/elecstate_lcao.cpp:    this->gint_k->cal_gint(&inout);
module_elecstate/elecstate_lcao.cpp:            ModuleBase::GlobalFunc::ZEROS(this->charge->kin_r[is], this->charge->nrxx);
module_elecstate/elecstate_lcao.cpp:        Gint_inout inout1(this->loc->DM_R, this->charge->kin_r, Gint_Tools::job_type::tau);
module_elecstate/elecstate_lcao.cpp:        this->gint_k->cal_gint(&inout1);
module_elecstate/elecstate_lcao.cpp:    this->charge->renormalize_rho();
module_elecstate/elecstate_lcao.cpp:    this->calculate_weights();
module_elecstate/elecstate_lcao.cpp:    this->calEBand();
module_elecstate/elecstate_lcao.cpp:        //cal_dm(this->loc->ParaV, this->wg, psi, this->loc->dm_gamma);
module_elecstate/elecstate_lcao.cpp:        elecstate::cal_dm_psi(this->DM->get_paraV_pointer(), this->wg, psi, *(this->DM));
module_elecstate/elecstate_lcao.cpp:        this->DM->cal_DMR();
module_elecstate/elecstate_lcao.cpp:        if (this->loc->out_dm) // keep interface for old Output_DM until new one is ready
module_elecstate/elecstate_lcao.cpp:            this->loc->dm_gamma.resize(GlobalV::NSPIN);
module_elecstate/elecstate_lcao.cpp:                this->loc->set_dm_gamma(is, this->DM->get_DMK_pointer(is));
module_elecstate/elecstate_lcao.cpp:                this->print_psi(psi);
module_elecstate/elecstate_lcao.cpp:            if (this->loc->out_dm) // keep interface for old Output_DM until new one is ready
module_elecstate/elecstate_lcao.cpp:                this->loc->cal_dk_gamma_from_2D_pub();
module_elecstate/elecstate_lcao.cpp:        ModuleBase::GlobalFunc::ZEROS(this->charge->rho[is], this->charge->nrxx); // mohan 2009-11-10
module_elecstate/elecstate_lcao.cpp:    this->gint_gamma->transfer_DM2DtoGrid(this->DM->get_DMR_vector()); // transfer DM2D to DM_grid in gint
module_elecstate/elecstate_lcao.cpp:    Gint_inout inout(this->loc->DM, this->charge->rho, Gint_Tools::job_type::rho);
module_elecstate/elecstate_lcao.cpp:    this->gint_gamma->cal_gint(&inout);
module_elecstate/elecstate_lcao.cpp:            ModuleBase::GlobalFunc::ZEROS(this->charge->kin_r[is], this->charge->nrxx);
module_elecstate/elecstate_lcao.cpp:        Gint_inout inout1(this->loc->DM, this->charge->kin_r, Gint_Tools::job_type::tau);
module_elecstate/elecstate_lcao.cpp:        this->gint_gamma->cal_gint(&inout1);
module_elecstate/elecstate_lcao.cpp:    this->charge->renormalize_rho();
module_elecstate/elecstate_lcao.cpp:    this->DM = new DensityMatrix<TK,double>(kv, paraV, nspin);
module_elecstate/elecstate_lcao.h:        this->loc = loc_in;
module_elecstate/elecstate_lcao.h:        this->gint_gamma = gint_gamma_in; // mohan add 2024-04-01
module_elecstate/elecstate_lcao.h:        this->gint_k = gint_k_in; // mohan add 2024-04-01
module_elecstate/elecstate_lcao.h:        this->lowf = lowf_in;
module_elecstate/elecstate_lcao.h:        this->classname = "ElecStateLCAO";
module_elecstate/elecstate_lcao.h:		if (this->DM != nullptr)
module_elecstate/elecstate_lcao.h:			delete this->DM;
module_elecstate/elecstate_lcao.h:    DensityMatrix<TK,double>* get_DM() const { return const_cast<DensityMatrix<TK,double>*>(this->DM); } 
module_elecstate/elecstate_lcao_tddft.cpp:    this->calculate_weights_td();
module_elecstate/elecstate_lcao_tddft.cpp:    this->calEBand();
module_elecstate/elecstate_lcao_tddft.cpp:        elecstate::cal_dm_psi(this->DM->get_paraV_pointer(), this->wg, psi, *(this->DM));
module_elecstate/elecstate_lcao_tddft.cpp:        this->DM->cal_DMR();
module_elecstate/elecstate_lcao_tddft.cpp:            const K_Vectors* kv = this->DM->get_kv_pointer();
module_elecstate/elecstate_lcao_tddft.cpp:            this->loc->dm_k.resize(kv->nks);
module_elecstate/elecstate_lcao_tddft.cpp:                this->loc->set_dm_k(ik, this->DM->get_DMK_pointer(ik));         
module_elecstate/elecstate_lcao_tddft.cpp:            this->print_psi(psi);
module_elecstate/elecstate_lcao_tddft.cpp:    //this->loc->cal_dk_k(*this->lowf->gridt, this->wg, *(this->klist));
module_elecstate/elecstate_lcao_tddft.cpp:        ModuleBase::GlobalFunc::ZEROS(this->charge->rho[is], this->charge->nrxx); // mohan 2009-11-10
module_elecstate/elecstate_lcao_tddft.cpp:    this->gint_k->transfer_DM2DtoGrid(this->DM->get_DMR_vector()); // transfer DM2D to DM_grid in gint
module_elecstate/elecstate_lcao_tddft.cpp:    Gint_inout inout(this->loc->DM_R, this->charge->rho, Gint_Tools::job_type::rho); // rho calculation
module_elecstate/elecstate_lcao_tddft.cpp:    this->gint_k->cal_gint(&inout);
module_elecstate/elecstate_lcao_tddft.cpp:    this->charge->renormalize_rho();
module_elecstate/elecstate_lcao_tddft.cpp:        num = this->klist->nks * GlobalV::NBANDS;
module_elecstate/elecstate_lcao_tddft.cpp:        for (int ik = 0; ik < this->klist->nks; ik++)
module_elecstate/elecstate_lcao_tddft.cpp:                this->wg(ik, ib) = GlobalV::ocp_kb[ik * GlobalV::NBANDS + ib];
module_elecstate/elecstate_lcao_tddft.h:        this->loc = loc_in;
module_elecstate/elecstate_lcao_tddft.h:        this->gint_k = gint_k_in;
module_elecstate/elecstate_lcao_tddft.h:        this->lowf = lowf_in;
module_elecstate/elecstate_lcao_tddft.h:        this->classname = "ElecStateLCAO_TDDFT";
module_elecstate/elecstate_print.cpp:    for (int ik = 0; ik < this->klist->nks; ++ik)
module_elecstate/elecstate_print.cpp:        for (int ib = 0; ib < this->ekb.nc; ++ib)
module_elecstate/elecstate_print.cpp:            if (std::abs(this->ekb(ik, ib)) > 1.0e10)
module_elecstate/elecstate_print.cpp:                GlobalV::ofs_warning << " ik=" << ik + 1 << " ib=" << ib + 1 << " " << this->ekb(ik, ib) << " Ry"
module_elecstate/elecstate_print.cpp:    for (int ik = 0; ik < this->klist->nks; ik++)
module_elecstate/elecstate_print.cpp:        else if (ik == this->klist->nks / 2)
module_elecstate/elecstate_print.cpp:            if (this->klist->isk[ik] == 0)
module_elecstate/elecstate_print.cpp:                ofs << " " << ik + 1 << "/" << this->klist->nks / 2 
module_elecstate/elecstate_print.cpp:                << " kpoint (Cartesian) = " << this->klist->kvec_c[ik].x << " " << this->klist->kvec_c[ik].y << " " << this->klist->kvec_c[ik].z << " (" << this->klist->ngk[ik] << " pws)" << std::endl;
module_elecstate/elecstate_print.cpp:            if (this->klist->isk[ik] == 1)
module_elecstate/elecstate_print.cpp:                ofs << " " << ik + 1 - this->klist->nks / 2 << "/" << this->klist->nks / 2
module_elecstate/elecstate_print.cpp:                    << " kpoint (Cartesian) = " << this->klist->kvec_c[ik].x << " " << this->klist->kvec_c[ik].y << " "
module_elecstate/elecstate_print.cpp:                    << this->klist->kvec_c[ik].z << " (" << this->klist->ngk[ik] << " pws)" << std::endl;
module_elecstate/elecstate_print.cpp:            ofs << " " << ik + 1 << "/" << this->klist->nks << " kpoint (Cartesian) = " << this->klist->kvec_c[ik].x
module_elecstate/elecstate_print.cpp:                << " " << this->klist->kvec_c[ik].y << " " << this->klist->kvec_c[ik].z << " (" << this->klist->ngk[ik]
module_elecstate/elecstate_print.cpp:        for (int ib = 0; ib < this->ekb.nc; ib++)
module_elecstate/elecstate_print.cpp:            ofs << std::setw(8) << ib + 1 << std::setw(15) << this->ekb(ik, ib) * ModuleBase::Ry_to_eV << std::setw(15)
module_elecstate/elecstate_print.cpp:                << this->wg(ik, ib) << std::endl;
module_elecstate/elecstate_print.cpp:        if (std::abs(this->ekb(ik, ib)) > 1.0e10)
module_elecstate/elecstate_print.cpp:            GlobalV::ofs_warning << " ik=" << ik + 1 << " ib=" << ib + 1 << " " << this->ekb(ik, ib) << " Ry"
module_elecstate/elecstate_print.cpp:                                     << this->ekb(ik, ib) * ModuleBase::Ry_to_eV;
module_elecstate/elecstate_print.cpp:                GlobalV::ofs_running << std::setw(15) << this->wg(ik, ib);
module_elecstate/elecstate_print.cpp:    const int nrxx = this->charge->nrxx;
module_elecstate/elecstate_print.cpp:    const int nxyz = this->charge->nxyz;
module_elecstate/elecstate_print.cpp:        titles.push_back("E_KohnSham");     energies_Ry.push_back(this->f_en.etot);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_KS(sigma->0)"); energies_Ry.push_back(this->f_en.etot - this->f_en.demet/(2+n_order));
module_elecstate/elecstate_print.cpp:        titles.push_back("E_Harris");       energies_Ry.push_back(this->f_en.etot_harris);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_band");         energies_Ry.push_back(this->f_en.eband);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_one_elec");     energies_Ry.push_back(this->f_en.eband + this->f_en.deband);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_Hartree");      energies_Ry.push_back(this->f_en.hartree_energy);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_xc");           energies_Ry.push_back(this->f_en.etxc - this->f_en.etxcc);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_Ewald");        energies_Ry.push_back(this->f_en.ewald_energy);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_entropy(-TS)"); energies_Ry.push_back(this->f_en.demet);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_descf");        energies_Ry.push_back(this->f_en.descf);
module_elecstate/elecstate_print.cpp:            titles.push_back("E_vdwD2"); energies_Ry.push_back(this->f_en.evdw);
module_elecstate/elecstate_print.cpp:            titles.push_back("E_vdwD3"); energies_Ry.push_back(this->f_en.evdw);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_exx"); energies_Ry.push_back(this->f_en.exx);
module_elecstate/elecstate_print.cpp:            titles.push_back("E_sol_el"); energies_Ry.push_back(this->f_en.esol_el);
module_elecstate/elecstate_print.cpp:            titles.push_back("E_sol_cav"); energies_Ry.push_back(this->f_en.esol_cav);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_KohnSham"); energies_Ry.push_back(this->f_en.etot);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_Harris");   energies_Ry.push_back(this->f_en.etot_harris);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_Fermi_up"); energies_Ry.push_back(this->eferm.ef_up);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_Fermi_dw"); energies_Ry.push_back(this->eferm.ef_dw);
module_elecstate/elecstate_print.cpp:        titles.push_back("E_Fermi"); energies_Ry.push_back(this->eferm.ef);
module_elecstate/elecstate_print.cpp:            titles.push_back("E_bandgap"); energies_Ry.push_back(this->bandgap);
module_elecstate/elecstate_print.cpp:            titles.push_back("E_bandgap_up"); energies_Ry.push_back(this->bandgap_up);
module_elecstate/elecstate_print.cpp:            titles.push_back("E_bandgap_dw"); energies_Ry.push_back(this->bandgap_dw);
module_elecstate/elecstate_print.cpp:        this->f_en.etot_old = this->f_en.etot;
module_elecstate/elecstate_print.cpp:    this->f_en.etot_delta = this->f_en.etot - this->f_en.etot_old;
module_elecstate/elecstate_print.cpp:                printf("\e[36m%-15f\e[0m", this->f_en.etot);
module_elecstate/elecstate_print.cpp:                printf("\e[36m%-15f\e[0m", this->f_en.etot * ModuleBase::Ry_to_eV);
module_elecstate/elecstate_print.cpp:            std::cout << std::setw(15) << this->f_en.etot * ModuleBase::Ry_to_eV;
module_elecstate/elecstate_print.cpp:            std::cout << std::setw(15) << this->f_en.etot_delta * ModuleBase::Ry_to_eV;
module_elecstate/elecstate_print.cpp:    this->f_en.etot_old = this->f_en.etot;
module_elecstate/elecstate_pw.cpp:    this->classname = "ElecStatePW";
module_elecstate/elecstate_pw.cpp:    this->rhopw_smooth = rhopw_in;
module_elecstate/elecstate_pw.cpp:    this->ppcell = ppcell_in;
module_elecstate/elecstate_pw.cpp:    this->ucell = ucell_in;
module_elecstate/elecstate_pw.cpp:    this->init_ks(chg_in, pkv_in, pkv_in->nks, rhodpw_in, bigpw_in);
module_elecstate/elecstate_pw.cpp:    if (psi::device::get_device_type<Device>(this->ctx) == psi::GpuDevice) {
module_elecstate/elecstate_pw.cpp:        delmem_var_op()(this->ctx, this->rho_data);
module_elecstate/elecstate_pw.cpp:            delmem_var_op()(this->ctx, this->kin_r_data);
module_elecstate/elecstate_pw.cpp:    delmem_var_op()(this->ctx, becsum);
module_elecstate/elecstate_pw.cpp:    delmem_complex_op()(this->ctx, this->wfcr);
module_elecstate/elecstate_pw.cpp:    delmem_complex_op()(this->ctx, this->wfcr_another_spin);
module_elecstate/elecstate_pw.cpp:        this->rho = new Real*[this->charge->nspin];
module_elecstate/elecstate_pw.cpp:        resmem_var_op()(this->ctx, this->rho_data, this->charge->nspin * this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:        for (int ii = 0; ii < this->charge->nspin; ii++) {
module_elecstate/elecstate_pw.cpp:            this->rho[ii] = this->rho_data + ii * this->charge->nrxx;
module_elecstate/elecstate_pw.cpp:            this->kin_r = new Real*[this->charge->nspin];
module_elecstate/elecstate_pw.cpp:            resmem_var_op()(this->ctx, this->kin_r_data, this->charge->nspin * this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:            for (int ii = 0; ii < this->charge->nspin; ii++) {
module_elecstate/elecstate_pw.cpp:                this->kin_r[ii] = this->kin_r_data + ii * this->charge->nrxx;
module_elecstate/elecstate_pw.cpp:        this->rho = reinterpret_cast<Real **>(this->charge->rho);
module_elecstate/elecstate_pw.cpp:            this->kin_r = reinterpret_cast<Real **>(this->charge->kin_r);
module_elecstate/elecstate_pw.cpp:    resmem_complex_op()(this->ctx, this->wfcr, this->basis->nmaxgr, "ElecSPW::wfcr");
module_elecstate/elecstate_pw.cpp:    resmem_complex_op()(this->ctx, this->wfcr_another_spin, this->basis->nrxx, "ElecSPW::wfcr_a");
module_elecstate/elecstate_pw.cpp:    this->init_rho = true;
module_elecstate/elecstate_pw.cpp:    if (!this->init_rho) {
module_elecstate/elecstate_pw.cpp:        this->init_rho_data();
module_elecstate/elecstate_pw.cpp:    this->calculate_weights();
module_elecstate/elecstate_pw.cpp:    this->calEBand();
module_elecstate/elecstate_pw.cpp:		// ModuleBase::GlobalFunc::ZEROS(this->rho[is], this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:        setmem_var_op()(this->ctx, this->rho[is], 0,  this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:            // ModuleBase::GlobalFunc::ZEROS(this->charge->kin_r[is], this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:            setmem_var_op()(this->ctx, this->kin_r[is], 0,  this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:        this->updateRhoK(psi);
module_elecstate/elecstate_pw.cpp:        this->add_usrho(psi);
module_elecstate/elecstate_pw.cpp:            castmem_var_d2h_op()(cpu_ctx, this->ctx, this->charge->rho[ii], this->rho[ii], this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:                castmem_var_d2h_op()(cpu_ctx, this->ctx, this->charge->kin_r[ii], this->kin_r[ii], this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:    this->parallelK();
module_elecstate/elecstate_pw.cpp:    this->rhoBandK(psi);
module_elecstate/elecstate_pw.cpp:    this->charge->rho_mpi();
module_elecstate/elecstate_pw.cpp:        this->f_en.eband /= GlobalV::NPROC_IN_POOL;
module_elecstate/elecstate_pw.cpp:        MPI_Allreduce(MPI_IN_PLACE, &this->f_en.eband, 1, MPI_DOUBLE, MPI_SUM, STO_WORLD);
module_elecstate/elecstate_pw.cpp:    // wfcr.resize(this->basis->nmaxgr);
module_elecstate/elecstate_pw.cpp:    //     wfcr_another_spin.resize(this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:    if (!this->init_rho) {
module_elecstate/elecstate_pw.cpp:        this->init_rho_data();
module_elecstate/elecstate_pw.cpp:        current_spin = this->klist->isk[ik];
module_elecstate/elecstate_pw.cpp:            this->basis->recip_to_real(this->ctx, &psi(ibnd,0), this->wfcr, ik);
module_elecstate/elecstate_pw.cpp:            this->basis->recip_to_real(this->ctx, &psi(ibnd,npwx), this->wfcr_another_spin, ik);
module_elecstate/elecstate_pw.cpp:            const auto w1 = static_cast<Real>(this->wg(ik, ibnd) / get_ucell_omega());
module_elecstate/elecstate_pw.cpp:                elecstate_pw_op()(this->ctx,
module_elecstate/elecstate_pw.cpp:                                  this->basis->nrxx,
module_elecstate/elecstate_pw.cpp:                                  this->rho,
module_elecstate/elecstate_pw.cpp:                                  this->wfcr,
module_elecstate/elecstate_pw.cpp:                                  this->wfcr_another_spin);
module_elecstate/elecstate_pw.cpp:            this->basis->recip_to_real(this->ctx, &psi(ibnd,0), this->wfcr, ik);
module_elecstate/elecstate_pw.cpp:            const auto w1 = static_cast<Real>(this->wg(ik, ibnd) / get_ucell_omega());
module_elecstate/elecstate_pw.cpp:                elecstate_pw_op()(this->ctx, current_spin, this->basis->nrxx, w1, this->rho, this->wfcr);
module_elecstate/elecstate_pw.cpp:                    setmem_complex_op()(this->ctx, this->wfcr, 0,  this->charge->nrxx);
module_elecstate/elecstate_pw.cpp:                    meta_op()(this->ctx,
module_elecstate/elecstate_pw.cpp:                              this->basis->npwk_max,
module_elecstate/elecstate_pw.cpp:                              this->basis->template get_gcar_data<Real>(),
module_elecstate/elecstate_pw.cpp:                              this->basis->template get_kvec_c_data<Real>(),
module_elecstate/elecstate_pw.cpp:                              this->wfcr);
module_elecstate/elecstate_pw.cpp:                    this->basis->recip_to_real(this->ctx, this->wfcr, this->wfcr, ik);
module_elecstate/elecstate_pw.cpp:                    elecstate_pw_op()(this->ctx, current_spin, this->charge->nrxx, w1, this->kin_r, this->wfcr);
module_elecstate/elecstate_pw.cpp:    const int nkb = this->ppcell->nkb;
module_elecstate/elecstate_pw.cpp:    this->vkb = this->ppcell->template get_vkb_data<Real>();
module_elecstate/elecstate_pw.cpp:    resmem_complex_op()(this->ctx, becp, nbands * nkb, "ElecState<PW>::becp");
module_elecstate/elecstate_pw.cpp:    const int nh_tot = this->ppcell->nhm * (this->ppcell->nhm + 1) / 2;
module_elecstate/elecstate_pw.cpp:    resmem_var_op()(this->ctx, becsum, nh_tot * ucell->nat * GlobalV::NSPIN, "ElecState<PW>::becsum");
module_elecstate/elecstate_pw.cpp:    setmem_var_op()(this->ctx, becsum, 0, nh_tot * ucell->nat * GlobalV::NSPIN);
module_elecstate/elecstate_pw.cpp:        const int currect_spin = this->klist->isk[ik];
module_elecstate/elecstate_pw.cpp:        if (this->ppcell->nkb > 0)
module_elecstate/elecstate_pw.cpp:            this->ppcell->getvnl(this->ctx, ik, this->vkb);
module_elecstate/elecstate_pw.cpp:            gemv_op()(this->ctx,
module_elecstate/elecstate_pw.cpp:                      this->ppcell->nkb,
module_elecstate/elecstate_pw.cpp:                      this->vkb,
module_elecstate/elecstate_pw.cpp:                      this->ppcell->vkb.nc,
module_elecstate/elecstate_pw.cpp:            gemm_op()(this->ctx,
module_elecstate/elecstate_pw.cpp:                      this->ppcell->nkb,
module_elecstate/elecstate_pw.cpp:                      this->vkb,
module_elecstate/elecstate_pw.cpp:                      this->ppcell->vkb.nc,
module_elecstate/elecstate_pw.cpp:                      this->ppcell->nkb);
module_elecstate/elecstate_pw.cpp:        Parallel_Reduce::reduce_pool(becp, this->ppcell->nkb * nbands);
module_elecstate/elecstate_pw.cpp:                resmem_complex_op()(this->ctx, auxk1, nbands * atom->ncpp.nh, "ElecState<PW>::auxk1");
module_elecstate/elecstate_pw.cpp:                resmem_complex_op()(this->ctx, auxk2, nbands * atom->ncpp.nh, "ElecState<PW>::auxk2");
module_elecstate/elecstate_pw.cpp:                resmem_complex_op()(this->ctx,
module_elecstate/elecstate_pw.cpp:                            const int ikb = this->ppcell->indv_ijkb0[iat] + ih;
module_elecstate/elecstate_pw.cpp:                                auxk1[ih * nbands + ib] = becp[ib * this->ppcell->nkb + ikb];
module_elecstate/elecstate_pw.cpp:                                    = becp[ib * this->ppcell->nkb + ikb] * static_cast<Real>(this->wg(ik, ib));
module_elecstate/elecstate_pw.cpp:                        gemm_op()(this->ctx,
module_elecstate/elecstate_pw.cpp:                delmem_complex_op()(this->ctx, auxk1);
module_elecstate/elecstate_pw.cpp:                delmem_complex_op()(this->ctx, auxk2);
module_elecstate/elecstate_pw.cpp:                delmem_complex_op()(this->ctx, aux_gk);
module_elecstate/elecstate_pw.cpp:    delmem_complex_op()(this->ctx, becp);
module_elecstate/elecstate_pw.cpp:    resmem_complex_op()(this->ctx, rhog, this->charge->rhopw->npw * GlobalV::NSPIN, "ElecState<PW>::rhog");
module_elecstate/elecstate_pw.cpp:    setmem_complex_op()(this->ctx, rhog, 0, this->charge->rhopw->npw * GlobalV::NSPIN);
module_elecstate/elecstate_pw.cpp:        this->rhopw_smooth->real2recip(this->rho[is], &rhog[is * this->charge->rhopw->npw]);
module_elecstate/elecstate_pw.cpp:    this->addusdens_g(becsum, rhog);
module_elecstate/elecstate_pw.cpp:        this->charge->rhopw->recip2real(&rhog[is * this->charge->rhopw->npw], this->rho[is]);
module_elecstate/elecstate_pw.cpp:    delmem_complex_op()(this->ctx, rhog);
module_elecstate/elecstate_pw.cpp:    const int npw = this->charge->rhopw->npw;
module_elecstate/elecstate_pw.cpp:    const int lmaxq = this->ppcell->lmaxq;
module_elecstate/elecstate_pw.cpp:    const int nh_tot = this->ppcell->nhm * (this->ppcell->nhm + 1) / 2;
module_elecstate/elecstate_pw.cpp:    Structure_Factor* psf = this->ppcell->psf;
module_elecstate/elecstate_pw.cpp:    resmem_var_op()(this->ctx, qmod, npw, "ElecState<PW>::qmod");
module_elecstate/elecstate_pw.cpp:    resmem_complex_op()(this->ctx, qgm, npw, "ElecState<PW>::qgm");
module_elecstate/elecstate_pw.cpp:    resmem_var_op()(this->ctx, ylmk0, npw * lmaxq * lmaxq, "ElecState<PW>::ylmk0");
module_elecstate/elecstate_pw.cpp:    Real* g = reinterpret_cast<Real*>(this->charge->rhopw->gcar);
module_elecstate/elecstate_pw.cpp:    ModuleBase::YlmReal::Ylm_Real(this->ctx, lmaxq * lmaxq, npw, g, ylmk0);
module_elecstate/elecstate_pw.cpp:        qmod[ig] = static_cast<Real>(this->charge->rhopw->gcar[ig].norm() * ucell->tpiba);
module_elecstate/elecstate_pw.cpp:            resmem_complex_op()(this->ctx, skk, atom->na * npw, "ElecState<PW>::skk");
module_elecstate/elecstate_pw.cpp:            resmem_complex_op()(this->ctx, aux2, nij * npw, "ElecState<PW>::aux2");
module_elecstate/elecstate_pw.cpp:            resmem_complex_op()(this->ctx, tbecsum, GlobalV::NSPIN * atom->na * nij, "ElecState<PW>::tbecsum");
module_elecstate/elecstate_pw.cpp:                    double arg = this->charge->rhopw->gcar[ig] * atom->tau[ia];
module_elecstate/elecstate_pw.cpp:                gemm_op()(this->ctx,
module_elecstate/elecstate_pw.cpp:                        this->ppcell->radial_fft_q(this->ctx, npw, ih, jh, it, qmod, ylmk0, qgm);
module_elecstate/elecstate_pw.cpp:            delmem_complex_op()(this->ctx, skk);
module_elecstate/elecstate_pw.cpp:            delmem_complex_op()(this->ctx, aux2);
module_elecstate/elecstate_pw.cpp:            delmem_complex_op()(this->ctx, tbecsum);
module_elecstate/elecstate_pw.cpp:    delmem_var_op()(this->ctx, qmod);
module_elecstate/elecstate_pw.cpp:    delmem_complex_op()(this->ctx, qgm);
module_elecstate/elecstate_pw.cpp:    delmem_var_op()(this->ctx, ylmk0);
module_elecstate/elecstate_pw_sdft.cpp:        ModuleBase::TITLE(this->classname, "psiToRho");
module_elecstate/elecstate_pw_sdft.cpp:        ModuleBase::timer::tick(this->classname, "psiToRho");
module_elecstate/elecstate_pw_sdft.cpp:			ModuleBase::GlobalFunc::ZEROS(this->charge->rho[is], this->charge->nrxx);
module_elecstate/elecstate_pw_sdft.cpp:                ModuleBase::GlobalFunc::ZEROS(this->charge->kin_r[is], this->charge->nrxx);
module_elecstate/elecstate_pw_sdft.cpp:            this->calEBand();
module_elecstate/elecstate_pw_sdft.cpp:		        ModuleBase::GlobalFunc::ZEROS(this->charge->rho[is], this->charge->nrxx);
module_elecstate/elecstate_pw_sdft.cpp:                this->updateRhoK(psi);
module_elecstate/elecstate_pw_sdft.cpp:            this->parallelK();
module_elecstate/elecstate_pw_sdft.cpp:        ModuleBase::timer::tick(this->classname, "psiToRho");
module_elecstate/elecstate_pw_sdft.h:          this->classname = "ElecStatePW_SDFT";
module_elecstate/fp_energy.cpp:        return this->ef;
module_elecstate/fp_energy.cpp:        return this->ef_up;
module_elecstate/fp_energy.cpp:        return this->ef_dw;
module_elecstate/fp_energy.cpp:        return this->ef;
module_elecstate/fp_energy.cpp:        return this->ef_up;
module_elecstate/fp_energy.cpp:        return this->ef_dw;
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->cpu_ctx, 
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->spin, this->nrxx,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->w1, 
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->wfcr.data());
module_elecstate/kernels/test/elecstate_op_test.cpp:    rho[1] = rho_data.data() + this->nrxx;
module_elecstate/kernels/test/elecstate_op_test.cpp:    rho[2] = rho_data.data() + this->nrxx * 2;
module_elecstate/kernels/test/elecstate_op_test.cpp:    rho[3] = rho_data.data() + this->nrxx * 3;
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->cpu_ctx, 
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->DOMAG,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->DOMAG_Z,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->nrxx,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->w1, 
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->wfcr_2.data(),
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->wfcr_another_spin_2.data());
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->gpu_ctx, 
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->spin, this->nrxx,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->w1,
module_elecstate/kernels/test/elecstate_op_test.cpp:    delete_memory_var_op()(this->gpu_ctx, d_rho_data);
module_elecstate/kernels/test/elecstate_op_test.cpp:    delete_memory_complex_op()(this->gpu_ctx, d_wfcr);
module_elecstate/kernels/test/elecstate_op_test.cpp:    rho[1] = d_rho_data_2 + this->nrxx;
module_elecstate/kernels/test/elecstate_op_test.cpp:    rho[2] = d_rho_data_2 + this->nrxx * 2;
module_elecstate/kernels/test/elecstate_op_test.cpp:    rho[3] = d_rho_data_2 + this->nrxx * 3;
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->gpu_ctx, 
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->DOMAG,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->DOMAG_Z,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->nrxx,
module_elecstate/kernels/test/elecstate_op_test.cpp:      this->w1, 
module_elecstate/kernels/test/elecstate_op_test.cpp:    delete_memory_var_op()(this->gpu_ctx, d_rho_data_2);
module_elecstate/kernels/test/elecstate_op_test.cpp:    delete_memory_complex_op()(this->gpu_ctx, d_wfcr_2);
module_elecstate/kernels/test/elecstate_op_test.cpp:    delete_memory_complex_op()(this->gpu_ctx, d_wfcr_another_spin_2);
module_elecstate/magnetism.cpp:    this->tot_magnetization = 0.0;
module_elecstate/magnetism.cpp:    this->abs_magnetization = 0.0;
module_elecstate/magnetism.cpp:    this->start_magnetization = nullptr;
module_elecstate/magnetism.cpp:    delete[] this->start_magnetization;
module_elecstate/magnetism.cpp:        this->tot_magnetization = 0.00;
module_elecstate/magnetism.cpp:        this->abs_magnetization = 0.00;
module_elecstate/magnetism.cpp:            this->tot_magnetization += diff;
module_elecstate/magnetism.cpp:            this->abs_magnetization += std::abs(diff);
module_elecstate/magnetism.cpp:        Parallel_Reduce::reduce_pool(this->tot_magnetization);
module_elecstate/magnetism.cpp:        Parallel_Reduce::reduce_pool(this->abs_magnetization);
module_elecstate/magnetism.cpp:        this->tot_magnetization *= elecstate::get_ucell_omega() / nxyz;
module_elecstate/magnetism.cpp:        this->abs_magnetization *= elecstate::get_ucell_omega() / nxyz;
module_elecstate/magnetism.cpp:		ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,"total magnetism (Bohr mag/cell)",this->tot_magnetization);
module_elecstate/magnetism.cpp:		ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,"absolute magnetism (Bohr mag/cell)",this->abs_magnetization);
module_elecstate/magnetism.cpp:			nelec_spin[0] = (GlobalV::nelec + this->tot_magnetization) / 2;
module_elecstate/magnetism.cpp:			nelec_spin[1] = (GlobalV::nelec - this->tot_magnetization) / 2;
module_elecstate/magnetism.cpp:		for(int i=0;i<3;i++)this->tot_magnetization_nc[i] = 0.00;
module_elecstate/magnetism.cpp:		this->abs_magnetization = 0.00;
module_elecstate/magnetism.cpp:			for(int i=0;i<3;i++)this->tot_magnetization_nc[i] += rho[i+1][ir];
module_elecstate/magnetism.cpp:			this->abs_magnetization += std::abs(diff);
module_elecstate/magnetism.cpp:        Parallel_Reduce::reduce_pool(this->tot_magnetization_nc, 3);
module_elecstate/magnetism.cpp:        Parallel_Reduce::reduce_pool(this->abs_magnetization);
module_elecstate/magnetism.cpp:		for(int i=0;i<3;i++)this->tot_magnetization_nc[i] *= elecstate::get_ucell_omega() / nxyz;
module_elecstate/magnetism.cpp:		this->abs_magnetization *= elecstate::get_ucell_omega() / nxyz;
module_elecstate/magnetism.cpp:		GlobalV::ofs_running<<"total magnetism (Bohr mag/cell)"<<'\t'<<this->tot_magnetization_nc[0]<<'\t'<<this->tot_magnetization_nc[1]<<'\t'<<this->tot_magnetization_nc[2]<<'\n';
module_elecstate/magnetism.cpp:		ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,"absolute magnetism (Bohr mag/cell)",this->abs_magnetization);
module_elecstate/module_charge/charge.cpp:    this->destroy();
module_elecstate/module_charge/charge.cpp:    this->rhopw = rhopw_in;
module_elecstate/module_charge/charge.cpp:    this->nrxx = this->rhopw->nrxx;
module_elecstate/module_charge/charge.cpp:    this->nxyz = this->rhopw->nxyz;
module_elecstate/module_charge/charge.cpp:    this->ngmc = this->rhopw->npw;
module_elecstate/module_charge/charge.cpp:        this->destroy();
module_elecstate/module_charge/charge.cpp:    this->nspin = nspin_in;
module_elecstate/module_charge/charge.cpp:    this->rho_core = new double[nrxx]; // core charge in real space
module_elecstate/module_charge/charge.cpp:    this->rhog_core = new std::complex<double>[ngmc]; // reciprocal core charge
module_elecstate/module_charge/charge.cpp:    this->allocate_rho = true;
module_elecstate/module_charge/charge.cpp:                sum_rho += this->rho[is][ir] + this->nhat[is][ir];
module_elecstate/module_charge/charge.cpp:                sum_rho += this->rho[is][ir];
module_elecstate/module_charge/charge.cpp:    sum_rho *= elecstate::get_ucell_omega() / static_cast<double>(this->rhopw->nxyz);
module_elecstate/module_charge/charge.cpp:    const double sr = this->sum_rho();
module_elecstate/module_charge/charge.cpp:    ModuleBase::GlobalFunc::OUT(GlobalV::ofs_warning, "charge after normalized", this->sum_rho());
module_elecstate/module_charge/charge.cpp:            for (int ir = 0; ir < this->rhopw->nrxx; ++ir)
module_elecstate/module_charge/charge.cpp:            ne[is] *= omega / (double)this->rhopw->nxyz;
module_elecstate/module_charge/charge.cpp:            for (int ir = 0; ir < this->rhopw->nrxx; ++ir)
module_elecstate/module_charge/charge.cpp:            for (int ir = 0; ir < this->rhopw->nrxx; ++ir)
module_elecstate/module_charge/charge.cpp:            ModuleBase::ComplexMatrix rho_g3d(spin_number_need, this->rhopw->npw);
module_elecstate/module_charge/charge.cpp:                        std::vector<double> rho_lgl(this->rhopw->ngg, 0);
module_elecstate/module_charge/charge.cpp:                        if (this->rhopw->gg_uniq[0] < 1e-8)
module_elecstate/module_charge/charge.cpp:                            for (int igg = gstart; igg < this->rhopw->ngg; ++igg)
module_elecstate/module_charge/charge.cpp:                                const double gx = sqrt(this->rhopw->gg_uniq[igg]) * ucell.tpiba;
module_elecstate/module_charge/charge.cpp:                            for (int igg = 0; igg < this->rhopw->ngg; igg++)
module_elecstate/module_charge/charge.cpp:                        for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge.cpp:                            rho_g3d(0, ig) += strucFac(it, ig) * rho_lgl[this->rhopw->ig2igg[ig]];
module_elecstate/module_charge/charge.cpp:                            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge.cpp:                                const std::complex<double> swap = strucFac(it, ig) * rho_lgl[this->rhopw->ig2igg[ig]];
module_elecstate/module_charge/charge.cpp:                                for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge.cpp:                                    const double Gtau = this->rhopw->gcar[ig][0] * atom->tau[ia].x
module_elecstate/module_charge/charge.cpp:                                                        + this->rhopw->gcar[ig][1] * atom->tau[ia].y
module_elecstate/module_charge/charge.cpp:                                                        + this->rhopw->gcar[ig][2] * atom->tau[ia].z;
module_elecstate/module_charge/charge.cpp:                                        = ModuleBase::libm::exp(ci_tpi * Gtau) * rho_lgl[this->rhopw->ig2igg[ig]];
module_elecstate/module_charge/charge.cpp:                            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge.cpp:                                const std::complex<double> swap = strucFac(it, ig) * rho_lgl[this->rhopw->ig2igg[ig]];
module_elecstate/module_charge/charge.cpp:                                for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge.cpp:                                    const double Gtau = this->rhopw->gcar[ig][0] * atom->tau[ia].x
module_elecstate/module_charge/charge.cpp:                                                        + this->rhopw->gcar[ig][1] * atom->tau[ia].y
module_elecstate/module_charge/charge.cpp:                                                        + this->rhopw->gcar[ig][2] * atom->tau[ia].z;
module_elecstate/module_charge/charge.cpp:                                    std::complex<double> swap = exp(ci_tpi * Gtau) * rho_lgl[this->rhopw->ig2igg[ig]];
module_elecstate/module_charge/charge.cpp:            this->rhopw->recip2real(&rho_g3d(is, 0), rho_in[is]);
module_elecstate/module_charge/charge.cpp:            for (int ir = 0; ir < this->rhopw->nrxx; ++ir)
module_elecstate/module_charge/charge.cpp:            ne[is] *= omega / (double)this->rhopw->nxyz;
module_elecstate/module_charge/charge.cpp:            for (int ir = 0; ir < this->rhopw->nrxx; ir++)
module_elecstate/module_charge/charge.cpp:                rea = this->rhopw->ft.get_auxr_data<double>()[ir].real();
module_elecstate/module_charge/charge.cpp:                ima += std::abs(this->rhopw->ft.get_auxr_data<double>()[ir].imag());
module_elecstate/module_charge/charge.cpp:            neg = neg / (double)this->rhopw->nxyz * omega;
module_elecstate/module_charge/charge.cpp:            ima = ima / (double)this->rhopw->nxyz * omega;
module_elecstate/module_charge/charge.cpp:            sumrea = sumrea / (double)this->rhopw->nxyz * omega;
module_elecstate/module_charge/charge.cpp:            for (int ir = 0; ir < this->rhopw->nrxx; ++ir)
module_elecstate/module_charge/charge.cpp:        ModuleBase::GlobalFunc::DCOPY(rho[is], rho_save[is], this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:            ModuleBase::GlobalFunc::DCOPY(kin_r[is], kin_r_save[is], this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:            ModuleBase::GlobalFunc::DCOPY(nhat[is], nhat_save[is], this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:    for (int ir = 0; ir < this->rhopw->nrxx; ir++)
module_elecstate/module_charge/charge.cpp:    ne = ne * elecstate::get_ucell_omega() / (double)this->rhopw->nxyz;
module_elecstate/module_charge/charge.cpp:    if (this->nspin==1 || this->nspin==4)
module_elecstate/module_charge/charge.cpp:        ne = this->cal_rho2ne(rho[0]);
module_elecstate/module_charge/charge.cpp:    else if (this->nspin == 2)
module_elecstate/module_charge/charge.cpp:        ne_up = this->cal_rho2ne(rho[0]);
module_elecstate/module_charge/charge.cpp:        ne_dn = this->cal_rho2ne(rho[1]);
module_elecstate/module_charge/charge.cpp:        std::cout << "\n spin_number = " << GlobalV::NSPIN << " real_point_number = " << this->rhopw->nrxx << std::endl;
module_elecstate/module_charge/charge.cpp:        rho[is] = new double[this->rhopw->nrxx];
module_elecstate/module_charge/charge.cpp:        rhog[is] = new std::complex<double>[this->rhopw->npw];
module_elecstate/module_charge/charge.cpp:        rho_save[is] = new double[this->rhopw->nrxx];
module_elecstate/module_charge/charge.cpp:        rhog_save[is] = new std::complex<double>[this->rhopw->npw];
module_elecstate/module_charge/charge.cpp:        ModuleBase::GlobalFunc::ZEROS(rho[is], this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:        ModuleBase::GlobalFunc::ZEROS(rhog[is], this->rhopw->npw);
module_elecstate/module_charge/charge.cpp:        ModuleBase::GlobalFunc::ZEROS(rho_save[is], this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:        ModuleBase::GlobalFunc::ZEROS(rhog_save[is], this->rhopw->npw);
module_elecstate/module_charge/charge.cpp:    ModuleBase::Memory::record("Chg::rho", sizeof(double) * GlobalV::NSPIN * this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:    ModuleBase::Memory::record("Chg::rho_save", sizeof(double) * GlobalV::NSPIN * this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:    ModuleBase::Memory::record("Chg::rhog", sizeof(double) * GlobalV::NSPIN * this->rhopw->npw);
module_elecstate/module_charge/charge.cpp:    ModuleBase::Memory::record("Chg::rhog_save", sizeof(double) * GlobalV::NSPIN * this->rhopw->npw);
module_elecstate/module_charge/charge.cpp:    this->rho_core = new double[this->rhopw->nrxx]; // core charge in real space
module_elecstate/module_charge/charge.cpp:    ModuleBase::GlobalFunc::ZEROS(rho_core, this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:    this->rhog_core = new std::complex<double>[this->rhopw->npw]; // reciprocal core charge
module_elecstate/module_charge/charge.cpp:    ModuleBase::GlobalFunc::ZEROS(rhog_core, this->rhopw->npw);
module_elecstate/module_charge/charge.cpp:    ModuleBase::Memory::record("Chg::rho_core", sizeof(double) * this->rhopw->nrxx);
module_elecstate/module_charge/charge.cpp:    ModuleBase::Memory::record("Chg::rhog_core", sizeof(double) * this->rhopw->npw);
module_elecstate/module_charge/charge.cpp:    this->allocate_rho_final_scf = true;
module_elecstate/module_charge/charge_init.cpp:                        this->rho[is],
module_elecstate/module_charge/charge_init.cpp:                        this->rhopw->nx,
module_elecstate/module_charge/charge_init.cpp:                        this->rhopw->ny,
module_elecstate/module_charge/charge_init.cpp:                        this->rhopw->nz,
module_elecstate/module_charge/charge_init.cpp:                        this->prenspin))
module_elecstate/module_charge/charge_init.cpp:                        for (int ir = 0; ir < this->rhopw->nrxx; ir++)
module_elecstate/module_charge/charge_init.cpp:                            this->rho[is][ir] = 0.0;
module_elecstate/module_charge/charge_init.cpp:                            for (int ir = 0; ir < this->rhopw->nrxx; ir++)
module_elecstate/module_charge/charge_init.cpp:                                this->rho[3][ir] = this->rho[0][ir] - this->rho[1][ir];
module_elecstate/module_charge/charge_init.cpp:                                this->rho[0][ir] = this->rho[0][ir] + this->rho[1][ir];
module_elecstate/module_charge/charge_init.cpp:                                this->rho[1][ir] = 0.0;
module_elecstate/module_charge/charge_init.cpp:                                this->rho[2][ir] = 0.0;
module_elecstate/module_charge/charge_init.cpp:                            this->kin_r[is],
module_elecstate/module_charge/charge_init.cpp:                            this->rhopw->nx,
module_elecstate/module_charge/charge_init.cpp:                            this->rhopw->ny,
module_elecstate/module_charge/charge_init.cpp:                            this->rhopw->nz,
module_elecstate/module_charge/charge_init.cpp:                            this->prenspin))
module_elecstate/module_charge/charge_init.cpp:        this->atomic_rho(GlobalV::NSPIN, GlobalC::ucell.omega, rho, strucFac, GlobalC::ucell);
module_elecstate/module_charge/charge_init.cpp:                for (int ir = 0; ir < this->rhopw->nrxx; ++ir)
module_elecstate/module_charge/charge_init.cpp:            GlobalC::restart.load_disk("charge", is, this->nrxx, rho[is]);
module_elecstate/module_charge/charge_init.cpp:    this->init_chgmpi(nbz, bz);
module_elecstate/module_charge/charge_init.cpp:        ModuleBase::GlobalFunc::ZEROS( this->rho_core, this->rhopw->nrxx);
module_elecstate/module_charge/charge_init.cpp:    double *rhocg = new double[this->rhopw->ngg];
module_elecstate/module_charge/charge_init.cpp:    ModuleBase::GlobalFunc::ZEROS(rhocg, this->rhopw->ngg );
module_elecstate/module_charge/charge_init.cpp:    std::complex<double> *vg = new std::complex<double>[this->rhopw->npw];	
module_elecstate/module_charge/charge_init.cpp:            this->non_linear_core_correction(
module_elecstate/module_charge/charge_init.cpp:            for (int ig = 0; ig < this->rhopw->npw ; ig++)
module_elecstate/module_charge/charge_init.cpp:                vg[ig] += structure_factor(it, ig) * rhocg[this->rhopw->ig2igg[ig]];
module_elecstate/module_charge/charge_init.cpp:	for(int ig=0; ig< this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_init.cpp:		this->rhog_core[ig] = vg[ig];
module_elecstate/module_charge/charge_init.cpp:    this->rhopw->recip2real(vg, this->rho_core);
module_elecstate/module_charge/charge_init.cpp:    for (int ir = 0; ir < this->rhopw->nrxx; ir++)
module_elecstate/module_charge/charge_init.cpp:        rhoneg += std::min(0.0, this->rhopw->ft.get_auxr_data<double>()[ir].real());
module_elecstate/module_charge/charge_init.cpp:        rhoima += std::abs(this->rhopw->ft.get_auxr_data<double>()[ir].imag());
module_elecstate/module_charge/charge_init.cpp:    rhoneg /= this->rhopw->nxyz * GlobalC::ucell.omega;
module_elecstate/module_charge/charge_init.cpp:    rhoima /= this->rhopw->nxyz * GlobalC::ucell.omega;
module_elecstate/module_charge/charge_init.cpp:    GlobalC::paw_cell.get_vloc_ncoret(tmp,this->rho_core);
module_elecstate/module_charge/charge_init.cpp:    this->rhopw->real2recip(this->rho_core,this->rhog_core);
module_elecstate/module_charge/charge_init.cpp:        if (this->rhopw->gg_uniq [0] < 1.0e-8)
module_elecstate/module_charge/charge_init.cpp:		ModuleBase::TASK_DIST_1D(num_threads, thread_id, this->rhopw->ngg - igl0, igl_beg, igl_end);
module_elecstate/module_charge/charge_init.cpp:            gx = sqrt(this->rhopw->gg_uniq[igl] * GlobalC::ucell.tpiba2);
module_elecstate/module_charge/charge_mixing.cpp:    delete this->mixing;
module_elecstate/module_charge/charge_mixing.cpp:    delete this->mixing_highf;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_mode = mixing_mode_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_beta = mixing_beta_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_beta_mag = mixing_beta_mag_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_ndim = mixing_ndim_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_gg0 = mixing_gg0_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_tau = mixing_tau_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_gg0_mag = mixing_gg0_mag_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_gg0_min = mixing_gg0_min_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_angle = mixing_angle_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing_dmr = mixing_dmr_in;
module_elecstate/module_charge/charge_mixing.cpp:    if (this->mixing_beta > 1.0 || this->mixing_beta < 0.0)
module_elecstate/module_charge/charge_mixing.cpp:    if (GlobalV::NSPIN >= 2 && this->mixing_beta_mag < 0.0)
module_elecstate/module_charge/charge_mixing.cpp:    if (!(this->mixing_mode == "plain" || this->mixing_mode == "broyden" || this->mixing_mode == "pulay"))
module_elecstate/module_charge/charge_mixing.cpp:    GlobalV::ofs_running<<"mixing_type: "<< this->mixing_mode <<std::endl;
module_elecstate/module_charge/charge_mixing.cpp:    GlobalV::ofs_running<<"mixing_beta: "<< this->mixing_beta <<std::endl;
module_elecstate/module_charge/charge_mixing.cpp:    GlobalV::ofs_running<<"mixing_gg0: "<< this->mixing_gg0 <<std::endl;
module_elecstate/module_charge/charge_mixing.cpp:        GlobalV::ofs_running<<"mixing_beta_mag: "<< this->mixing_beta_mag <<std::endl;
module_elecstate/module_charge/charge_mixing.cpp:    GlobalV::ofs_running<<"mixing_ndim: "<< this->mixing_ndim <<std::endl;
module_elecstate/module_charge/charge_mixing.cpp:    if (this->mixing_mode == "broyden")
module_elecstate/module_charge/charge_mixing.cpp:        delete this->mixing;
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing = new Base_Mixing::Broyden_Mixing(this->mixing_ndim, this->mixing_beta);
module_elecstate/module_charge/charge_mixing.cpp:    else if (this->mixing_mode == "plain")
module_elecstate/module_charge/charge_mixing.cpp:        delete this->mixing;
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_elecstate/module_charge/charge_mixing.cpp:    else if (this->mixing_mode == "pulay")
module_elecstate/module_charge/charge_mixing.cpp:        delete this->mixing;
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing = new Base_Mixing::Pulay_Mixing(this->mixing_ndim, this->mixing_beta);
module_elecstate/module_charge/charge_mixing.cpp:        delete this->mixing_highf;
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing_highf = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_elecstate/module_charge/charge_mixing.cpp:            this->mixing->init_mixing_data(this->rho_mdata,
module_elecstate/module_charge/charge_mixing.cpp:                                        this->rhopw->npw * 2,
module_elecstate/module_charge/charge_mixing.cpp:            this->mixing->init_mixing_data(this->rho_mdata,
module_elecstate/module_charge/charge_mixing.cpp:                                        this->rhopw->npw * GlobalV::NSPIN,
module_elecstate/module_charge/charge_mixing.cpp:            this->mixing->init_mixing_data(this->rho_mdata, this->rhopw->nrxx * 2, sizeof(double));
module_elecstate/module_charge/charge_mixing.cpp:            this->mixing->init_mixing_data(this->rho_mdata, this->rhopw->nrxx * GlobalV::NSPIN, sizeof(double));
module_elecstate/module_charge/charge_mixing.cpp:            this->mixing->init_mixing_data(this->tau_mdata,
module_elecstate/module_charge/charge_mixing.cpp:                                           this->rhopw->npw * GlobalV::NSPIN,
module_elecstate/module_charge/charge_mixing.cpp:            this->mixing->init_mixing_data(this->tau_mdata, this->rhopw->nrxx * GlobalV::NSPIN, sizeof(double));
module_elecstate/module_charge/charge_mixing.cpp:    if(GlobalV::use_paw) this->mixing->init_mixing_data(this->nhat_mdata, this->rhopw->nrxx * GlobalV::NSPIN, sizeof(double));
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->init_mixing_data(this->dmr_mdata, nnr * dmr_nspin, sizeof(double));
module_elecstate/module_charge/charge_mixing.cpp:    this->dmr_mdata.reset();
module_elecstate/module_charge/charge_mixing.cpp:    this->rhopw = rhopw_in;
module_elecstate/module_charge/charge_mixing.cpp:    this->rhodpw = rhodpw_in;
module_elecstate/module_charge/charge_mixing.cpp:        std::vector<std::complex<double>> drhog(GlobalV::NSPIN * this->rhopw->npw);
module_elecstate/module_charge/charge_mixing.cpp:            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:        drho = this->inner_product_recip_rho(drhog.data(), drhog.data());
module_elecstate/module_charge/charge_mixing.cpp:            for (int ir = 0; ir < this->rhopw->nrxx; ir++)
module_elecstate/module_charge/charge_mixing.cpp:        assert(this->rhopw->nxyz > 0);
module_elecstate/module_charge/charge_mixing.cpp:        drho *= GlobalC::ucell.omega / static_cast<double>(this->rhopw->nxyz);
module_elecstate/module_charge/charge_mixing.cpp:        for (int ir = 0; ir < this->rhopw->nrxx; ir++)
module_elecstate/module_charge/charge_mixing.cpp:    assert(this->rhopw->nxyz > 0);
module_elecstate/module_charge/charge_mixing.cpp:    dkin *= GlobalC::ucell.omega / static_cast<double>(this->rhopw->nxyz);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhog_in, rhog_out, screen, true);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhog_out);
module_elecstate/module_charge/charge_mixing.cpp:        const int npw = this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:                      out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                      out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhog_in, rhog_out, screen, twobeta_mix, true);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhog_out);
module_elecstate/module_charge/charge_mixing.cpp:        const int npw = this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:                      out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                      out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhog_in, rhog_out, screen, twobeta_mix, true);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhog_out);
module_elecstate/module_charge/charge_mixing.cpp:        const int nrxx = this->rhopw->nrxx;
module_elecstate/module_charge/charge_mixing.cpp:        const int npw = this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        this->rhopw->real2recip(rho_magabs, rhog_magabs + this->rhopw->npw);
module_elecstate/module_charge/charge_mixing.cpp:        this->rhopw->real2recip(rho_magabs_save, rhog_magabs_save + this->rhopw->npw);
module_elecstate/module_charge/charge_mixing.cpp:                      out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                      out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhog_in, rhog_out, screen, twobeta_mix, true);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhog_out);
module_elecstate/module_charge/charge_mixing.cpp:        this->rhopw->recip2real(rhog_magabs + this->rhopw->npw, rho_magabs);
module_elecstate/module_charge/charge_mixing.cpp:        const int ndimhf = (this->rhodpw->npw - this->rhopw->npw) * GlobalV::NSPIN;
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing_highf->plain_mix(rhoghf_out, rhoghf_in, rhoghf_out, ndimhf, nullptr);
module_elecstate/module_charge/charge_mixing.cpp:            this->rhodpw->recip2real(chr->rhog[is], chr->rho[is]);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->tau_mdata, taugs_in, taugs_out, nullptr, false);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->tau_mdata, taugs_out);
module_elecstate/module_charge/charge_mixing.cpp:            const int ndimhf = (this->rhodpw->npw - this->rhopw->npw) * GlobalV::NSPIN;
module_elecstate/module_charge/charge_mixing.cpp:            this->mixing_highf->plain_mix(taughf_out, taughf_in, taughf_out, ndimhf, nullptr);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->nhat_mdata, nhat_in, nhat_out, nullptr, false);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->nhat_mdata, nhat_out);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhor_in, rhor_out, screen, true);    
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhor_out);
module_elecstate/module_charge/charge_mixing.cpp:        const int nrxx = this->rhopw->nrxx;
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhor_in, rhor_out, screen, twobeta_mix, true);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhor_out);
module_elecstate/module_charge/charge_mixing.cpp:        const int nrxx = this->rhopw->nrxx;
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhor_in, rhor_out, screen, twobeta_mix, true);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhor_out);
module_elecstate/module_charge/charge_mixing.cpp:        const int nrxx = this->rhopw->nrxx;
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->rho_mdata, rhor_in, rhor_out, screen, twobeta_mix, true);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->rho_mdata, rhor_out);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->tau_mdata, taur_in, taur_out, nullptr, false);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->tau_mdata, taur_out);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->dmr_mdata, dmr_in, dmr_out, nullptr, false);    
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->dmr_mdata, dmr_out);
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->dmr_mdata, dmr_in, dmr_out, nullptr, twobeta_mix, false);
module_elecstate/module_charge/charge_mixing.cpp:        //this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->dmr_mdata, dmr_out);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->dmr_mdata, dmr_in, dmr_out, nullptr, false);    
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->dmr_mdata, dmr_out);
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:                out[i] = in[i] + this->mixing_beta_mag * sres[i];
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->push_data(this->dmr_mdata, dmr_in, dmr_out, nullptr, twobeta_mix, false);
module_elecstate/module_charge/charge_mixing.cpp:        //this->mixing->cal_coef(this->rho_mdata, inner_product);
module_elecstate/module_charge/charge_mixing.cpp:        this->mixing->mix_data(this->dmr_mdata, dmr_out);
module_elecstate/module_charge/charge_mixing.cpp:    this->mixing->reset();
module_elecstate/module_charge/charge_mixing.cpp:    this->rho_mdata.reset();
module_elecstate/module_charge/charge_mixing.cpp:        this->tau_mdata.reset();
module_elecstate/module_charge/charge_mixing.cpp:    this->nhat_mdata.reset();
module_elecstate/module_charge/charge_mixing.cpp:    if (this->mixing_gg0 <= 0.0 || this->mixing_beta <= 0.1)
module_elecstate/module_charge/charge_mixing.cpp:    if (GlobalV::NSPIN == 4 && this->mixing_angle > 0) resize_tmp = 2;
module_elecstate/module_charge/charge_mixing.cpp:            if (this->mixing_gg0_mag <= 0.0001 || this->mixing_beta_mag <= 0.1)
module_elecstate/module_charge/charge_mixing.cpp:                //for (int ig = 0; ig < this->rhopw->npw * is_mag; ig++)
module_elecstate/module_charge/charge_mixing.cpp:                //    drhog[is * this->rhopw->npw + ig] *= 1;
module_elecstate/module_charge/charge_mixing.cpp:            fac = this->mixing_gg0_mag;
module_elecstate/module_charge/charge_mixing.cpp:            amin = this->mixing_beta_mag;
module_elecstate/module_charge/charge_mixing.cpp:            fac = this->mixing_gg0;
module_elecstate/module_charge/charge_mixing.cpp:            amin = this->mixing_beta;
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ++ig)
module_elecstate/module_charge/charge_mixing.cpp:            double gg = this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:            double filter_g = std::max(gg / (gg + gg0), this->mixing_gg0_min / amin);
module_elecstate/module_charge/charge_mixing.cpp:            drhog[is * this->rhopw->npw + ig] *= filter_g;
module_elecstate/module_charge/charge_mixing.cpp:    if (this->mixing_gg0 <= 0.0001 || this->mixing_beta <= 0.1)
module_elecstate/module_charge/charge_mixing.cpp:    if (GlobalV::NSPIN == 4 && this->mixing_angle > 0) resize_tmp = 2;
module_elecstate/module_charge/charge_mixing.cpp:    std::vector<std::complex<double>> drhog(this->rhopw->npw * GlobalV::NSPIN / resize_tmp);
module_elecstate/module_charge/charge_mixing.cpp:    std::vector<double> drhor_filter(this->rhopw->nrxx * GlobalV::NSPIN / resize_tmp);
module_elecstate/module_charge/charge_mixing.cpp:        this->rhopw->real2recip(drhor + is * this->rhopw->nrxx, drhog.data() + is * this->rhopw->npw);
module_elecstate/module_charge/charge_mixing.cpp:            if (this->mixing_gg0_mag <= 0.0001 || this->mixing_beta_mag <= 0.1)
module_elecstate/module_charge/charge_mixing.cpp:                if (GlobalV::NSPIN == 4 && this->mixing_angle > 0) is_mag = 1;
module_elecstate/module_charge/charge_mixing.cpp:                for (int ig = 0; ig < this->rhopw->npw * is_mag; ig++)
module_elecstate/module_charge/charge_mixing.cpp:                    drhog[is * this->rhopw->npw + ig] = 0;
module_elecstate/module_charge/charge_mixing.cpp:            fac = this->mixing_gg0_mag;
module_elecstate/module_charge/charge_mixing.cpp:            amin = this->mixing_beta_mag;
module_elecstate/module_charge/charge_mixing.cpp:            fac = this->mixing_gg0;
module_elecstate/module_charge/charge_mixing.cpp:            amin = this->mixing_beta;
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:            double gg = this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:            //    drhog[is * this->rhopw->npw + ig] *= 0;
module_elecstate/module_charge/charge_mixing.cpp:            double filter_g = std::max(gg / (gg + gg0), this->mixing_gg0_min / amin);
module_elecstate/module_charge/charge_mixing.cpp:            drhog[is * this->rhopw->npw + ig] *= (1 - filter_g);
module_elecstate/module_charge/charge_mixing.cpp:        this->rhopw->recip2real(drhog.data() + is * this->rhopw->npw, drhor_filter.data() + is * this->rhopw->nrxx);
module_elecstate/module_charge/charge_mixing.cpp:    for (int ir = 0; ir < this->rhopw->nrxx * GlobalV::NSPIN / resize_tmp; ir++)
module_elecstate/module_charge/charge_mixing.cpp:        rhog1[is] = rho1 + is * this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        rhog2[is] = rho2 + is * this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ++ig)
module_elecstate/module_charge/charge_mixing.cpp:            if (this->rhopw->gg[ig] < 1e-8)
module_elecstate/module_charge/charge_mixing.cpp:            sum += (conj(rhog1[0][ig]) * rhog2[0][ig]).real() / this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ++ig)
module_elecstate/module_charge/charge_mixing.cpp:            if (this->rhopw->gg[ig] < 1e-8)
module_elecstate/module_charge/charge_mixing.cpp:            sum += (conj(rhog1[0][ig] + rhog1[1][ig]) * (rhog2[0][ig] + rhog2[1][ig])).real() / this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:                if (ig == this->rhopw->ig_gge0)
module_elecstate/module_charge/charge_mixing.cpp:                sum += (conj(rhog1[0][ig]) * rhog2[0][ig]).real() / this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:            const int ig0 = this->rhopw->ig_gge0;
module_elecstate/module_charge/charge_mixing.cpp:            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:    if (GlobalV::NSPIN == 4 && this->mixing_angle > 0) resize_tmp = 2;
module_elecstate/module_charge/charge_mixing.cpp:    for (int ig = 0; ig < this->rhopw->npw * GlobalV::NSPIN / resize_tmp; ++ig)
module_elecstate/module_charge/charge_mixing.cpp:    const int npw = this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ++ig)
module_elecstate/module_charge/charge_mixing.cpp:            if (this->rhopw->gg[ig] < 1e-8)
module_elecstate/module_charge/charge_mixing.cpp:            sum += (conj(rhog1[ig]) * rhog2[ig]).real() / this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ++ig)
module_elecstate/module_charge/charge_mixing.cpp:            if (this->rhopw->gg[ig] < 1e-8)
module_elecstate/module_charge/charge_mixing.cpp:            sum += (conj(rhog1[ig]) * (rhog2[ig])).real() / this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:        sum2 += fac2 * (conj(rhog1[0 + this->rhopw->npw]) * rhog2[0 + this->rhopw->npw]).real();
module_elecstate/module_charge/charge_mixing.cpp:        for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:            mag += (conj(rhog1[ig + this->rhopw->npw]) * rhog2[ig + this->rhopw->npw]).real();
module_elecstate/module_charge/charge_mixing.cpp:        else if (this->mixing_angle <= 0)
module_elecstate/module_charge/charge_mixing.cpp:            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:                if (ig == this->rhopw->ig_gge0)
module_elecstate/module_charge/charge_mixing.cpp:                sum += (conj(rhog1[ig]) * rhog2[ig]).real() / this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:            const int ig0 = this->rhopw->ig_gge0;
module_elecstate/module_charge/charge_mixing.cpp:            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:        else if (this->mixing_angle > 0)
module_elecstate/module_charge/charge_mixing.cpp:            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:                if (ig == this->rhopw->ig_gge0)
module_elecstate/module_charge/charge_mixing.cpp:                sum += (conj(rhog1[ig]) * rhog2[ig]).real() / this->rhopw->gg[ig];
module_elecstate/module_charge/charge_mixing.cpp:            const int ig0 = this->rhopw->ig_gge0;
module_elecstate/module_charge/charge_mixing.cpp:                       * ((conj(rhog1[ig0 + this->rhopw->npw]) * rhog2[ig0 + this->rhopw->npw]).real());
module_elecstate/module_charge/charge_mixing.cpp:            for (int ig = 0; ig < this->rhopw->npw; ig++)
module_elecstate/module_charge/charge_mixing.cpp:                       * ((conj(rhog1[ig + this->rhopw->npw]) * rhog2[ig + this->rhopw->npw]).real());
module_elecstate/module_charge/charge_mixing.cpp:    if (GlobalV::NSPIN == 4 && this->mixing_angle > 0) resize_tmp = 2;
module_elecstate/module_charge/charge_mixing.cpp:    for (int ir = 0; ir < this->rhopw->nrxx * GlobalV::NSPIN / resize_tmp; ++ir)
module_elecstate/module_charge/charge_mixing.cpp:        data_hf = data_d + this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        const int ndimd = this->rhodpw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        const int ndims = this->rhopw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        const int ndimd = this->rhodpw->npw;
module_elecstate/module_charge/charge_mixing.cpp:        const int ndims = this->rhopw->npw;
module_elecstate/module_charge/charge_mpi.cpp:        this->use_intel_pool = true;
module_elecstate/module_charge/charge_mpi.cpp:        this->use_intel_pool = false;
module_elecstate/module_charge/charge_mpi.cpp:        const int ncxy = this->rhopw->nx * this->rhopw->ny;
module_elecstate/module_charge/charge_mpi.cpp:            rec[ip] = this->rhopw->numz[ip] * ncxy;
module_elecstate/module_charge/charge_mpi.cpp:            dis[ip] = this->rhopw->startz[ip] * ncxy;
module_elecstate/module_charge/charge_mpi.cpp:    if (this->use_intel_pool)
module_elecstate/module_charge/charge_mpi.cpp:        MPI_Allreduce(MPI_IN_PLACE, array_rho, this->nrxx, MPI_DOUBLE, MPI_SUM, INTER_POOL);
module_elecstate/module_charge/charge_mpi.cpp:        double* array_tmp = new double[this->rhopw->nxyz];
module_elecstate/module_charge/charge_mpi.cpp:        double* array_tot = new double[this->rhopw->nxyz];
module_elecstate/module_charge/charge_mpi.cpp:        double* array_tot_aux = new double[this->rhopw->nxyz];
module_elecstate/module_charge/charge_mpi.cpp:        for (int ir = 0; ir < this->rhopw->nrxx; ++ir)
module_elecstate/module_charge/charge_mpi.cpp:        MPI_Allgatherv(array_tmp, this->rhopw->nrxx, MPI_DOUBLE, array_tot, rec, dis, MPI_DOUBLE, POOL_WORLD);
module_elecstate/module_charge/charge_mpi.cpp:        const int ncxy = this->rhopw->nx * this->rhopw->ny;
module_elecstate/module_charge/charge_mpi.cpp:                for (int iz = 0; iz < this->rhopw->numz[ip]; ++iz)
module_elecstate/module_charge/charge_mpi.cpp:                    // is 'this->rhopw->nz'
module_elecstate/module_charge/charge_mpi.cpp:                    // between [ this->rhopw->startz[ip], this->rhopw->startz[ip]+this->rhopw->numz[ip] )
module_elecstate/module_charge/charge_mpi.cpp:                    // (4) this->rhopw->startz[ip] + iz yields correct z coordiante.
module_elecstate/module_charge/charge_mpi.cpp:                    // 'ip' is this->rhopw->numz[ip]
module_elecstate/module_charge/charge_mpi.cpp:                    // this->rhopw->startz[ip] * ncxy.
module_elecstate/module_charge/charge_mpi.cpp:                    array_tot_aux[this->rhopw->nz * ir + this->rhopw->startz[ip] + iz]
module_elecstate/module_charge/charge_mpi.cpp:                        = array_tot[this->rhopw->numz[ip] * ir + this->rhopw->startz[ip] * ncxy + iz];
module_elecstate/module_charge/charge_mpi.cpp:            MPI_Allreduce(array_tot_aux, array_tot, this->rhopw->nxyz, MPI_DOUBLE, MPI_SUM, STO_WORLD);
module_elecstate/module_charge/charge_mpi.cpp:            MPI_Allreduce(array_tot_aux, array_tot, this->rhopw->nxyz, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
module_elecstate/module_charge/charge_mpi.cpp:            for (int iz = 0; iz < this->rhopw->numz[GlobalV::RANK_IN_POOL]; iz++)
module_elecstate/module_charge/charge_mpi.cpp:                array_rho[this->rhopw->numz[GlobalV::RANK_IN_POOL] * ir + iz]
module_elecstate/module_charge/charge_mpi.cpp:                    = array_tot[this->rhopw->nz * ir + this->rhopw->startz_current + iz];
module_elecstate/module_charge/charge_mpi.cpp:        reduce_diff_pools(this->rho[is]);
module_elecstate/module_charge/charge_mpi.cpp:            reduce_diff_pools(this->kin_r[is]);
module_elecstate/module_charge/symmetry_rhog.cpp:	this->reduce_to_fullrhog(rho_basis, rhogtot, rhog_part, ig2isztot, rho_basis->ig2isz, max_npw);
module_elecstate/module_charge/symmetry_rhog.cpp:		this->get_ixyz2ipw(rho_basis, ig2isztot, fftixy2is, ixyz2ipw);	
module_elecstate/module_charge/symmetry_rhog.cpp:		this->get_ixyz2ipw(rho_basis, rho_basis->ig2isz, fftixy2is, ixyz2ipw);	
module_elecstate/module_charge/symmetry_rhog.cpp:	this->rhog_piece_to_all(rho_basis, rhogtot, rhog_part);
module_elecstate/module_dm/density_matrix.cpp:    for (auto& it: this->_DMR)
module_elecstate/module_dm/density_matrix.cpp:    this->_kv = kv_in;
module_elecstate/module_dm/density_matrix.cpp:    this->_paraV = paraV_in;
module_elecstate/module_dm/density_matrix.cpp:    // set this->_nspin
module_elecstate/module_dm/density_matrix.cpp:        this->_nspin = 1;
module_elecstate/module_dm/density_matrix.cpp:        this->_nspin = 2;
module_elecstate/module_dm/density_matrix.cpp:    // set this->_nks, which is real number of k-points
module_elecstate/module_dm/density_matrix.cpp:    this->_nks = kv_in->nks / this->_nspin;
module_elecstate/module_dm/density_matrix.cpp:    this->_DMK.resize(this->_kv->nks);
module_elecstate/module_dm/density_matrix.cpp:    for (int ik = 0; ik < this->_kv->nks; ik++)
module_elecstate/module_dm/density_matrix.cpp:        this->_DMK[ik].resize(this->_paraV->get_row_size() * this->_paraV->get_col_size());
module_elecstate/module_dm/density_matrix.cpp:    ModuleBase::Memory::record("DensityMatrix::DMK", this->_DMK.size() * this->_DMK[0].size() * sizeof(TK));
module_elecstate/module_dm/density_matrix.cpp:    this->_paraV = paraV_in;
module_elecstate/module_dm/density_matrix.cpp:    // set this->_nspin
module_elecstate/module_dm/density_matrix.cpp:        this->_nspin = 1;
module_elecstate/module_dm/density_matrix.cpp:        this->_nspin = 2;
module_elecstate/module_dm/density_matrix.cpp:    // set this->_nks, which is real number of k-points
module_elecstate/module_dm/density_matrix.cpp:    this->_nks = 1;
module_elecstate/module_dm/density_matrix.cpp:    this->_DMK.resize(_nspin);
module_elecstate/module_dm/density_matrix.cpp:    for (int ik = 0; ik < this->_nspin; ik++)
module_elecstate/module_dm/density_matrix.cpp:        this->_DMK[ik].resize(this->_paraV->get_row_size() * this->_paraV->get_col_size());
module_elecstate/module_dm/density_matrix.cpp:    ModuleBase::Memory::record("DensityMatrix::DMK", this->_DMK.size() * this->_DMK[0].size() * sizeof(TK));
module_elecstate/module_dm/density_matrix.cpp:    for (auto& it: this->_DMR)
module_elecstate/module_dm/density_matrix.cpp:    this->_DMR.clear();
module_elecstate/module_dm/density_matrix.cpp:    tmp_DMR = new hamilt::HContainer<TR>(this->_paraV);
module_elecstate/module_dm/density_matrix.cpp:            if (this->_paraV->get_row_size(iat1) <= 0 || this->_paraV->get_col_size(iat2) <= 0)
module_elecstate/module_dm/density_matrix.cpp:            hamilt::AtomPair<TR> tmp_ap(iat1, iat2, R_index.x, R_index.y, R_index.z, this->_paraV);
module_elecstate/module_dm/density_matrix.cpp:    this->_DMR.push_back(tmp_DMR);
module_elecstate/module_dm/density_matrix.cpp:    if (this->_nspin == 2)
module_elecstate/module_dm/density_matrix.cpp:        this->_DMR.push_back(tmp_DMR1);
module_elecstate/module_dm/density_matrix.cpp:    ModuleBase::Memory::record("DensityMatrix::DMR", this->_DMR.size() * this->_DMR[0]->get_memory_size());
module_elecstate/module_dm/density_matrix.cpp:    for (auto& it: this->_DMR)
module_elecstate/module_dm/density_matrix.cpp:    this->_DMR.clear();
module_elecstate/module_dm/density_matrix.cpp:    tmp_DMR = new hamilt::HContainer<TR>(this->_paraV);
module_elecstate/module_dm/density_matrix.cpp:            if (this->_paraV->get_row_size(iat1) <= 0 || this->_paraV->get_col_size(iat2) <= 0)
module_elecstate/module_dm/density_matrix.cpp:            hamilt::AtomPair<TR> tmp_ap(iat1, iat2, ra.info[iat1][ad][0], ra.info[iat1][ad][1], ra.info[iat1][ad][2], this->_paraV);
module_elecstate/module_dm/density_matrix.cpp:    this->_DMR.push_back(tmp_DMR);
module_elecstate/module_dm/density_matrix.cpp:    if (this->_nspin == 2)
module_elecstate/module_dm/density_matrix.cpp:        this->_DMR.push_back(tmp_DMR1);
module_elecstate/module_dm/density_matrix.cpp:    ModuleBase::Memory::record("DensityMatrix::DMR", this->_DMR.size() * this->_DMR[0]->get_memory_size());
module_elecstate/module_dm/density_matrix.cpp:    for (auto& it: this->_DMR)
module_elecstate/module_dm/density_matrix.cpp:    this->_DMR.clear();
module_elecstate/module_dm/density_matrix.cpp:    for (int is = 0; is < this->_nspin; ++is) // loop over spin
module_elecstate/module_dm/density_matrix.cpp:        this->_DMR.push_back(tmp_DMR);
module_elecstate/module_dm/density_matrix.cpp:    ModuleBase::Memory::record("DensityMatrix::DMR", this->_DMR.size() * this->_DMR[0]->get_memory_size());
module_elecstate/module_dm/density_matrix.cpp:    for (auto& it: this->_DMR)
module_elecstate/module_dm/density_matrix.cpp:    this->_DMR.clear();
module_elecstate/module_dm/density_matrix.cpp:        this->_DMR.push_back(tmp_DMR);
module_elecstate/module_dm/density_matrix.cpp:        if(this->_nspin == 2)
module_elecstate/module_dm/density_matrix.cpp:            this->_DMR.push_back(tmp_DMR1);
module_elecstate/module_dm/density_matrix.cpp:    ModuleBase::Memory::record("DensityMatrix::DMR", this->_DMR.size() * this->_DMR[0]->get_memory_size());
module_elecstate/module_dm/density_matrix.cpp:    assert(ispin > 0 && ispin <= this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:    return this->_DMR[ispin - 1];
module_elecstate/module_dm/density_matrix.cpp:    assert(ik < this->_nks * this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:    return const_cast<TK*>(this->_DMK[ik].data());
module_elecstate/module_dm/density_matrix.cpp:    assert(ik < this->_nks * this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:    this->_DMK[ik].assign(DMK_in, DMK_in + this->_paraV->nrow * this->_paraV->ncol);
module_elecstate/module_dm/density_matrix.cpp:    assert(ispin > 0 && ispin <= this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:    assert(ik >= 0 && ik < this->_nks);
module_elecstate/module_dm/density_matrix.cpp:    this->_DMK[ik + this->_nks * (ispin - 1)][i * this->_paraV->nrow + j] = value;
module_elecstate/module_dm/density_matrix.cpp:        ModuleBase::GlobalFunc::ZEROS(this->_DMK[ik].data(), this->_paraV->get_row_size() * this->_paraV->get_col_size());
module_elecstate/module_dm/density_matrix.cpp:    assert(ispin > 0 && ispin <= this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:    return this->_DMK[ik + this->_nks * (ispin - 1)][i * this->_paraV->nrow + j];
module_elecstate/module_dm/density_matrix.cpp:    assert(this->_DMK.size() != 0);
module_elecstate/module_dm/density_matrix.cpp:    assert(this->_kv != nullptr);
module_elecstate/module_dm/density_matrix.cpp:    return this->_kv->nks;
module_elecstate/module_dm/density_matrix.cpp:    assert(this->_DMK.size() != 0);
module_elecstate/module_dm/density_matrix.cpp:    return this->_DMK.size();
module_elecstate/module_dm/density_matrix.cpp:    assert(this->_DMK.size() != 0);
module_elecstate/module_dm/density_matrix.cpp:    return this->_paraV->nrow;
module_elecstate/module_dm/density_matrix.cpp:    assert(this->_DMK.size() != 0);
module_elecstate/module_dm/density_matrix.cpp:    return this->_paraV->ncol;
module_elecstate/module_dm/density_matrix.cpp:    const int nnr = this->_DMR[0]->get_nnr();
module_elecstate/module_dm/density_matrix.cpp:        _DMR_save.resize(this->_DMR.size());
module_elecstate/module_dm/density_matrix.cpp:    for(int is=0;is<this->_DMR.size();is++)
module_elecstate/module_dm/density_matrix.cpp:        TR* DMR_pointer = this->_DMR[is]->get_wrapper();
module_elecstate/module_dm/density_matrix.cpp:    for (int is = 1; is <= this->_nspin; ++is)
module_elecstate/module_dm/density_matrix.cpp:        int ik_begin = this->_nks*(is-1); // jump this->_nks for spin_down if nspin==2
module_elecstate/module_dm/density_matrix.cpp:        hamilt::HContainer<TR>* tmp_DMR = this->_DMR[is-1];
module_elecstate/module_dm/density_matrix.cpp:            int row_ap = this->_paraV->atom_begin_row[iat1];
module_elecstate/module_dm/density_matrix.cpp:            int col_ap = this->_paraV->atom_begin_col[iat2];
module_elecstate/module_dm/density_matrix.cpp:                for (int ik = 0; ik < this->_nks; ++ik)
module_elecstate/module_dm/density_matrix.cpp:                    const double arg = (this->_kv->kvec_d[ik] * dR) * ModuleBase::TWO_PI;
module_elecstate/module_dm/density_matrix.cpp:                    for (int i = 0; i < this->_paraV->get_row_size(iat1); ++i)
module_elecstate/module_dm/density_matrix.cpp:                        for (int j = 0; j < this->_paraV->get_col_size(iat2); ++j)
module_elecstate/module_dm/density_matrix.cpp:                            tmp_res = kphase * this->_DMK[ik_begin+ik][(col_ap+j)*this->_paraV->nrow+row_ap+i];
module_elecstate/module_dm/density_matrix.cpp:    int ld_hk = this->_paraV->nrow;
module_elecstate/module_dm/density_matrix.cpp:    for (int is = 1; is <= this->_nspin; ++is)
module_elecstate/module_dm/density_matrix.cpp:        int ik_begin = this->_nks * (is - 1); // jump this->_nks for spin_down if nspin==2
module_elecstate/module_dm/density_matrix.cpp:        hamilt::HContainer<double>* tmp_DMR = this->_DMR[is - 1];
module_elecstate/module_dm/density_matrix.cpp:            int row_ap = this->_paraV->atom_begin_row[iat1];
module_elecstate/module_dm/density_matrix.cpp:            int col_ap = this->_paraV->atom_begin_col[iat2];
module_elecstate/module_dm/density_matrix.cpp:					for (int ik = 0; ik < this->_nks; ++ik)
module_elecstate/module_dm/density_matrix.cpp:						const double arg = (this->_kv->kvec_d[ik] * dR) * ModuleBase::TWO_PI;
module_elecstate/module_dm/density_matrix.cpp:						std::complex<double>* tmp_DMK_pointer = this->_DMK[ik + ik_begin].data();
module_elecstate/module_dm/density_matrix.cpp:						tmp_DMK_pointer += col_ap * this->_paraV->nrow + row_ap;
module_elecstate/module_dm/density_matrix.cpp:						for (int mu = 0; mu < this->_paraV->get_row_size(iat1); ++mu)
module_elecstate/module_dm/density_matrix.cpp:							BlasConnector::axpy(this->_paraV->get_col_size(iat2),
module_elecstate/module_dm/density_matrix.cpp:							BlasConnector::axpy(this->_paraV->get_col_size(iat2),
module_elecstate/module_dm/density_matrix.cpp:							tmp_DMR_pointer += this->_paraV->get_col_size(iat2);
module_elecstate/module_dm/density_matrix.cpp:                    std::vector<std::complex<double>> tmp_DMR(this->_paraV->get_col_size() * this->_paraV->get_row_size(), std::complex<double>(0.0, 0.0));
module_elecstate/module_dm/density_matrix.cpp:                    for (int ik = 0; ik < this->_nks; ++ik)
module_elecstate/module_dm/density_matrix.cpp:                        const double arg = (this->_kv->kvec_d[ik] * dR) * ModuleBase::TWO_PI;
module_elecstate/module_dm/density_matrix.cpp:                        std::complex<double>* tmp_DMK_pointer = this->_DMK[ik + ik_begin].data();
module_elecstate/module_dm/density_matrix.cpp:                        tmp_DMK_pointer += col_ap * this->_paraV->nrow + row_ap;
module_elecstate/module_dm/density_matrix.cpp:                        for (int mu = 0; mu < this->_paraV->get_row_size(iat1); ++mu)
module_elecstate/module_dm/density_matrix.cpp:                            BlasConnector::axpy(this->_paraV->get_col_size(iat2),
module_elecstate/module_dm/density_matrix.cpp:                            tmp_DMR_pointer += this->_paraV->get_col_size(iat2);
module_elecstate/module_dm/density_matrix.cpp:                            step_trace[is * npol + is2] = this->_paraV->get_col_size(iat2) * is + is2;
module_elecstate/module_dm/density_matrix.cpp:                            //step_trace[is + is2 * npol] = this->_paraV->get_col_size(iat2) * is + is2;
module_elecstate/module_dm/density_matrix.cpp:                    for(int irow=0;irow<this->_paraV->get_row_size(iat1);irow += 2)
module_elecstate/module_dm/density_matrix.cpp:                        for(int icol=0;icol<this->_paraV->get_col_size(iat2);icol += 2)
module_elecstate/module_dm/density_matrix.cpp:                        tmp_DMR_pointer += this->_paraV->get_col_size(iat2) * 2;
module_elecstate/module_dm/density_matrix.cpp:                        target_DMR += this->_paraV->get_col_size(iat2) * 2;
module_elecstate/module_dm/density_matrix.cpp:    int ld_hk = this->_paraV->nrow;
module_elecstate/module_dm/density_matrix.cpp:    for (int is = 1; is <= this->_nspin; ++is)
module_elecstate/module_dm/density_matrix.cpp:        int ik_begin = this->_nks * (is - 1); // jump this->_nks for spin_down if nspin==2
module_elecstate/module_dm/density_matrix.cpp:        hamilt::HContainer<double>* tmp_DMR = this->_DMR[is - 1];
module_elecstate/module_dm/density_matrix.cpp:        assert(this->_nks == 1);
module_elecstate/module_dm/density_matrix.cpp:            int row_ap = this->_paraV->atom_begin_row[iat1];
module_elecstate/module_dm/density_matrix.cpp:            int col_ap = this->_paraV->atom_begin_col[iat2];
module_elecstate/module_dm/density_matrix.cpp:            double* tmp_DMK_pointer = this->_DMK[0 + ik_begin].data();
module_elecstate/module_dm/density_matrix.cpp:            tmp_DMK_pointer += col_ap * this->_paraV->nrow + row_ap;
module_elecstate/module_dm/density_matrix.cpp:            for (int mu = 0; mu < this->_paraV->get_row_size(iat1); ++mu)
module_elecstate/module_dm/density_matrix.cpp:                BlasConnector::axpy(this->_paraV->get_col_size(iat2), kphase, tmp_DMK_pointer, ld_hk, tmp_DMR_pointer, 1);
module_elecstate/module_dm/density_matrix.cpp:                tmp_DMR_pointer += this->_paraV->get_col_size(iat2);
module_elecstate/module_dm/density_matrix.cpp:    if (this->_nspin == 1)
module_elecstate/module_dm/density_matrix.cpp:    if (this->_nspin == 2)
module_elecstate/module_dm/density_matrix.cpp:        hamilt::HContainer<double>* tmp_DMR_up = this->_DMR[0];
module_elecstate/module_dm/density_matrix.cpp:        hamilt::HContainer<double>* tmp_DMR_down = this->_DMR[1];
module_elecstate/module_dm/density_matrix.cpp:    assert(ispin > 0 && ispin <= this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:        ModuleBase::CHECK_DOUBLE(ifs, this->_kv->kvec_d[ik].x, quit);
module_elecstate/module_dm/density_matrix.cpp:        ModuleBase::CHECK_DOUBLE(ifs, this->_kv->kvec_d[ik].y, quit);
module_elecstate/module_dm/density_matrix.cpp:        ModuleBase::CHECK_DOUBLE(ifs, this->_kv->kvec_d[ik].z, quit);
module_elecstate/module_dm/density_matrix.cpp:        ModuleBase::CHECK_INT(ifs, this->_paraV->nrow);
module_elecstate/module_dm/density_matrix.cpp:        ModuleBase::CHECK_INT(ifs, this->_paraV->ncol);
module_elecstate/module_dm/density_matrix.cpp:    for (int i = 0; i < this->_paraV->nrow; ++i)
module_elecstate/module_dm/density_matrix.cpp:        for (int j = 0; j < this->_paraV->ncol; ++j)
module_elecstate/module_dm/density_matrix.cpp:            ifs >> this->_DMK[ik + this->_nks * (ispin - 1)][i * this->_paraV->ncol + j];
module_elecstate/module_dm/density_matrix.cpp:    assert(ispin > 0 && ispin <= this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:    ofs << this->_kv->kvec_d[ik].x << " " << this->_kv->kvec_d[ik].y << " " << this->_kv->kvec_d[ik].z << std::endl;
module_elecstate/module_dm/density_matrix.cpp:    ofs << "\n  " << this->_paraV->nrow << " " << this->_paraV->ncol << std::endl;
module_elecstate/module_dm/density_matrix.cpp:    for (int i = 0; i < this->_paraV->nrow; ++i)
module_elecstate/module_dm/density_matrix.cpp:        for (int j = 0; j < this->_paraV->ncol; ++j)
module_elecstate/module_dm/density_matrix.cpp:            ofs << " " << this->_DMK[ik + this->_nks * (ispin - 1)][i * this->_paraV->ncol + j];
module_elecstate/module_dm/density_matrix.cpp:    assert(ispin > 0 && ispin <= this->_nspin);
module_elecstate/module_dm/density_matrix.cpp:    ofs << this->_kv->kvec_d[ik].x << " " << this->_kv->kvec_d[ik].y << " " << this->_kv->kvec_d[ik].z << std::endl;
module_elecstate/module_dm/density_matrix.cpp:    ofs << "\n  " << this->_paraV->nrow << " " << this->_paraV->ncol << std::endl;
module_elecstate/module_dm/density_matrix.cpp:    for (int i = 0; i < this->_paraV->nrow; ++i)
module_elecstate/module_dm/density_matrix.cpp:        for (int j = 0; j < this->_paraV->ncol; ++j)
module_elecstate/module_dm/density_matrix.cpp:            ofs << " " << this->_DMK[ik + this->_nks * (ispin - 1)][i * this->_paraV->ncol + j].real();
module_elecstate/module_dm/density_matrix.h:    const std::vector<hamilt::HContainer<TR>*>& get_DMR_vector() const {return this->_DMR;}
module_elecstate/module_dm/density_matrix.h:    std::vector<hamilt::HContainer<TR>*>& get_DMR_vector() {return this->_DMR;}
module_elecstate/module_dm/density_matrix.h:    const std::vector<std::vector<TR>>& get_DMR_save() const {return this->_DMR_save;}
module_elecstate/module_dm/density_matrix.h:    std::vector<std::vector<TR>>& get_DMR_save() {return this->_DMR_save;}
module_elecstate/module_dm/density_matrix.h:    const std::vector<std::vector<TK>>& get_DMK_vector() const {return this->_DMK;}
module_elecstate/module_dm/density_matrix.h:    std::vector<std::vector<TK>>& get_DMK_vector() {return this->_DMK;}
module_elecstate/module_dm/density_matrix.h:    const Parallel_Orbitals* get_paraV_pointer() const {return this->_paraV;}
module_elecstate/module_dm/density_matrix.h:    const K_Vectors* get_kv_pointer() const {return this->_kv;}
module_elecstate/module_dm/test/prepare_unitcell.h:        this->ntype = this->elements.size();
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.setup(this->latname, this->ntype, this->lmaxmax, this->init_vel, this->fixed_axes);
module_elecstate/module_dm/test/prepare_unitcell.h:            ucell.atom_label[it] = this->elements[it];
module_elecstate/module_dm/test/prepare_unitcell.h:            ucell.atom_mass[it] = this->atomic_mass[it];
module_elecstate/module_dm/test/prepare_unitcell.h:            ucell.pseudo_fn[it] = this->pp_files[it];
module_elecstate/module_dm/test/prepare_unitcell.h:            ucell.pseudo_type[it] = this->pp_types[it];
module_elecstate/module_dm/test/prepare_unitcell.h:            ucell.orbital_fn[it] = this->orb_files[it];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.lat0 = this->lat0;
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e11 = this->latvec[0];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e12 = this->latvec[1];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e13 = this->latvec[2];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e21 = this->latvec[3];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e22 = this->latvec[4];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e23 = this->latvec[5];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e31 = this->latvec[6];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e32 = this->latvec[7];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.latvec.e33 = this->latvec[8];
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.Coordinate = this->coor_type;
module_elecstate/module_dm/test/prepare_unitcell.h:        this->atomic_index = 0;
module_elecstate/module_dm/test/prepare_unitcell.h:            ucell.atoms[it].label = this->elements[it];
module_elecstate/module_dm/test/prepare_unitcell.h:            ucell.atoms[it].na = this->natom[it];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].taud[ia].x = this->coordinates[this->atomic_index * 3 + 0];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].taud[ia].y = this->coordinates[this->atomic_index * 3 + 1];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].taud[ia].z = this->coordinates[this->atomic_index * 3 + 2];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].x = this->coordinates[this->atomic_index * 3 + 0];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].y = this->coordinates[this->atomic_index * 3 + 1];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].z = this->coordinates[this->atomic_index * 3 + 2];
module_elecstate/module_dm/test/prepare_unitcell.h:                if (this->init_vel)
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].vel[ia].x = this->velocity[this->atomic_index * 3 + 0];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].vel[ia].y = this->velocity[this->atomic_index * 3 + 1];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].vel[ia].z = this->velocity[this->atomic_index * 3 + 2];
module_elecstate/module_dm/test/prepare_unitcell.h:                if (this->selective_dynamics)
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].mbl[ia].x = this->mbl[this->atomic_index * 3 + 0];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].mbl[ia].y = this->mbl[this->atomic_index * 3 + 1];
module_elecstate/module_dm/test/prepare_unitcell.h:                    ucell.atoms[it].mbl[ia].z = this->mbl[this->atomic_index * 3 + 2];
module_elecstate/module_dm/test/prepare_unitcell.h:                ++(this->atomic_index);
module_elecstate/module_dm/test/prepare_unitcell.h:        ucell.nat = this->natom.sum();
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // set this->_DMK
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // initialize this->_DMR
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // calculate this->_DMR
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // set this->_DMK
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // initialize this->_DMR
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // calculate this->_DMR
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // set this->_DMK
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // initialize this->_DMR
module_elecstate/module_dm/test/test_cal_dm_R.cpp:    // calculate this->_DMR
module_elecstate/module_dm/test/test_dm_R_init.cpp:    // initialize this->_DMR
module_elecstate/module_dm/test/test_dm_io.cpp:    this->tot_magnetization = 0.0;
module_elecstate/module_dm/test/test_dm_io.cpp:    this->abs_magnetization = 0.0;
module_elecstate/module_dm/test/test_dm_io.cpp:    this->start_magnetization = nullptr;
module_elecstate/module_dm/test/test_dm_io.cpp:    delete[] this->start_magnetization;
module_elecstate/module_dm/test/tmp_mocks.cpp:    this->iat2iwt.resize(this->nat);
module_elecstate/module_dm/test/tmp_mocks.cpp:    this->npol = npol_in;
module_elecstate/module_dm/test/tmp_mocks.cpp:    for (int it = 0; it < this->ntype; it++)
module_elecstate/module_dm/test/tmp_mocks.cpp:            this->iat2iwt[iat] = iwt;
module_elecstate/module_dm/test/tmp_mocks.cpp:            iwt += atoms[it].nw * this->npol;
module_elecstate/potentials/H_Hartree_pw.cpp:    this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/H_Hartree_pw.cpp:    this->dynamic_mode = true;
module_elecstate/potentials/H_Hartree_pw.cpp:    this->fixed_mode = false;
module_elecstate/potentials/H_Hartree_pw.cpp:        v_eff += H_Hartree_pw::v_hartree(*ucell, const_cast<ModulePW::PW_Basis*>(this->rho_basis_), v_eff.nr, rho_tmp);
module_elecstate/potentials/H_Hartree_pw.cpp:        v_eff += H_Hartree_pw::v_hartree(*ucell, const_cast<ModulePW::PW_Basis*>(this->rho_basis_), v_eff.nr, chg->rho);
module_elecstate/potentials/H_TDDFT_pw.cpp:        std::vector<double> vext_space(this->rho_basis_->nrxx, 0.0);
module_elecstate/potentials/H_TDDFT_pw.cpp:        for (size_t ir = 0; ir < this->rho_basis_->nrxx; ++ir)
module_elecstate/potentials/H_TDDFT_pw.cpp:    for (int ir = 0; ir < this->rho_basis_->nrxx; ++ir)
module_elecstate/potentials/H_TDDFT_pw.cpp:        int i = ir / (this->rho_basis_->ny * this->rho_basis_->nplane);
module_elecstate/potentials/H_TDDFT_pw.cpp:        int j = ir / this->rho_basis_->nplane - i * this->rho_basis_->ny;
module_elecstate/potentials/H_TDDFT_pw.cpp:        int k = ir % this->rho_basis_->nplane + this->rho_basis_->startz_current;
module_elecstate/potentials/H_TDDFT_pw.cpp:        double x = (double)i / this->rho_basis_->nx;
module_elecstate/potentials/H_TDDFT_pw.cpp:        double y = (double)j / this->rho_basis_->ny;
module_elecstate/potentials/H_TDDFT_pw.cpp:        double z = (double)k / this->rho_basis_->nz;
module_elecstate/potentials/H_TDDFT_pw.cpp:        vext_space = ((i - lcut1) * (lcut2 - lcut1) / (lcut1 + 1.0 - lcut2) - lcut1) * this->ucell_->lat0;
module_elecstate/potentials/H_TDDFT_pw.cpp:        vext_space = -i * this->ucell_->lat0;
module_elecstate/potentials/H_TDDFT_pw.cpp:        vext_space = ((i - lcut2) * (lcut2 - lcut1) / (lcut1 + 1.0 - lcut2) - lcut2) * this->ucell_->lat0;
module_elecstate/potentials/H_TDDFT_pw.h:        this->dynamic_mode = false;
module_elecstate/potentials/H_TDDFT_pw.h:        this->fixed_mode = true;
module_elecstate/potentials/H_TDDFT_pw.h:        this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/efield.h:        this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/efield.h:            this->fixed_mode = true;
module_elecstate/potentials/efield.h:            this->dynamic_mode = false;
module_elecstate/potentials/efield.h:            this->fixed_mode = false;
module_elecstate/potentials/efield.h:            this->dynamic_mode = true;
module_elecstate/potentials/gatefield.h:        this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/gatefield.h:        this->fixed_mode = true;
module_elecstate/potentials/gatefield.h:        this->dynamic_mode = false;
module_elecstate/potentials/gatefield.h:        Gatefield::add_gatefield(vl_pseudo, *ucell_, this->rho_basis_, true, true);
module_elecstate/potentials/pot_local.cpp:    std::complex<double> *vg = new std::complex<double>[this->rho_basis_->npw];
module_elecstate/potentials/pot_local.cpp:    ModuleBase::GlobalFunc::ZEROS(vg, this->rho_basis_->npw);
module_elecstate/potentials/pot_local.cpp:    for (int it = 0; it < this->ntype_; it++)
module_elecstate/potentials/pot_local.cpp:        for (int ig = 0; ig < this->rho_basis_->npw; ig++)
module_elecstate/potentials/pot_local.cpp:            vg[ig] += this->vloc_[0](it, this->rho_basis_->ig2igg[ig]) * this->sf_[0](it, ig);
module_elecstate/potentials/pot_local.cpp:    const_cast<ModulePW::PW_Basis *>(this->rho_basis_)->recip2real(vg, vl_pseudo);
module_elecstate/potentials/pot_local.h:        assert(this->vloc_->nr == this->sf_->nr);
module_elecstate/potentials/pot_local.h:        this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/pot_local.h:        this->ntype_ = this->vloc_->nr;
module_elecstate/potentials/pot_local.h:        this->fixed_mode = true;
module_elecstate/potentials/pot_local.h:        this->dynamic_mode = false;
module_elecstate/potentials/pot_local_paw.h:      this->fixed_mode = true;
module_elecstate/potentials/pot_local_paw.h:      this->dynamic_mode = false;
module_elecstate/potentials/pot_surchem.hpp:        this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/pot_surchem.hpp:        this->structure_factors_ = structure_factors_in;
module_elecstate/potentials/pot_surchem.hpp:        this->dynamic_mode = true;
module_elecstate/potentials/pot_surchem.hpp:        this->fixed_mode = false;
module_elecstate/potentials/pot_surchem.hpp:        if (this->allocated)
module_elecstate/potentials/pot_surchem.hpp:            this->surchem_->clear();
module_elecstate/potentials/pot_surchem.hpp:        if (!this->allocated)
module_elecstate/potentials/pot_surchem.hpp:            this->surchem_->allocate(this->rho_basis_->nrxx, v_eff.nr);
module_elecstate/potentials/pot_surchem.hpp:            this->allocated = true;
module_elecstate/potentials/pot_surchem.hpp:        v_eff += this->surchem_->v_correction(*ucell,
module_elecstate/potentials/pot_surchem.hpp:                                              const_cast<ModulePW::PW_Basis*>(this->rho_basis_),
module_elecstate/potentials/pot_surchem.hpp:                                              this->vlocal,
module_elecstate/potentials/pot_surchem.hpp:                                              this->structure_factors_);
module_elecstate/potentials/pot_xc.cpp:        *(this->etxc_) = std::get<0>(etxc_vtxc_v);
module_elecstate/potentials/pot_xc.cpp:        *(this->vtxc_) = std::get<1>(etxc_vtxc_v);
module_elecstate/potentials/pot_xc.cpp:        *(this->vofk) = std::get<3>(etxc_vtxc_v);
module_elecstate/potentials/pot_xc.cpp:        *(this->etxc_) = std::get<0>(etxc_vtxc_v);
module_elecstate/potentials/pot_xc.cpp:        *(this->vtxc_) = std::get<1>(etxc_vtxc_v);
module_elecstate/potentials/pot_xc.h:        this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/pot_xc.h:        this->dynamic_mode = true;
module_elecstate/potentials/pot_xc.h:        this->fixed_mode = false;
module_elecstate/potentials/potential_new.cpp:    this->rho_basis_ = rho_basis_in;
module_elecstate/potentials/potential_new.cpp:    this->rho_basis_smooth_ = rho_basis_smooth_in;
module_elecstate/potentials/potential_new.cpp:    this->fixed_mode = true;
module_elecstate/potentials/potential_new.cpp:    this->dynamic_mode = true;
module_elecstate/potentials/potential_new.cpp:    this->allocate();
module_elecstate/potentials/potential_new.cpp:    if (this->components.size() > 0)
module_elecstate/potentials/potential_new.cpp:        for (auto comp: this->components)
module_elecstate/potentials/potential_new.cpp:        this->components.clear();
module_elecstate/potentials/potential_new.cpp:    if (this->components.size() > 0)
module_elecstate/potentials/potential_new.cpp:        for (auto comp: this->components)
module_elecstate/potentials/potential_new.cpp:        this->components.clear();
module_elecstate/potentials/potential_new.cpp:        PotBase* tmp = this->get_pot_type(comp);
module_elecstate/potentials/potential_new.cpp:        this->components.push_back(tmp);
module_elecstate/potentials/potential_new.cpp:    this->fixed_done = false;
module_elecstate/potentials/potential_new.cpp:    int nrxx = this->rho_basis_->nrxx;
module_elecstate/potentials/potential_new.cpp:    int nrxx_smooth = this->rho_basis_smooth_->nrxx;
module_elecstate/potentials/potential_new.cpp:    this->v_effective_fixed.resize(nrxx);
module_elecstate/potentials/potential_new.cpp:    this->v_effective.create(GlobalV::NSPIN, nrxx);
module_elecstate/potentials/potential_new.cpp:    this->veff_smooth.create(GlobalV::NSPIN, nrxx_smooth);
module_elecstate/potentials/potential_new.cpp:        this->v_xc.create(GlobalV::NSPIN, nrxx);
module_elecstate/potentials/potential_new.cpp:        this->vofk_effective.create(GlobalV::NSPIN, nrxx);
module_elecstate/potentials/potential_new.cpp:        this->vofk_smooth.create(GlobalV::NSPIN, nrxx_smooth);
module_elecstate/potentials/potential_new.cpp:            this->d_veff_smooth = this->veff_smooth.c;
module_elecstate/potentials/potential_new.cpp:            this->d_vofk_smooth = this->vofk_smooth.c;
module_elecstate/potentials/potential_new.cpp:    if (!this->fixed_done)
module_elecstate/potentials/potential_new.cpp:        this->cal_fixed_v(this->v_effective_fixed.data());
module_elecstate/potentials/potential_new.cpp:        this->fixed_done = true;
module_elecstate/potentials/potential_new.cpp:    this->cal_v_eff(chg, ucell, this->v_effective);
module_elecstate/potentials/potential_new.cpp:    this->interpolate_vrs();
module_elecstate/potentials/potential_new.cpp:        this->v_xc.zero_out();
module_elecstate/potentials/potential_new.cpp:                                 this->veff_smooth.c,
module_elecstate/potentials/potential_new.cpp:                                 this->veff_smooth.nr * this->veff_smooth.nc);
module_elecstate/potentials/potential_new.cpp:                                 this->vofk_smooth.c,
module_elecstate/potentials/potential_new.cpp:                                 this->vofk_smooth.nr * this->vofk_smooth.nc);
module_elecstate/potentials/potential_new.cpp:                                 this->veff_smooth.c,
module_elecstate/potentials/potential_new.cpp:                                 this->veff_smooth.nr * this->veff_smooth.nc);
module_elecstate/potentials/potential_new.cpp:                                 this->vofk_smooth.c,
module_elecstate/potentials/potential_new.cpp:                                 this->vofk_smooth.nr * this->vofk_smooth.nc);
module_elecstate/potentials/potential_new.cpp:                                 this->veff_smooth.c,
module_elecstate/potentials/potential_new.cpp:                                 this->veff_smooth.nr * this->veff_smooth.nc);
module_elecstate/potentials/potential_new.cpp:                                 this->vofk_smooth.c,
module_elecstate/potentials/potential_new.cpp:                                 this->vofk_smooth.nr * this->vofk_smooth.nc);
module_elecstate/potentials/potential_new.cpp:    this->v_effective_fixed.assign(this->v_effective_fixed.size(), 0.0);
module_elecstate/potentials/potential_new.cpp:    for (size_t i = 0; i < this->components.size(); i++)
module_elecstate/potentials/potential_new.cpp:        if (this->components[i]->fixed_mode)
module_elecstate/potentials/potential_new.cpp:            this->components[i]->cal_fixed_v(vl_pseudo);
module_elecstate/potentials/potential_new.cpp:    int nspin_current = this->v_effective.nr;
module_elecstate/potentials/potential_new.cpp:    int nrxx = this->v_effective.nc;
module_elecstate/potentials/potential_new.cpp:    this->v_effective.zero_out();
module_elecstate/potentials/potential_new.cpp:            ModuleBase::GlobalFunc::COPYARRAY(this->v_effective_fixed.data(), this->get_effective_v(i), nrxx);
module_elecstate/potentials/potential_new.cpp:    for (size_t i = 0; i < this->components.size(); i++)
module_elecstate/potentials/potential_new.cpp:        if (this->components[i]->dynamic_mode)
module_elecstate/potentials/potential_new.cpp:            this->components[i]->cal_v_eff(chg, ucell, v_eff);
module_elecstate/potentials/potential_new.cpp:    this->fixed_done = false;
module_elecstate/potentials/potential_new.cpp:    this->update_from_charge(chg, this->ucell_);
module_elecstate/potentials/potential_new.cpp:    // figure::picture(this->vr_eff1,GlobalC::rhopw->nx,GlobalC::rhopw->ny,GlobalC::rhopw->nz);
module_elecstate/potentials/potential_new.cpp:    vnew.create(this->v_effective.nr, this->v_effective.nc);
module_elecstate/potentials/potential_new.cpp:    vnew = this->v_effective;
module_elecstate/potentials/potential_new.cpp:    this->update_from_charge(chg, this->ucell_);
module_elecstate/potentials/potential_new.cpp:        vnew.c[iter] = this->v_effective.c[iter] - vnew.c[iter];
module_elecstate/potentials/potential_new.cpp:        this->veff_smooth = this->v_effective;
module_elecstate/potentials/potential_new.cpp:        this->vofk_smooth = this->vofk_effective;
module_elecstate/potentials/potential_new.cpp:    return this->veff_smooth.nc > 0 ? this->s_veff_smooth : nullptr;
module_elecstate/potentials/potential_new.cpp:    return this->veff_smooth.nc > 0 ? this->d_veff_smooth : nullptr;
module_elecstate/potentials/potential_new.cpp:    return this->vofk_smooth.nc > 0 ? this->s_vofk_smooth : nullptr;
module_elecstate/potentials/potential_new.cpp:    return this->vofk_smooth.nc > 0 ? this->d_vofk_smooth : nullptr;
module_elecstate/potentials/potential_new.h:        return this->v_effective;
module_elecstate/potentials/potential_new.h:        return this->v_effective;
module_elecstate/potentials/potential_new.h:        if (this->v_effective.nc > 0)
module_elecstate/potentials/potential_new.h:            return &(this->v_effective(is, 0));
module_elecstate/potentials/potential_new.h:        if (this->v_effective.nc > 0)
module_elecstate/potentials/potential_new.h:            return &(this->v_effective(is, 0));
module_elecstate/potentials/potential_new.h:        return this->vofk_effective;
module_elecstate/potentials/potential_new.h:        return this->vofk_effective;
module_elecstate/potentials/potential_new.h:        if (this->vofk_effective.nc > 0)
module_elecstate/potentials/potential_new.h:            return &(this->vofk_effective(is, 0));
module_elecstate/potentials/potential_new.h:        if (this->vofk_effective.nc > 0)
module_elecstate/potentials/potential_new.h:            return &(this->vofk_effective(is, 0));
module_elecstate/potentials/potential_new.h:        return this->veff_smooth;
module_elecstate/potentials/potential_new.h:        return this->veff_smooth;
module_elecstate/potentials/potential_new.h:        return this->vofk_smooth;
module_elecstate/potentials/potential_new.h:        return this->vofk_smooth;
module_elecstate/potentials/potential_new.h:        return this->v_effective_fixed.data();
module_elecstate/potentials/potential_new.h:        return this->v_effective_fixed.data();
module_elecstate/potentials/potential_types.cpp:            return new PotLocal(this->vloc_, &(this->structure_factors_->strucFac), this->rho_basis_);
module_elecstate/potentials/potential_types.cpp:        return new PotHartree(this->rho_basis_);
module_elecstate/potentials/potential_types.cpp:        return new PotXC(this->rho_basis_, this->etxc_, this->vtxc_, &(this->vofk_effective));
module_elecstate/potentials/potential_types.cpp:        return new PotSurChem(this->rho_basis_,
module_elecstate/potentials/potential_types.cpp:                              this->structure_factors_,
module_elecstate/potentials/potential_types.cpp:                              this->v_effective_fixed.data(),
module_elecstate/potentials/potential_types.cpp:        return new PotEfield(this->rho_basis_, this->ucell_, GlobalV::DIP_COR_FLAG);
module_elecstate/potentials/potential_types.cpp:        return new PotGate(this->rho_basis_, this->ucell_);
module_elecstate/potentials/potential_types.cpp:        return new H_TDDFT_pw(this->rho_basis_, this->ucell_);
module_elecstate/test/charge_extra_test.cpp:    this->start_magnetization = nullptr;
module_elecstate/test/charge_extra_test.cpp:    delete[] this->start_magnetization;
module_elecstate/test/charge_mixing_test.cpp:    this->rhopw = rhopw_in;
module_elecstate/test/charge_mixing_test.cpp:        double gg = this->pw_basis.gg[i];
module_elecstate/test/charge_mixing_test.cpp:        double gg = this->pw_basis.gg[i];
module_elecstate/test/charge_mixing_test.cpp:        double gg = this->pw_basis.gg[i];
module_elecstate/test/charge_mixing_test.cpp:        double gg = this->pw_basis.gg[i];
module_elecstate/test/charge_mixing_test.cpp:        double gg = this->pw_basis.gg[i];
module_elecstate/test/charge_mixing_test.cpp:        double gg = this->pw_basis.gg[i];
module_elecstate/test/charge_test.cpp:    this->tot_magnetization = 0.0;
module_elecstate/test/charge_test.cpp:    this->abs_magnetization = 0.0;
module_elecstate/test/charge_test.cpp:    this->start_magnetization = nullptr;
module_elecstate/test/charge_test.cpp:    delete[] this->start_magnetization;
module_elecstate/test/elecstate_base_test.cpp: *      - get the pointer to this->charge->rho
module_elecstate/test/elecstate_energy_test.cpp:    return &(this->eferm.ef);
module_elecstate/test/elecstate_print_test.cpp:    return &(this->eferm.ef);
module_elecstate/test/potential_new_test.cpp:    pot->cal_v_eff(chg,this->ucell,v_eff);
module_elecstate/test/potential_new_test.cpp:    pot->update_from_charge(chg, this->ucell);
module_elecstate/test/prepare_unitcell.h:		this->ntype = this->elements.size();
module_elecstate/test/prepare_unitcell.h:        ucell->setup(this->latname,
module_elecstate/test/prepare_unitcell.h:				this->ntype,
module_elecstate/test/prepare_unitcell.h:				this->lmaxmax,
module_elecstate/test/prepare_unitcell.h:				this->init_vel,
module_elecstate/test/prepare_unitcell.h:				this->fixed_axes);
module_elecstate/test/prepare_unitcell.h:			ucell->atom_label[it] = this->elements[it];
module_elecstate/test/prepare_unitcell.h:			ucell->atom_mass[it] = this->atomic_mass[it];
module_elecstate/test/prepare_unitcell.h:			ucell->pseudo_fn[it] = this->pp_files[it];
module_elecstate/test/prepare_unitcell.h:			ucell->pseudo_type[it] = this->pp_types[it];
module_elecstate/test/prepare_unitcell.h:			ucell->orbital_fn[it] = this->orb_files[it];
module_elecstate/test/prepare_unitcell.h:		ucell->lat0 = this->lat0;
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e11 = this->latvec[0];
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e12 = this->latvec[1];
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e13 = this->latvec[2];
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e21 = this->latvec[3];
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e22 = this->latvec[4];
module_elecstate/test/prepare_unitcell.h:	       	ucell->latvec.e23 = this->latvec[5];
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e31 = this->latvec[6];
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e32 = this->latvec[7];
module_elecstate/test/prepare_unitcell.h:		ucell->latvec.e33 = this->latvec[8];
module_elecstate/test/prepare_unitcell.h:		ucell->Coordinate = this->coor_type;
module_elecstate/test/prepare_unitcell.h:		this->atomic_index = 0;
module_elecstate/test/prepare_unitcell.h:			ucell->atoms[it].label = this->elements[it];
module_elecstate/test/prepare_unitcell.h:			ucell->atoms[it].na = this->natom[it];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].x = this->coordinates[this->atomic_index*3+0];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].y = this->coordinates[this->atomic_index*3+1];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].z = this->coordinates[this->atomic_index*3+2];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].x = this->coordinates[this->atomic_index*3+0];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].y = this->coordinates[this->atomic_index*3+1];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].z = this->coordinates[this->atomic_index*3+2];
module_elecstate/test/prepare_unitcell.h:                if(this->init_vel)
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].x = this->velocity[this->atomic_index*3+0];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].y = this->velocity[this->atomic_index*3+1];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].z = this->velocity[this->atomic_index*3+2];
module_elecstate/test/prepare_unitcell.h:				if(this->selective_dynamics)
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].x = this->mbl[this->atomic_index*3+0];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].y = this->mbl[this->atomic_index*3+1];
module_elecstate/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].z = this->mbl[this->atomic_index*3+2];
module_elecstate/test/prepare_unitcell.h:				++(this->atomic_index);
module_elecstate/test/prepare_unitcell.h:		ucell->nat = this->natom.sum();
module_esolver/esolver_fp.cpp:	delete this->pelec;
module_esolver/esolver_fp.cpp:	this->pw_rho->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD);
module_esolver/esolver_fp.cpp:	if (this->classname == "ESolver_OF")
module_esolver/esolver_fp.cpp:		this->pw_rho->setfullpw(inp.of_full_pw, inp.of_full_pw_dim);
module_esolver/esolver_fp.cpp:		this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, 4.0 * inp.ecutwfc);
module_esolver/esolver_fp.cpp:		this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.nx, inp.ny, inp.nz);
module_esolver/esolver_fp.cpp:	this->pw_rho->initparameters(false, 4.0 * inp.ecutwfc);
module_esolver/esolver_fp.cpp:	this->pw_rho->ft.fft_mode = inp.fft_mode;
module_esolver/esolver_fp.cpp:	this->pw_rho->setuptransform();
module_esolver/esolver_fp.cpp:	this->pw_rho->collect_local_pw();
module_esolver/esolver_fp.cpp:	this->pw_rho->collect_uniqgg();
module_esolver/esolver_fp.cpp:		this->pw_rhod->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD);
module_esolver/esolver_fp.cpp:		if (this->classname == "ESolver_OF")
module_esolver/esolver_fp.cpp:			this->pw_rhod->setfullpw(inp.of_full_pw, inp.of_full_pw_dim);
module_esolver/esolver_fp.cpp:			this->pw_rhod->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.ecutrho);
module_esolver/esolver_fp.cpp:			this->pw_rhod->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.ndx, inp.ndy, inp.ndz);
module_esolver/esolver_fp.cpp:		this->pw_rhod->initparameters(false, inp.ecutrho);
module_esolver/esolver_fp.cpp:		this->pw_rhod->ft.fft_mode = inp.fft_mode;
module_esolver/esolver_fp.cpp:		pw_rhod_sup->setuptransform(this->pw_rho);
module_esolver/esolver_fp.cpp:		this->pw_rhod->collect_local_pw();
module_esolver/esolver_fp.cpp:		this->pw_rhod->collect_uniqgg();
module_esolver/esolver_fp.cpp:	this->print_rhofft(inp, GlobalV::ofs_running);
module_esolver/esolver_fp.cpp:			this->pw_rho->initgrids(cell.lat0, cell.latvec, 4.0 * inp.ecutwfc);
module_esolver/esolver_fp.cpp:			this->pw_rho->initgrids(cell.lat0, cell.latvec, inp.nx, inp.ny, inp.nz);
module_esolver/esolver_fp.cpp:		this->pw_rho->initparameters(false, 4.0 * inp.ecutwfc);
module_esolver/esolver_fp.cpp:		this->pw_rho->setuptransform();
module_esolver/esolver_fp.cpp:		this->pw_rho->collect_local_pw(); 
module_esolver/esolver_fp.cpp:		this->pw_rho->collect_uniqgg();
module_esolver/esolver_fp.cpp:				this->pw_rhod->initgrids(cell.lat0, cell.latvec, inp.ecutrho);
module_esolver/esolver_fp.cpp:				this->pw_rhod->initgrids(cell.lat0, cell.latvec, inp.ndx, inp.ndy, inp.ndz);
module_esolver/esolver_fp.cpp:			this->pw_rhod->initparameters(false, inp.ecutrho);
module_esolver/esolver_fp.cpp:			pw_rhod_sup->setuptransform(this->pw_rho);
module_esolver/esolver_fp.cpp:			this->pw_rhod->collect_local_pw();
module_esolver/esolver_fp.cpp:			this->pw_rhod->collect_uniqgg();
module_esolver/esolver_fp.cpp:			this->pw_rhod->initgrids(cell.lat0, cell.latvec, pw_rhod->nx, pw_rhod->ny, pw_rhod->nz);
module_esolver/esolver_fp.cpp:			this->pw_rhod->collect_local_pw();
module_esolver/esolver_fp.cpp:			this->pw_rhod->collect_uniqgg();
module_esolver/esolver_fp.cpp:	this->pelec->omega = GlobalC::ucell.omega;
module_esolver/esolver_fp.cpp:		ecut = this->pw_rho->gridecut_lat * this->pw_rho->tpiba2;
module_esolver/esolver_fp.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"fft grid for charge/potential", this->pw_rho->nx,this->pw_rho->ny,this->pw_rho->nz);
module_esolver/esolver_fp.cpp:	ModuleBase::GlobalFunc::OUT(ofs, "nrxx", this->pw_rho->nrxx);
module_esolver/esolver_fp.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"number of plane waves",this->pw_rho->npwtot);
module_esolver/esolver_fp.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"number of sticks", this->pw_rho->nstot);
module_esolver/esolver_fp.cpp:            << this->pw_rho->nst_per[i] 
module_esolver/esolver_fp.cpp:            << std::setw(15) << this->pw_rho->npw_per[i] << std::endl;
module_esolver/esolver_fp.cpp:        << std::setw(15) << this->pw_rho->nstot 
module_esolver/esolver_fp.cpp:        << std::setw(15) << this->pw_rho->npwtot << std::endl;
module_esolver/esolver_fp.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"number of |g|", this->pw_rho->ngg);
module_esolver/esolver_fp.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"max |g|", this->pw_rho->gg_uniq[ this->pw_rho->ngg-1]);
module_esolver/esolver_fp.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"min |g|", this->pw_rho->gg_uniq[0]);
module_esolver/esolver_fp.cpp:			ecut = this->pw_rhod->gridecut_lat * this->pw_rhod->tpiba2;
module_esolver/esolver_fp.cpp:				this->pw_rhod->nx,
module_esolver/esolver_fp.cpp:				this->pw_rhod->ny,
module_esolver/esolver_fp.cpp:				this->pw_rhod->nz);
module_esolver/esolver_fp.cpp:		ModuleBase::GlobalFunc::OUT(ofs, "nrxx", this->pw_rhod->nrxx);
module_esolver/esolver_fp.cpp:		ModuleBase::GlobalFunc::OUT(ofs, "number of plane waves", this->pw_rhod->npwtot);
module_esolver/esolver_fp.cpp:		ModuleBase::GlobalFunc::OUT(ofs, "number of sticks", this->pw_rhod->nstot);
module_esolver/esolver_fp.cpp:			ofs << " " << std::setw(8) << i + 1 << std::setw(15) << this->pw_rhod->nst_per[i] << std::setw(15)
module_esolver/esolver_fp.cpp:				<< this->pw_rhod->npw_per[i] << std::endl;
module_esolver/esolver_fp.cpp:		ofs << " " << std::setw(8) << GlobalV::NPROC_IN_POOL << std::setw(15) << this->pw_rhod->nstot
module_esolver/esolver_fp.cpp:			<< std::setw(15) << this->pw_rhod->npwtot << std::endl;
module_esolver/esolver_fp.cpp:		ModuleBase::GlobalFunc::OUT(ofs, "number of |g|", this->pw_rhod->ngg);
module_esolver/esolver_fp.cpp:		ModuleBase::GlobalFunc::OUT(ofs, "max |g|", this->pw_rhod->gg_uniq[this->pw_rhod->ngg - 1]);
module_esolver/esolver_fp.cpp:		ModuleBase::GlobalFunc::OUT(ofs, "min |g|", this->pw_rhod->gg_uniq[0]);
module_esolver/esolver_ks.cpp:	p_chgmix->set_rhopw(this->pw_rho, this->pw_rhod);
module_esolver/esolver_ks.cpp:	this->wf.init_wfc = INPUT.init_wfc;
module_esolver/esolver_ks.cpp:	this->wf.mem_saver = INPUT.mem_saver;
module_esolver/esolver_ks.cpp:	this->wf.out_wfc_pw = INPUT.out_wfc_pw;
module_esolver/esolver_ks.cpp:	this->wf.out_wfc_r = INPUT.out_wfc_r;
module_esolver/esolver_ks.cpp:    delete this->psi;
module_esolver/esolver_ks.cpp:    delete this->pw_wfc;
module_esolver/esolver_ks.cpp:    delete this->p_hamilt;
module_esolver/esolver_ks.cpp:    delete this->phsol;
module_esolver/esolver_ks.cpp:    delete this->p_chgmix;
module_esolver/esolver_ks.cpp:	this->kv.set(ucell.symm, GlobalV::global_kpoint_card, GlobalV::NSPIN, ucell.G, ucell.latvec);
module_esolver/esolver_ks.cpp:	Print_Info::setup_parameters(ucell, this->kv);
module_esolver/esolver_ks.cpp:	this->pw_wfc->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD);
module_esolver/esolver_ks.cpp:	this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0,
module_esolver/esolver_ks.cpp:			this->pw_rho->nx,
module_esolver/esolver_ks.cpp:			this->pw_rho->ny,
module_esolver/esolver_ks.cpp:			this->pw_rho->nz);
module_esolver/esolver_ks.cpp:	this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data());
module_esolver/esolver_ks.cpp:		MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
module_esolver/esolver_ks.cpp:	this->pw_wfc->ft.fft_mode = inp.fft_mode;
module_esolver/esolver_ks.cpp:	this->pw_wfc->setuptransform();
module_esolver/esolver_ks.cpp:	for (int ik = 0; ik < this->kv.nks; ++ik)
module_esolver/esolver_ks.cpp:		this->kv.ngk[ik] = this->pw_wfc->npwk[ik];
module_esolver/esolver_ks.cpp:	this->pw_wfc->collect_local_pw(inp.erf_ecut, inp.erf_height, inp.erf_sigma);
module_esolver/esolver_ks.cpp:	this->print_wfcfft(inp, GlobalV::ofs_running);
module_esolver/esolver_ks.cpp:	GlobalC::Pgrid.init(this->pw_rhod->nx,
module_esolver/esolver_ks.cpp:			this->pw_rhod->ny,
module_esolver/esolver_ks.cpp:			this->pw_rhod->nz,
module_esolver/esolver_ks.cpp:			this->pw_rhod->nplane,
module_esolver/esolver_ks.cpp:			this->pw_rhod->nrxx,
module_esolver/esolver_ks.cpp:	this->sf.setup_structure_factor(&ucell, this->pw_rhod);
module_esolver/esolver_ks.cpp:		GlobalC::paw_cell.set_libpaw_fft(this->pw_wfc->nx,this->pw_wfc->ny,this->pw_wfc->nz,
module_esolver/esolver_ks.cpp:				this->pw_wfc->nx,this->pw_wfc->ny,this->pw_wfc->nz,
module_esolver/esolver_ks.cpp:				this->pw_wfc->startz,this->pw_wfc->numz);
module_esolver/esolver_ks.cpp:				this->pw_wfc->nx,this->pw_wfc->ny,this->pw_wfc->nz,
module_esolver/esolver_ks.cpp:				this->sf.eigts1.c,this->sf.eigts2.c,this->sf.eigts3.c);
module_esolver/esolver_ks.cpp:		GlobalC::Pgrid.init(this->pw_rhod->nx,
module_esolver/esolver_ks.cpp:				this->pw_rhod->ny,
module_esolver/esolver_ks.cpp:				this->pw_rhod->nz,
module_esolver/esolver_ks.cpp:				this->pw_rhod->nplane,
module_esolver/esolver_ks.cpp:				this->pw_rhod->nrxx,
module_esolver/esolver_ks.cpp:		this->sf.setup_structure_factor(&ucell, this->pw_rhod);
module_esolver/esolver_ks.cpp:	ModuleBase::timer::tick(this->classname, "hamilt2density");
module_esolver/esolver_ks.cpp:	//this->phsol->solve(this->phamilt, this->pes, this->wf, ETHR);
module_esolver/esolver_ks.cpp:	ModuleBase::timer::tick(this->classname, "hamilt2density");
module_esolver/esolver_ks.cpp:	if(std::abs(ecut-this->pw_wfc->gk_ecut * this->pw_wfc->tpiba2) > 1e-6)
module_esolver/esolver_ks.cpp:		ecut = this->pw_wfc->gk_ecut * this->pw_wfc->tpiba2;
module_esolver/esolver_ks.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"fft grid for wave functions", this->pw_wfc->nx,this->pw_wfc->ny,this->pw_wfc->nz);
module_esolver/esolver_ks.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"number of plane waves",this->pw_wfc->npwtot);
module_esolver/esolver_ks.cpp:	ModuleBase::GlobalFunc::OUT(ofs,"number of sticks", this->pw_wfc->nstot);
module_esolver/esolver_ks.cpp:            << this->pw_wfc->nst_per[i] 
module_esolver/esolver_ks.cpp:            << this->pw_wfc->npw_per[i] << std::endl;
module_esolver/esolver_ks.cpp:        << std::setw(15) << this->pw_wfc->nstot 
module_esolver/esolver_ks.cpp:        << std::setw(15) << this->pw_wfc->npwtot << std::endl;
module_esolver/esolver_ks.cpp:		this->others(istep);
module_esolver/esolver_ks.cpp:		ModuleBase::timer::tick(this->classname, "run");
module_esolver/esolver_ks.cpp:		this->before_scf(istep); //Something else to do before the iter loop
module_esolver/esolver_ks.cpp:		if(this->maxniter > 0)  
module_esolver/esolver_ks.cpp:			this->print_head(); //print the headline on the screen.
module_esolver/esolver_ks.cpp:		this->conv_elec = false;
module_esolver/esolver_ks.cpp:		this->niter = this->maxniter;
module_esolver/esolver_ks.cpp:		for (int iter = 1; iter <= this->maxniter; ++iter)
module_esolver/esolver_ks.cpp:			this->write_head(GlobalV::ofs_running, istep, iter);
module_esolver/esolver_ks.cpp:			double diag_ethr = this->phsol->set_diagethr(istep, iter, drho);
module_esolver/esolver_ks.cpp:			this->iter_init(istep, iter);
module_esolver/esolver_ks.cpp:			this->hamilt2density(istep, iter, diag_ethr);
module_esolver/esolver_ks.cpp:				// double drho = this->estate.caldr2(); 
module_esolver/esolver_ks.cpp:					hsolver_error = this->phsol->cal_hsolerror();
module_esolver/esolver_ks.cpp:						diag_ethr = this->phsol->reset_diagethr(GlobalV::ofs_running, hsolver_error, drho);
module_esolver/esolver_ks.cpp:						this->hamilt2density(istep, iter, diag_ethr);
module_esolver/esolver_ks.cpp:						hsolver_error = this->phsol->cal_hsolerror();
module_esolver/esolver_ks.cpp:				// mixing will restart at this->p_chgmix->mixing_restart steps
module_esolver/esolver_ks.cpp:                    && this->p_chgmix->mixing_restart_step > iter)
module_esolver/esolver_ks.cpp:					this->p_chgmix->mixing_restart_step = iter + 1;
module_esolver/esolver_ks.cpp:				// drho will be 0 at this->p_chgmix->mixing_restart step, which is not ground state
module_esolver/esolver_ks.cpp:				bool not_restart_step = !(iter==this->p_chgmix->mixing_restart_step && GlobalV::MIXING_RESTART > 0.0);
module_esolver/esolver_ks.cpp:				this->conv_elec = (drho < this->scf_thr 
module_esolver/esolver_ks.cpp:				if (drho < hsolver_error || this->conv_elec)
module_esolver/esolver_ks.cpp:					// mixing will restart after this->p_chgmix->mixing_restart steps
module_esolver/esolver_ks.cpp:                        && iter == this->p_chgmix->mixing_restart_step - 1)
module_esolver/esolver_ks.cpp:			MPI_Bcast(&this->conv_elec, 1, MPI_DOUBLE , 0, PARAPW_WORLD);
module_esolver/esolver_ks.cpp:			MPI_Bcast(pelec->charge->rho[0], this->pw_rhod->nrxx, MPI_DOUBLE, 0, PARAPW_WORLD);
module_esolver/esolver_ks.cpp:			// this->phamilt->update(conv_elec);
module_esolver/esolver_ks.cpp:			this->update_pot(istep, iter);
module_esolver/esolver_ks.cpp:			this->iter_finish(iter);
module_esolver/esolver_ks.cpp:			this->print_iter(iter, drho, dkin, duration, diag_ethr);
module_esolver/esolver_ks.cpp:					this->pelec->f_en.etot * ModuleBase::Ry_to_eV,
module_esolver/esolver_ks.cpp:					this->pelec->f_en.etot_delta * ModuleBase::Ry_to_eV,
module_esolver/esolver_ks.cpp:			if (this->conv_elec)
module_esolver/esolver_ks.cpp:				this->niter = iter;
module_esolver/esolver_ks.cpp:				bool stop = this->do_after_converge(iter);
module_esolver/esolver_ks.cpp:             && iter == this->p_chgmix->mixing_restart_step - 1 
module_esolver/esolver_ks.cpp:				this->pelec->eferm.ef * ModuleBase::Ry_to_eV,
module_esolver/esolver_ks.cpp:				this->pelec->f_en.etot * ModuleBase::Ry_to_eV,
module_esolver/esolver_ks.cpp:				this->conv_elec
module_esolver/esolver_ks.cpp:		this->after_scf(istep);
module_esolver/esolver_ks.cpp:		ModuleBase::timer::tick(this->classname, "run");
module_esolver/esolver_ks.cpp:	int Jnkstot = this->pelec->klist->nkstot;
module_esolver/esolver_ks.cpp:	int Jnkstot_ibz = this->pelec->klist->nkstot_ibz;
module_esolver/esolver_ks.cpp:        this->pelec->print_etot(this->conv_elec, iter, drho, dkin, duration, INPUT.printe, ethr);
module_esolver/esolver_ks.cpp:		<< this->basisname
module_esolver/esolver_ks.cpp:	return this->niter;
module_esolver/esolver_ks.cpp:		return ModuleIO::Output_Rho(this->pw_big,
module_esolver/esolver_ks.cpp:								this->pw_rhod,
module_esolver/esolver_ks.cpp:								this->pelec->eferm.get_efval(is),
module_esolver/esolver_ks.cpp:	return ModuleIO::Output_Rho(this->pw_big,
module_esolver/esolver_ks.cpp:			this->pw_rhod,
module_esolver/esolver_ks.cpp:			this->pelec->eferm.get_efval(is),
module_esolver/esolver_ks.cpp:	return ModuleIO::Output_Rho(this->pw_big,
module_esolver/esolver_ks.cpp:			this->pw_rhod,
module_esolver/esolver_ks.cpp:			this->pelec->eferm.get_efval(is),
module_esolver/esolver_ks.cpp:	return ModuleIO::Output_Potential(this->pw_big,
module_esolver/esolver_ks.cpp:			this->pw_rhod,
module_esolver/esolver_ks.cpp:			this->pelec->pot->get_effective_v(),
module_esolver/esolver_ks.cpp:			this->pelec->pot->get_fixed_v(),
module_esolver/esolver_ks_lcao.cpp:	this->classname = "ESolver_KS_LCAO";
module_esolver/esolver_ks_lcao.cpp:	this->basisname = "LCAO";
module_esolver/esolver_ks_lcao.cpp:		this->exx_lri_double = std::make_shared<Exx_LRI<double>>(GlobalC::exx_info.info_ri);
module_esolver/esolver_ks_lcao.cpp:		this->exd = std::make_shared<Exx_LRI_Interface<TK, double>>(this->exx_lri_double);
module_esolver/esolver_ks_lcao.cpp:		this->LM.Hexxd = &this->exd->get_Hexxs();
module_esolver/esolver_ks_lcao.cpp:		this->exx_lri_complex = std::make_shared<Exx_LRI<std::complex<double>>>(GlobalC::exx_info.info_ri);
module_esolver/esolver_ks_lcao.cpp:		this->exc = std::make_shared<Exx_LRI_Interface<TK, std::complex<double>>>(this->exx_lri_complex);
module_esolver/esolver_ks_lcao.cpp:		this->LM.Hexxc = &this->exc->get_Hexxs();
module_esolver/esolver_ks_lcao.cpp:	this->orb_con.clear_after_ions(GlobalC::UOT, GlobalC::ORB, GlobalV::deepks_setorb, GlobalC::ucell.infoNL.nproj);
module_esolver/esolver_ks_lcao.cpp:        this->kv.set(ucell.symm, GlobalV::global_kpoint_card, GlobalV::NSPIN, ucell.G, ucell.latvec);
module_esolver/esolver_ks_lcao.cpp:        Print_Info::setup_parameters(ucell, this->kv);
module_esolver/esolver_ks_lcao.cpp:    if (this->pelec == nullptr)
module_esolver/esolver_ks_lcao.cpp:        this->pelec = new elecstate::ElecStateLCAO<TK>(
module_esolver/esolver_ks_lcao.cpp:            &(this->chr),
module_esolver/esolver_ks_lcao.cpp:            &(this->kv),
module_esolver/esolver_ks_lcao.cpp:            this->kv.nks,
module_esolver/esolver_ks_lcao.cpp:            &(this->LOC),
module_esolver/esolver_ks_lcao.cpp:            &(this->GG), // mohan add 2024-04-01
module_esolver/esolver_ks_lcao.cpp:            &(this->GK), // mohan add 2024-04-01
module_esolver/esolver_ks_lcao.cpp:            &(this->LOWF),
module_esolver/esolver_ks_lcao.cpp:            this->pw_rho,
module_esolver/esolver_ks_lcao.cpp:            this->pw_big);
module_esolver/esolver_ks_lcao.cpp:    this->init_basis_lcao(this->orb_con, inp, ucell);
module_esolver/esolver_ks_lcao.cpp:    this->gen_h.LM = &this->LM;
module_esolver/esolver_ks_lcao.cpp:    this->LOC.ParaV = this->LOWF.ParaV = this->LM.ParaV = &(this->orb_con.ParaV);
module_esolver/esolver_ks_lcao.cpp:    dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)->init_DM(&this->kv, this->LM.ParaV, GlobalV::NSPIN);
module_esolver/esolver_ks_lcao.cpp:    this->LM.divide_HS_in_frag(GlobalV::GAMMA_ONLY_LOCAL, orb_con.ParaV, this->kv.nks);
module_esolver/esolver_ks_lcao.cpp:                this->exx_lri_double->init(MPI_COMM_WORLD, this->kv);
module_esolver/esolver_ks_lcao.cpp:                this->exx_lri_complex->init(MPI_COMM_WORLD, this->kv);
module_esolver/esolver_ks_lcao.cpp:        GlobalC::dftu.init(ucell, this->LM, this->kv.nks);
module_esolver/esolver_ks_lcao.cpp:    GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho);
module_esolver/esolver_ks_lcao.cpp:    if (this->phsol == nullptr)
module_esolver/esolver_ks_lcao.cpp:        this->phsol = new hsolver::HSolverLCAO<TK>(this->LOWF.ParaV);
module_esolver/esolver_ks_lcao.cpp:        this->phsol->method = GlobalV::KS_SOLVER;
module_esolver/esolver_ks_lcao.cpp:    this->pelec->charge->allocate(GlobalV::NSPIN);
module_esolver/esolver_ks_lcao.cpp:    this->pelec->omega = GlobalC::ucell.omega;
module_esolver/esolver_ks_lcao.cpp:    if (this->pelec->pot == nullptr)
module_esolver/esolver_ks_lcao.cpp:        this->pelec->pot = new elecstate::Potential(this->pw_rhod,
module_esolver/esolver_ks_lcao.cpp:                                                    this->pw_rho,
module_esolver/esolver_ks_lcao.cpp:                                                    &(this->sf),
module_esolver/esolver_ks_lcao.cpp:                                                    &(this->pelec->f_en.etxc),
module_esolver/esolver_ks_lcao.cpp:                                                    &(this->pelec->f_en.vtxc));
module_esolver/esolver_ks_lcao.cpp:    // Fix this->pelec->wg by ocp_kb
module_esolver/esolver_ks_lcao.cpp:        this->pelec->fixed_weights(GlobalV::ocp_kb);
module_esolver/esolver_ks_lcao.cpp:		delete this->pelec;
module_esolver/esolver_ks_lcao.cpp:		this->pelec = new elecstate::ElecStateLCAO<TK>(&(this->chr),
module_esolver/esolver_ks_lcao.cpp:				&(this->kv),
module_esolver/esolver_ks_lcao.cpp:				this->kv.nks,
module_esolver/esolver_ks_lcao.cpp:				&(this->LOC),
module_esolver/esolver_ks_lcao.cpp:                &(this->GG), // mohan add 2024-04-01
module_esolver/esolver_ks_lcao.cpp:                &(this->GK), // mohan add 2024-04-01
module_esolver/esolver_ks_lcao.cpp:				&(this->LOWF),
module_esolver/esolver_ks_lcao.cpp:				this->pw_rho,
module_esolver/esolver_ks_lcao.cpp:				this->pw_big);
module_esolver/esolver_ks_lcao.cpp:		dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)->init_DM(&this->kv, this->LM.ParaV, GlobalV::NSPIN);
module_esolver/esolver_ks_lcao.cpp:        GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho);
module_esolver/esolver_ks_lcao.cpp:        this->pelec->charge->allocate(GlobalV::NSPIN);
module_esolver/esolver_ks_lcao.cpp:        this->pelec->omega = GlobalC::ucell.omega;
module_esolver/esolver_ks_lcao.cpp:        if (this->pelec->pot == nullptr)
module_esolver/esolver_ks_lcao.cpp:            this->pelec->pot = new elecstate::Potential(this->pw_rhod,
module_esolver/esolver_ks_lcao.cpp:                                                        this->pw_rho,
module_esolver/esolver_ks_lcao.cpp:                                                        &(this->sf),
module_esolver/esolver_ks_lcao.cpp:                                                        &(this->pelec->f_en.etxc),
module_esolver/esolver_ks_lcao.cpp:                                                        &(this->pelec->f_en.vtxc));
module_esolver/esolver_ks_lcao.cpp:    return this->pelec->f_en.etot;
module_esolver/esolver_ks_lcao.cpp:	Force_Stress_LCAO<TK> fsl(this->RA, GlobalC::ucell.nat);
module_esolver/esolver_ks_lcao.cpp:			this->LOC,
module_esolver/esolver_ks_lcao.cpp:            this->orb_con.ParaV, 
module_esolver/esolver_ks_lcao.cpp:			this->pelec,
module_esolver/esolver_ks_lcao.cpp:			this->psi,
module_esolver/esolver_ks_lcao.cpp:            this->LM,
module_esolver/esolver_ks_lcao.cpp:            this->gen_h, // mohan add 2024-04-02
module_esolver/esolver_ks_lcao.cpp:            this->GG, // mohan add 2024-04-01
module_esolver/esolver_ks_lcao.cpp:            this->GK, // mohan add 2024-04-01
module_esolver/esolver_ks_lcao.cpp:			this->scs,
module_esolver/esolver_ks_lcao.cpp:			this->sf,
module_esolver/esolver_ks_lcao.cpp:			this->kv,
module_esolver/esolver_ks_lcao.cpp:			this->pw_rho,
module_esolver/esolver_ks_lcao.cpp:			* this->exx_lri_double,
module_esolver/esolver_ks_lcao.cpp:			* this->exx_lri_complex,
module_esolver/esolver_ks_lcao.cpp:	this->RA.delete_grid();
module_esolver/esolver_ks_lcao.cpp:	this->have_force = true;
module_esolver/esolver_ks_lcao.cpp:    if (!this->have_force)
module_esolver/esolver_ks_lcao.cpp:        this->cal_force(fcs);
module_esolver/esolver_ks_lcao.cpp:    stress = this->scs; // copy the stress
module_esolver/esolver_ks_lcao.cpp:    this->have_force = false;
module_esolver/esolver_ks_lcao.cpp:    GlobalV::ofs_running << " !FINAL_ETOT_IS " << this->pelec->f_en.etot * ModuleBase::Ry_to_eV << " eV" << std::endl;
module_esolver/esolver_ks_lcao.cpp:        ModuleIO::write_istate_info(this->pelec->ekb, this->pelec->wg, this->kv, &(GlobalC::Pkpoints));
module_esolver/esolver_ks_lcao.cpp:                                this->pelec->ekb, 
module_esolver/esolver_ks_lcao.cpp:                                this->kv, 
module_esolver/esolver_ks_lcao.cpp:            this->psi,
module_esolver/esolver_ks_lcao.cpp:            this->LM,
module_esolver/esolver_ks_lcao.cpp:            this->pelec,
module_esolver/esolver_ks_lcao.cpp:            this->kv,
module_esolver/esolver_ks_lcao.cpp:            this->p_hamilt);
module_esolver/esolver_ks_lcao.cpp:				this->psi,
module_esolver/esolver_ks_lcao.cpp:                this->LM,
module_esolver/esolver_ks_lcao.cpp:                this->orb_con.ParaV,
module_esolver/esolver_ks_lcao.cpp:				this->pelec->ekb,
module_esolver/esolver_ks_lcao.cpp:				this->pelec->wg,
module_esolver/esolver_ks_lcao.cpp:				*(this->pelec->klist),
module_esolver/esolver_ks_lcao.cpp:				this->pelec->eferm,
module_esolver/esolver_ks_lcao.cpp:				this->p_hamilt);
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.gamma_only = GlobalV::GAMMA_ONLY_LOCAL;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.nlocal = GlobalV::NLOCAL;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.nbands = GlobalV::NBANDS;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.ParaV.nspin = GlobalV::NSPIN;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.dsize = GlobalV::DSIZE;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.nb2d = GlobalV::NB2D;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.dcolor = GlobalV::DCOLOR;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.drank = GlobalV::DRANK;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.myrank = GlobalV::MY_RANK;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.calculation = GlobalV::CALCULATION;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.ks_solver = GlobalV::KS_SOLVER;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.setup_2d = true;
module_esolver/esolver_ks_lcao.cpp:    this->orb_con.set_orb_tables(GlobalV::ofs_running,
module_esolver/esolver_ks_lcao.cpp:    if (this->orb_con.setup_2d)
module_esolver/esolver_ks_lcao.cpp:        this->orb_con.setup_2d_division(GlobalV::ofs_running, GlobalV::ofs_warning);
module_esolver/esolver_ks_lcao.cpp:        this->orb_con.ParaV.set_atomic_trace(GlobalC::ucell.get_iat2iwt(), GlobalC::ucell.nat, GlobalV::NLOCAL);
module_esolver/esolver_ks_lcao.cpp:        this->p_chgmix->init_mixing(); // init mixing
module_esolver/esolver_ks_lcao.cpp:        this->p_chgmix->mixing_restart_step = GlobalV::SCF_NMAX + 1;
module_esolver/esolver_ks_lcao.cpp:        this->p_chgmix->mixing_restart_count = 0;
module_esolver/esolver_ks_lcao.cpp:    if (iter == this->p_chgmix->mixing_restart_step 
module_esolver/esolver_ks_lcao.cpp:        this->p_chgmix->init_mixing();
module_esolver/esolver_ks_lcao.cpp:        this->p_chgmix->mixing_restart_count++;
module_esolver/esolver_ks_lcao.cpp:                this->p_chgmix->mixing_restart_step = GlobalV::SCF_NMAX + 1;
module_esolver/esolver_ks_lcao.cpp:                = dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao.cpp:            this->p_chgmix->allocate_mixing_dmr(nnr_tmp);
module_esolver/esolver_ks_lcao.cpp:    this->pelec->f_en.deband_harris = this->pelec->cal_delta_eband();
module_esolver/esolver_ks_lcao.cpp:        && this->wf.init_wfc == "file" 
module_esolver/esolver_ks_lcao.cpp:        && this->LOWF.error == 0)
module_esolver/esolver_ks_lcao.cpp:            this->pelec->skip_weights = true;
module_esolver/esolver_ks_lcao.cpp:            this->pelec->psiToRho(*this->psi);
module_esolver/esolver_ks_lcao.cpp:            this->pelec->skip_weights = false;
module_esolver/esolver_ks_lcao.cpp:            this->pelec->pot->update_from_charge(this->pelec->charge, &GlobalC::ucell);
module_esolver/esolver_ks_lcao.cpp:            this->pelec->f_en.descf = this->pelec->cal_delta_escf();
module_esolver/esolver_ks_lcao.cpp:        this->exd->exx_eachiterinit(*dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM(), iter);
module_esolver/esolver_ks_lcao.cpp:        this->exc->exx_eachiterinit(*dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM(), iter);
module_esolver/esolver_ks_lcao.cpp:            GlobalC::dftu.set_dmr( dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM() );
module_esolver/esolver_ks_lcao.cpp:        GlobalC::dftu.cal_slater_UJ(this->pelec->charge->rho, this->pw_rho->nrxx);
module_esolver/esolver_ks_lcao.cpp:        this->p_hamilt->refresh();
module_esolver/esolver_ks_lcao.cpp:            this->GK.renew();
module_esolver/esolver_ks_lcao.cpp:        this->p_hamilt->refresh();
module_esolver/esolver_ks_lcao.cpp:    this->pelec->charge->save_rho_before_sum_band();
module_esolver/esolver_ks_lcao.cpp:        && this->p_chgmix->mixing_restart_count > 0)
module_esolver/esolver_ks_lcao.cpp:            = dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao.cpp:    if (this->phsol != nullptr)
module_esolver/esolver_ks_lcao.cpp:        this->pelec->f_en.eband = 0.0;
module_esolver/esolver_ks_lcao.cpp:        this->pelec->f_en.demet = 0.0;
module_esolver/esolver_ks_lcao.cpp:        this->phsol->solve(this->p_hamilt, this->psi[0], this->pelec, GlobalV::KS_SOLVER);
module_esolver/esolver_ks_lcao.cpp:                this->pelec->cal_bandgap();
module_esolver/esolver_ks_lcao.cpp:                this->pelec->cal_bandgap_updw();
module_esolver/esolver_ks_lcao.cpp:    for (int ik = 0; ik < this->kv.nks; ++ik)
module_esolver/esolver_ks_lcao.cpp:        this->pelec->print_band(ik, INPUT.printe, iter);
module_esolver/esolver_ks_lcao.cpp:        this->exd->exx_hamilt2density(*this->pelec, *this->LOWF.ParaV, iter);
module_esolver/esolver_ks_lcao.cpp:        this->exc->exx_hamilt2density(*this->pelec, *this->LOWF.ParaV, iter);
module_esolver/esolver_ks_lcao.cpp:                dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM()->get_DMK_vector();
module_esolver/esolver_ks_lcao.cpp:                this->dftu_cal_occup_m(iter, tmp_dm);
module_esolver/esolver_ks_lcao.cpp:        const Parallel_Orbitals* pv = this->LOWF.ParaV;
module_esolver/esolver_ks_lcao.cpp:        dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM()->get_DMK_vector();
module_esolver/esolver_ks_lcao.cpp:        this->dpks_cal_e_delta_band(dm);
module_esolver/esolver_ks_lcao.cpp:        sc.cal_MW(iter, &(this->LM));
module_esolver/esolver_ks_lcao.cpp:    this->pelec->cal_energies(1);
module_esolver/esolver_ks_lcao.cpp:        srho.begin(is, *(this->pelec->charge), this->pw_rho, GlobalC::Pgrid, GlobalC::ucell.symm);
module_esolver/esolver_ks_lcao.cpp:    GlobalC::ucell.magnet.compute_magnetization(this->pelec->charge->nrxx,
module_esolver/esolver_ks_lcao.cpp:                                                this->pelec->charge->nxyz,
module_esolver/esolver_ks_lcao.cpp:                                                this->pelec->charge->rho,
module_esolver/esolver_ks_lcao.cpp:                                                this->pelec->nelec_spin.data());
module_esolver/esolver_ks_lcao.cpp:    this->pelec->f_en.deband = this->pelec->cal_delta_eband();
module_esolver/esolver_ks_lcao.cpp:    if (this->conv_elec)
module_esolver/esolver_ks_lcao.cpp:            this->GK.renew(true);
module_esolver/esolver_ks_lcao.cpp:        for (int ik = 0; ik < this->kv.nks; ++ik)
module_esolver/esolver_ks_lcao.cpp:                this->p_hamilt->updateHk(ik);
module_esolver/esolver_ks_lcao.cpp:            if (this->psi != nullptr && (istep % GlobalV::out_interval == 0))
module_esolver/esolver_ks_lcao.cpp:                this->p_hamilt->matrix(h_mat, s_mat);
module_esolver/esolver_ks_lcao.cpp:                                       *this->LOWF.ParaV, 
module_esolver/esolver_ks_lcao.cpp:                                       *this->LOWF.ParaV, 
module_esolver/esolver_ks_lcao.cpp:    if (this->conv_elec)
module_esolver/esolver_ks_lcao.cpp:        for (int ik = 0; ik < this->kv.nks; ik++)
module_esolver/esolver_ks_lcao.cpp:                this->psi[0].fix_k(ik);
module_esolver/esolver_ks_lcao.cpp:                this->pelec->print_psi(this->psi[0], istep);
module_esolver/esolver_ks_lcao.cpp:    if (this->conv_elec || iter == GlobalV::SCF_NMAX)
module_esolver/esolver_ks_lcao.cpp:    if (!this->conv_elec)
module_esolver/esolver_ks_lcao.cpp:        this->pelec->pot->update_from_charge(this->pelec->charge, &GlobalC::ucell);
module_esolver/esolver_ks_lcao.cpp:        this->pelec->f_en.descf = this->pelec->cal_delta_escf();
module_esolver/esolver_ks_lcao.cpp:        this->pelec->cal_converged();
module_esolver/esolver_ks_lcao.cpp:        && this->p_chgmix->mixing_restart_count > 0 
module_esolver/esolver_ks_lcao.cpp:            = dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao.cpp:        this->p_chgmix->mix_dmr(dm);
module_esolver/esolver_ks_lcao.cpp:            GlobalC::restart.save_disk("charge", is, this->pelec->charge->nrxx, this->pelec->charge->rho[is]);
module_esolver/esolver_ks_lcao.cpp:    int two_level_step = GlobalC::exx_info.info_ri.real_number ? this->exd->two_level_step : this->exc->two_level_step;
module_esolver/esolver_ks_lcao.cpp:        std::vector<TK> Hexxk_save(this->LOWF.ParaV->get_local_size());
module_esolver/esolver_ks_lcao.cpp:        for (int ik = 0;ik < this->kv.nks;++ik)
module_esolver/esolver_ks_lcao.cpp:            hamilt::OperatorEXX<hamilt::OperatorLCAO<TK, TR>> opexx_save(&this->LM, nullptr, &Hexxk_save, this->kv);
module_esolver/esolver_ks_lcao.cpp:            GlobalC::restart.save_disk("Hexx", ik, this->LOWF.ParaV->get_local_size(), Hexxk_save.data());
module_esolver/esolver_ks_lcao.cpp:			GlobalC::restart.save_disk("Eexx", 0, 1, &this->pelec->f_en.exx);
module_esolver/esolver_ks_lcao.cpp:    if (this->out_freq_elec && iter % this->out_freq_elec == 0)
module_esolver/esolver_ks_lcao.cpp:            this->create_Output_Rho(is, iter, "tmp_").write();
module_esolver/esolver_ks_lcao.cpp:            this->create_Output_DM(is, iter).write();
module_esolver/esolver_ks_lcao.cpp:                this->create_Output_Kin(is, iter, "tmp_").write();
module_esolver/esolver_ks_lcao.cpp:        sc.cal_MW(iter, &(this->LM));
module_esolver/esolver_ks_lcao.cpp:    this->pelec->cal_energies(2);
module_esolver/esolver_ks_lcao.cpp:        this->CE.save_files(istep,
module_esolver/esolver_ks_lcao.cpp:                            this->pw_big,
module_esolver/esolver_ks_lcao.cpp:                            this->pelec->charge,
module_esolver/esolver_ks_lcao.cpp:                            &this->sf);
module_esolver/esolver_ks_lcao.cpp:    if (this->LOC.out_dm1 == 1)
module_esolver/esolver_ks_lcao.cpp:        this->create_Output_DM1(istep).write();
module_esolver/esolver_ks_lcao.cpp:            this->create_Output_Rho(is, istep).write();
module_esolver/esolver_ks_lcao.cpp:                this->create_Output_Kin(is, istep).write();
module_esolver/esolver_ks_lcao.cpp:    if (this->LOC.out_dm)
module_esolver/esolver_ks_lcao.cpp:            this->create_Output_DM(is, istep).write();
module_esolver/esolver_ks_lcao.cpp:				*this->psi, 
module_esolver/esolver_ks_lcao.cpp:				this->sf, 
module_esolver/esolver_ks_lcao.cpp:				*this->pw_rho, 
module_esolver/esolver_ks_lcao.cpp:				*this->pw_rhod, 
module_esolver/esolver_ks_lcao.cpp:				*this->pelec->charge, 
module_esolver/esolver_ks_lcao.cpp:				this->GG,
module_esolver/esolver_ks_lcao.cpp:				this->GK,
module_esolver/esolver_ks_lcao.cpp:				this->LM, 
module_esolver/esolver_ks_lcao.cpp:				this->LOC, 
module_esolver/esolver_ks_lcao.cpp:				this->kv, 
module_esolver/esolver_ks_lcao.cpp:				this->pelec->wg, 
module_esolver/esolver_ks_lcao.cpp:            this->exd->write_Hexxs_csr(file_name_exx, GlobalC::ucell);
module_esolver/esolver_ks_lcao.cpp:            this->exc->write_Hexxs_csr(file_name_exx, GlobalC::ucell);
module_esolver/esolver_ks_lcao.cpp:    this->create_Output_Potential(istep).write();
module_esolver/esolver_ks_lcao.cpp:    ModuleIO::output_convergence_after_scf(this->conv_elec, this->pelec->f_en.etot);
module_esolver/esolver_ks_lcao.cpp:    ModuleIO::output_efermi(this->conv_elec, this->pelec->eferm.ef);
module_esolver/esolver_ks_lcao.cpp:        this->pelec->print_eigenvalue(GlobalV::ofs_running);
module_esolver/esolver_ks_lcao.cpp:    LDI.out_deepks_labels(this->pelec->f_en.etot,
module_esolver/esolver_ks_lcao.cpp:            this->pelec->klist->nks,
module_esolver/esolver_ks_lcao.cpp:            this->pelec->ekb,
module_esolver/esolver_ks_lcao.cpp:            this->pelec->klist->kvec_d,
module_esolver/esolver_ks_lcao.cpp:            this->LOWF.ParaV,
module_esolver/esolver_ks_lcao.cpp:            *(this->psi),
module_esolver/esolver_ks_lcao.cpp:            dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM());
module_esolver/esolver_ks_lcao.cpp:        // rpa_interface.out_for_RPA(*(this->LOWF.ParaV), *(this->psi), this->LOC, this->pelec);
module_esolver/esolver_ks_lcao.cpp:        rpa_lri_double.cal_postSCF_exx(*dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM(), MPI_COMM_WORLD, this->kv);
module_esolver/esolver_ks_lcao.cpp:        rpa_lri_double.init(MPI_COMM_WORLD, this->kv);
module_esolver/esolver_ks_lcao.cpp:        rpa_lri_double.out_for_RPA(*(this->LOWF.ParaV), *(this->psi), this->pelec);
module_esolver/esolver_ks_lcao.cpp:        this->p_hamilt->updateHk(0); // first k point, up spin
module_esolver/esolver_ks_lcao.cpp:            = dynamic_cast<hamilt::HamiltLCAO<std::complex<double>, double>*>(this->p_hamilt);
module_esolver/esolver_ks_lcao.cpp:        this->output_mat_npz(zipname,*(p_ham_lcao->getHR()));
module_esolver/esolver_ks_lcao.cpp:            this->p_hamilt->updateHk(this->kv.nks/2); // the other half of k points, down spin
module_esolver/esolver_ks_lcao.cpp:                = dynamic_cast<hamilt::HamiltLCAO<std::complex<double>, double>*>(this->p_hamilt);
module_esolver/esolver_ks_lcao.cpp:            this->output_mat_npz(zipname,*(p_ham_lcao->getHR()));            
module_esolver/esolver_ks_lcao.cpp:            = dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao.cpp:        this->output_mat_npz(zipname,*(dm->get_DMR_pointer(1)));
module_esolver/esolver_ks_lcao.cpp:            this->output_mat_npz(zipname,*(dm->get_DMR_pointer(2)));       
module_esolver/esolver_ks_lcao.cpp:        this->create_Output_Mat_Sparse(istep).write();
module_esolver/esolver_ks_lcao.cpp:            ModuleIO::out_mulliken(istep, &this->LM, this->pelec, this->kv, this->p_hamilt);
module_esolver/esolver_ks_lcao.cpp:        sc.cal_MW(istep, &(this->LM), true);
module_esolver/esolver_ks_lcao.cpp:                       &GlobalC::ucell, this->kv.kvec_d,
module_esolver/esolver_ks_lcao.cpp:		return this->exd->exx_after_converge(
module_esolver/esolver_ks_lcao.cpp:				*this->p_hamilt, 
module_esolver/esolver_ks_lcao.cpp:				this->LM, 
module_esolver/esolver_ks_lcao.cpp:				*dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM(), 
module_esolver/esolver_ks_lcao.cpp:				this->kv, 
module_esolver/esolver_ks_lcao.cpp:		return this->exc->exx_after_converge(*this->p_hamilt, 
module_esolver/esolver_ks_lcao.cpp:				this->LM, 
module_esolver/esolver_ks_lcao.cpp:				*dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM(), 
module_esolver/esolver_ks_lcao.cpp:				this->kv, 
module_esolver/esolver_ks_lcao.cpp:    return ModuleIO::Output_DM(this->GridT,
module_esolver/esolver_ks_lcao.cpp:                               this->LOC.out_dm,
module_esolver/esolver_ks_lcao.cpp:                               this->LOC.DM,
module_esolver/esolver_ks_lcao.cpp:                               this->pelec->eferm.get_efval(is),
module_esolver/esolver_ks_lcao.cpp:            = dynamic_cast<const elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao.cpp:    return ModuleIO::Output_DM1(GlobalV::NSPIN, istep, this->LOC, this->RA, this->kv, DM);
module_esolver/esolver_ks_lcao.cpp:			this->pelec->pot->get_effective_v(),
module_esolver/esolver_ks_lcao.cpp:			*this->LOWF.ParaV,
module_esolver/esolver_ks_lcao.cpp:            this->gen_h, // mohan add 2024-04-06
module_esolver/esolver_ks_lcao.cpp:            this->GK, // mohan add 2024-04-01
module_esolver/esolver_ks_lcao.cpp:			this->LM,
module_esolver/esolver_ks_lcao.cpp:			this->kv,
module_esolver/esolver_ks_lcao.cpp:			this->p_hamilt);
module_esolver/esolver_ks_lcao_elec.cpp:    this->GridT.set_pbc_grid(this->pw_rho->nx,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_rho->ny,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_rho->nz,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->bx,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->by,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->bz,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->nbx,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->nby,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->nbz,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->nbxx,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->nbzp_start,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_big->nbzp,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_rho->ny,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_rho->nplane,
module_esolver/esolver_ks_lcao_elec.cpp:                             this->pw_rho->startz_current);
module_esolver/esolver_ks_lcao_elec.cpp:    Parallel_Orbitals* pv = this->LM.ParaV;
module_esolver/esolver_ks_lcao_elec.cpp:        this->GridT.cal_nnrg(pv);
module_esolver/esolver_ks_lcao_elec.cpp:    this->set_matrix_grid(this->RA);
module_esolver/esolver_ks_lcao_elec.cpp:    if (this->psi == nullptr)
module_esolver/esolver_ks_lcao_elec.cpp:            ncol = this->LOWF.ParaV->ncol_bands;
module_esolver/esolver_ks_lcao_elec.cpp:                ncol = this->LOWF.ParaV->ncol;
module_esolver/esolver_ks_lcao_elec.cpp:            nsk = this->kv.nks;
module_esolver/esolver_ks_lcao_elec.cpp:            ncol = this->LOWF.ParaV->ncol_bands;
module_esolver/esolver_ks_lcao_elec.cpp:        this->psi = new psi::Psi<TK>(nsk, ncol, this->LOWF.ParaV->nrow, nullptr);
module_esolver/esolver_ks_lcao_elec.cpp:    LCAO_domain::grid_prepare(this->GridT, this->GG, this->GK, *this->pw_rho, *this->pw_big);
module_esolver/esolver_ks_lcao_elec.cpp:    if (this->p_hamilt != nullptr)
module_esolver/esolver_ks_lcao_elec.cpp:        delete this->p_hamilt;
module_esolver/esolver_ks_lcao_elec.cpp:        this->p_hamilt = nullptr;
module_esolver/esolver_ks_lcao_elec.cpp:    if (this->p_hamilt == nullptr)
module_esolver/esolver_ks_lcao_elec.cpp:        elecstate::DensityMatrix<TK, double>* DM = dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao_elec.cpp:        this->p_hamilt = new hamilt::HamiltLCAO<TK, TR>(
module_esolver/esolver_ks_lcao_elec.cpp:            GlobalV::GAMMA_ONLY_LOCAL ? &(this->GG) : nullptr,
module_esolver/esolver_ks_lcao_elec.cpp:            GlobalV::GAMMA_ONLY_LOCAL ? nullptr : &(this->GK),
module_esolver/esolver_ks_lcao_elec.cpp:            &(this->gen_h),
module_esolver/esolver_ks_lcao_elec.cpp:            &(this->LM),
module_esolver/esolver_ks_lcao_elec.cpp:            &(this->LOC),
module_esolver/esolver_ks_lcao_elec.cpp:            this->pelec->pot,
module_esolver/esolver_ks_lcao_elec.cpp:            this->kv,
module_esolver/esolver_ks_lcao_elec.cpp:            GlobalC::exx_info.info_ri.real_number ? &this->exd->two_level_step : &this->exc->two_level_step);
module_esolver/esolver_ks_lcao_elec.cpp:    this->LOC.allocate_dm_wfc(this->GridT, this->pelec, this->LOWF, this->psi, this->kv, istep);
module_esolver/esolver_ks_lcao_elec.cpp:            ModuleBase::GlobalFunc::ZEROS(this->pelec->charge->rho[is], this->pw_rho->nrxx);
module_esolver/esolver_ks_lcao_elec.cpp:            double& ef_tmp = this->pelec->eferm.get_ef(is);
module_esolver/esolver_ks_lcao_elec.cpp:                this->GridT.nnrg,
module_esolver/esolver_ks_lcao_elec.cpp:                this->GridT.trace_lo,
module_esolver/esolver_ks_lcao_elec.cpp:                this->LOC.DM,
module_esolver/esolver_ks_lcao_elec.cpp:                this->LOC.DM_R,
module_esolver/esolver_ks_lcao_elec.cpp:            Gint_inout inout(this->LOC.DM, this->pelec->charge->rho, Gint_Tools::job_type::rho);
module_esolver/esolver_ks_lcao_elec.cpp:            this->GG.cal_gint(&inout);
module_esolver/esolver_ks_lcao_elec.cpp:                    ModuleBase::GlobalFunc::ZEROS(this->pelec->charge->kin_r[0], this->pw_rho->nrxx);
module_esolver/esolver_ks_lcao_elec.cpp:                Gint_inout inout1(this->LOC.DM, this->pelec->charge->kin_r, Gint_Tools::job_type::tau);
module_esolver/esolver_ks_lcao_elec.cpp:                this->GG.cal_gint(&inout1);
module_esolver/esolver_ks_lcao_elec.cpp:            Gint_inout inout(this->LOC.DM_R, this->pelec->charge->rho, Gint_Tools::job_type::rho);
module_esolver/esolver_ks_lcao_elec.cpp:            this->GK.cal_gint(&inout);
module_esolver/esolver_ks_lcao_elec.cpp:                    ModuleBase::GlobalFunc::ZEROS(this->pelec->charge->kin_r[0], this->pw_rho->nrxx);
module_esolver/esolver_ks_lcao_elec.cpp:                Gint_inout inout1(this->LOC.DM_R, this->pelec->charge->kin_r, Gint_Tools::job_type::tau);
module_esolver/esolver_ks_lcao_elec.cpp:                this->GK.cal_gint(&inout1);
module_esolver/esolver_ks_lcao_elec.cpp:        this->pelec->charge->renormalize_rho();
module_esolver/esolver_ks_lcao_elec.cpp:        const Parallel_Orbitals* pv = this->LM.ParaV;
module_esolver/esolver_ks_lcao_elec.cpp:                   &(this->orb_con.ParaV),
module_esolver/esolver_ks_lcao_elec.cpp:                   this->kv,
module_esolver/esolver_ks_lcao_elec.cpp:                   &(this->LM),
module_esolver/esolver_ks_lcao_elec.cpp:                   this->phsol,
module_esolver/esolver_ks_lcao_elec.cpp:                   this->p_hamilt,
module_esolver/esolver_ks_lcao_elec.cpp:                   this->psi,
module_esolver/esolver_ks_lcao_elec.cpp:                   this->pelec);
module_esolver/esolver_ks_lcao_elec.cpp:        this->init_after_vc(INPUT, GlobalC::ucell);
module_esolver/esolver_ks_lcao_elec.cpp:        this->CE.update_all_dis(GlobalC::ucell);
module_esolver/esolver_ks_lcao_elec.cpp:        this->CE.extrapolate_charge(
module_esolver/esolver_ks_lcao_elec.cpp:            this->pelec->charge,
module_esolver/esolver_ks_lcao_elec.cpp:            &(this->sf));
module_esolver/esolver_ks_lcao_elec.cpp:        this->pelec->f_en.evdw = vdw_solver->get_energy();
module_esolver/esolver_ks_lcao_elec.cpp:    this->beforesolver(istep);
module_esolver/esolver_ks_lcao_elec.cpp:        this->exd->exx_beforescf(this->kv, *this->p_chgmix);
module_esolver/esolver_ks_lcao_elec.cpp:        this->exc->exx_beforescf(this->kv, *this->p_chgmix);
module_esolver/esolver_ks_lcao_elec.cpp:    this->pelec->init_scf(istep, this->sf.strucFac);
module_esolver/esolver_ks_lcao_elec.cpp:    dynamic_cast<elecstate::ElecStateLCAO<TK>*>(this->pelec)
module_esolver/esolver_ks_lcao_elec.cpp:        ->init_DMR(*(dynamic_cast<hamilt::HamiltLCAO<TK, TR>*>(this->p_hamilt)->getHR()));
module_esolver/esolver_ks_lcao_elec.cpp:            = dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao_elec.cpp:        this->read_mat_npz(zipname, *(dm->get_DMR_pointer(1)));
module_esolver/esolver_ks_lcao_elec.cpp:            this->read_mat_npz(zipname, *(dm->get_DMR_pointer(2)));
module_esolver/esolver_ks_lcao_elec.cpp:        this->pelec->psiToRho(*this->psi);
module_esolver/esolver_ks_lcao_elec.cpp:        this->create_Output_Rho(0, istep).write();
module_esolver/esolver_ks_lcao_elec.cpp:            this->create_Output_Rho(1, istep).write();
module_esolver/esolver_ks_lcao_elec.cpp:        srho.begin(is, *(this->pelec->charge), this->pw_rho, GlobalC::Pgrid, GlobalC::ucell.symm);
module_esolver/esolver_ks_lcao_elec.cpp:        this->pelec->f_en.ewald_energy = H_Ewald_pw::compute_ewald(GlobalC::ucell, this->pw_rho, this->sf.strucFac);
module_esolver/esolver_ks_lcao_elec.cpp:    this->p_hamilt->non_first_scf = istep;
module_esolver/esolver_ks_lcao_elec.cpp:        this->get_S();
module_esolver/esolver_ks_lcao_elec.cpp:        Cal_Test::test_memory(this->pw_rho,
module_esolver/esolver_ks_lcao_elec.cpp:                              this->pw_wfc,
module_esolver/esolver_ks_lcao_elec.cpp:                              this->p_chgmix->get_mixing_mode(),
module_esolver/esolver_ks_lcao_elec.cpp:                              this->p_chgmix->get_mixing_ndim());
module_esolver/esolver_ks_lcao_elec.cpp:    this->beforesolver(istep);
module_esolver/esolver_ks_lcao_elec.cpp:    this->pelec->init_scf(istep, this->sf.strucFac);
module_esolver/esolver_ks_lcao_elec.cpp:        this->nscf();
module_esolver/esolver_ks_lcao_elec.cpp:        IState_Charge ISC(this->psi, this->LOC);
module_esolver/esolver_ks_lcao_elec.cpp:        ISC.begin(this->GG,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pelec->charge->rho,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pelec->wg,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pelec->eferm.get_all_ef(),
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_rho->nrxx,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_rho->nplane,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_rho->startz_current,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_rho->nx,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_rho->ny,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_rho->nz,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_big->bz,
module_esolver/esolver_ks_lcao_elec.cpp:                  this->pw_big->nbz,
module_esolver/esolver_ks_lcao_elec.cpp:        IState_Envelope IEP(this->pelec);
module_esolver/esolver_ks_lcao_elec.cpp:            IEP.begin(this->psi,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->pw_rho,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->pw_wfc,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->pw_big,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->LOWF,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->GG,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->wf.out_wfc_r,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->kv,
module_esolver/esolver_ks_lcao_elec.cpp:            IEP.begin(this->psi,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->pw_rho,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->pw_wfc,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->pw_big,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->LOWF,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->GK,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->wf.out_wfc_r,
module_esolver/esolver_ks_lcao_elec.cpp:                      this->kv,
module_esolver/esolver_ks_lcao_elec.cpp:    this->RA.for_2d(this->orb_con.ParaV, GlobalV::GAMMA_ONLY_LOCAL);
module_esolver/esolver_ks_lcao_elec.cpp:    this->LM.ParaV = &this->orb_con.ParaV;
module_esolver/esolver_ks_lcao_elec.cpp:    if (this->p_hamilt == nullptr)
module_esolver/esolver_ks_lcao_elec.cpp:        this->p_hamilt = new hamilt::HamiltLCAO<std::complex<double>, double>(&this->LM, this->kv);
module_esolver/esolver_ks_lcao_elec.cpp:        dynamic_cast<hamilt::OperatorLCAO<std::complex<double>, double>*>(this->p_hamilt->ops)->contributeHR();
module_esolver/esolver_ks_lcao_elec.cpp:    ModuleIO::output_SR(orb_con.ParaV, this->LM, GlobalC::GridD, this->p_hamilt, "SR.csr");
module_esolver/esolver_ks_lcao_elec.cpp:    this->RA.for_2d(this->orb_con.ParaV, GlobalV::GAMMA_ONLY_LOCAL);
module_esolver/esolver_ks_lcao_elec.cpp:    this->LM.ParaV = &this->orb_con.ParaV;
module_esolver/esolver_ks_lcao_elec.cpp:    if (this->p_hamilt == nullptr)
module_esolver/esolver_ks_lcao_elec.cpp:        this->p_hamilt = new hamilt::HamiltLCAO<std::complex<double>, std::complex<double>>(&this->LM, this->kv);
module_esolver/esolver_ks_lcao_elec.cpp:        dynamic_cast<hamilt::OperatorLCAO<std::complex<double>, std::complex<double>>*>(this->p_hamilt->ops)
module_esolver/esolver_ks_lcao_elec.cpp:    ModuleIO::output_SR(orb_con.ParaV, this->LM, GlobalC::GridD, this->p_hamilt, "SR.csr");
module_esolver/esolver_ks_lcao_elec.cpp:        // GlobalC::exx_lcao.cal_exx_elec_nscf(this->LOWF.ParaV[0]);
module_esolver/esolver_ks_lcao_elec.cpp:            this->exd->read_Hexxs_csr(file_name_exx, GlobalC::ucell);
module_esolver/esolver_ks_lcao_elec.cpp:            this->exc->read_Hexxs_csr(file_name_exx, GlobalC::ucell);
module_esolver/esolver_ks_lcao_elec.cpp:        hamilt::HamiltLCAO<TK, TR>* hamilt_lcao = dynamic_cast<hamilt::HamiltLCAO<TK, TR>*>(this->p_hamilt);
module_esolver/esolver_ks_lcao_elec.cpp:        auto exx = new hamilt::OperatorEXX<hamilt::OperatorLCAO<TK, TR>>(&this->LM,
module_esolver/esolver_ks_lcao_elec.cpp:                                                                         &(hamilt_lcao->getHk(&this->LM)),
module_esolver/esolver_ks_lcao_elec.cpp:                                                                         this->kv);
module_esolver/esolver_ks_lcao_elec.cpp:    if (this->phsol != nullptr)
module_esolver/esolver_ks_lcao_elec.cpp:        this->phsol->solve(this->p_hamilt, this->psi[0], this->pelec, GlobalV::KS_SOLVER, true);
module_esolver/esolver_ks_lcao_elec.cpp:    for (int ik = 0; ik < this->kv.nks; ik++)
module_esolver/esolver_ks_lcao_elec.cpp:            if (ik == (this->kv.nks / 2))
module_esolver/esolver_ks_lcao_elec.cpp:        GlobalV::ofs_running << " k-points" << ik + 1 << "(" << this->kv.nkstot << "): " << this->kv.kvec_c[ik].x << " "
module_esolver/esolver_ks_lcao_elec.cpp:                             << this->kv.kvec_c[ik].y << " " << this->kv.kvec_c[ik].z << std::endl;
module_esolver/esolver_ks_lcao_elec.cpp:            GlobalV::ofs_running << " spin" << this->kv.isk[ik] + 1 << "final_state " << ib + 1 << " "
module_esolver/esolver_ks_lcao_elec.cpp:                                 << this->pelec->ekb(ik, ib) * ModuleBase::Ry_to_eV << " "
module_esolver/esolver_ks_lcao_elec.cpp:                                 << this->pelec->wg(ik, ib) * this->kv.nks << std::endl;
module_esolver/esolver_ks_lcao_elec.cpp:            this->pelec->cal_bandgap();
module_esolver/esolver_ks_lcao_elec.cpp:            GlobalV::ofs_running << " E_bandgap " << this->pelec->bandgap * ModuleBase::Ry_to_eV << " eV" << std::endl;
module_esolver/esolver_ks_lcao_elec.cpp:            this->pelec->cal_bandgap_updw();
module_esolver/esolver_ks_lcao_elec.cpp:            GlobalV::ofs_running << " E_bandgap_up " << this->pelec->bandgap_up * ModuleBase::Ry_to_eV << " eV"
module_esolver/esolver_ks_lcao_elec.cpp:            GlobalV::ofs_running << " E_bandgap_dw " << this->pelec->bandgap_dw * ModuleBase::Ry_to_eV << " eV"
module_esolver/esolver_ks_lcao_elec.cpp:            myWannier.calculate(this->pelec->ekb,
module_esolver/esolver_ks_lcao_elec.cpp:                                this->pw_wfc,
module_esolver/esolver_ks_lcao_elec.cpp:                                this->pw_big,
module_esolver/esolver_ks_lcao_elec.cpp:                                this->sf,
module_esolver/esolver_ks_lcao_elec.cpp:                                this->kv,
module_esolver/esolver_ks_lcao_elec.cpp:                                this->psi,
module_esolver/esolver_ks_lcao_elec.cpp:                                this->LOWF.ParaV);
module_esolver/esolver_ks_lcao_elec.cpp:            myWannier.calculate(this->pelec->ekb, this->kv, *(this->psi), this->LOWF.ParaV);
module_esolver/esolver_ks_lcao_elec.cpp:        berryphase bp(this->LOWF);
module_esolver/esolver_ks_lcao_elec.cpp:        bp.Macroscopic_polarization(this->pw_wfc->npwk_max, this->psi, this->pw_rho, this->pw_wfc, this->kv);
module_esolver/esolver_ks_lcao_elec.cpp:    const Parallel_Orbitals* pv = this->LOWF.ParaV;
module_esolver/esolver_ks_lcao_elec.cpp:            = dynamic_cast<const elecstate::ElecStateLCAO<TK>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao_elec.cpp:        this->dpks_cal_projected_DM(dm);
module_esolver/esolver_ks_lcao_tddft.cpp:    // this->orb_con.clear_after_ions(GlobalC::UOT, GlobalC::ORB, GlobalV::deepks_setorb, GlobalC::ucell.infoNL.nproj);
module_esolver/esolver_ks_lcao_tddft.cpp:    if (this->pelec == nullptr)
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec = new elecstate::ElecStateLCAO_TDDFT(&(this->chr),
module_esolver/esolver_ks_lcao_tddft.cpp:														 &(this->LOC),
module_esolver/esolver_ks_lcao_tddft.cpp:														 &(this->GK), // mohan add 2024-04-01
module_esolver/esolver_ks_lcao_tddft.cpp:                                                         &(this->LOWF),
module_esolver/esolver_ks_lcao_tddft.cpp:                                                         this->pw_rho,
module_esolver/esolver_ks_lcao_tddft.cpp:    this->init_basis_lcao(this->orb_con, inp, ucell);
module_esolver/esolver_ks_lcao_tddft.cpp:    this->LM.divide_HS_in_frag(GlobalV::GAMMA_ONLY_LOCAL, orb_con.ParaV, kv.nks);
module_esolver/esolver_ks_lcao_tddft.cpp:    this->gen_h.LM = &this->LM;
module_esolver/esolver_ks_lcao_tddft.cpp:    this->LOC.ParaV = this->LOWF.ParaV = this->LM.ParaV;
module_esolver/esolver_ks_lcao_tddft.cpp:    dynamic_cast<elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->init_DM(&kv, this->LM.ParaV, GlobalV::NSPIN);
module_esolver/esolver_ks_lcao_tddft.cpp:    if (this->phsol == nullptr)
module_esolver/esolver_ks_lcao_tddft.cpp:        this->phsol = new hsolver::HSolverLCAO<std::complex<double>>(this->LOWF.ParaV);
module_esolver/esolver_ks_lcao_tddft.cpp:        this->phsol->method = GlobalV::KS_SOLVER;
module_esolver/esolver_ks_lcao_tddft.cpp:    this->pelec->charge->allocate(GlobalV::NSPIN);
module_esolver/esolver_ks_lcao_tddft.cpp:    this->pelec->omega = GlobalC::ucell.omega;
module_esolver/esolver_ks_lcao_tddft.cpp:    this->pelec->pot = new elecstate::Potential(pw_rhod,
module_esolver/esolver_ks_lcao_tddft.cpp:    this->pelec_td = dynamic_cast<elecstate::ElecStateLCAO_TDDFT*>(this->pelec);
module_esolver/esolver_ks_lcao_tddft.cpp:                                                 this->p_hamilt,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                 this->LOWF,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                 this->psi,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                 this->psi_laststep,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                 this->Hk_laststep,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                 this->Sk_laststep,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                 this->pelec_td->ekb,
module_esolver/esolver_ks_lcao_tddft.cpp:            this->pelec_td->psiToRho_td(this->psi[0]);
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec_td->psiToRho_td(this->psi[0]);
module_esolver/esolver_ks_lcao_tddft.cpp:                                             this->p_hamilt,
module_esolver/esolver_ks_lcao_tddft.cpp:                                             this->LOWF,
module_esolver/esolver_ks_lcao_tddft.cpp:                                             this->psi,
module_esolver/esolver_ks_lcao_tddft.cpp:                                             this->psi_laststep,
module_esolver/esolver_ks_lcao_tddft.cpp:                                             this->Hk_laststep,
module_esolver/esolver_ks_lcao_tddft.cpp:                                             this->Sk_laststep,
module_esolver/esolver_ks_lcao_tddft.cpp:                                             this->pelec_td->ekb,
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec_td->psiToRho_td(this->psi[0]);
module_esolver/esolver_ks_lcao_tddft.cpp:    else if (this->phsol != nullptr)
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec->f_en.eband = 0.0;
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec->f_en.demet = 0.0;
module_esolver/esolver_ks_lcao_tddft.cpp:        if (this->psi != nullptr)
module_esolver/esolver_ks_lcao_tddft.cpp:			this->phsol->solve(
module_esolver/esolver_ks_lcao_tddft.cpp:					this->p_hamilt,
module_esolver/esolver_ks_lcao_tddft.cpp:					this->psi[0],
module_esolver/esolver_ks_lcao_tddft.cpp:					this->pelec_td,
module_esolver/esolver_ks_lcao_tddft.cpp:					<< this->pelec_td->wg(ik, ib)
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec_td->print_band(ik, INPUT.printe, iter);
module_esolver/esolver_ks_lcao_tddft.cpp:    this->pelec->cal_energies(1);
module_esolver/esolver_ks_lcao_tddft.cpp:    GlobalC::ucell.magnet.compute_magnetization(this->pelec->charge->nrxx,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                this->pelec->charge->nxyz,
module_esolver/esolver_ks_lcao_tddft.cpp:                                                this->pelec->charge->rho,
module_esolver/esolver_ks_lcao_tddft.cpp:    this->pelec->f_en.deband = this->pelec->cal_delta_eband();
module_esolver/esolver_ks_lcao_tddft.cpp:    if (this->conv_elec)
module_esolver/esolver_ks_lcao_tddft.cpp:            this->GK.renew(true);
module_esolver/esolver_ks_lcao_tddft.cpp:                this->p_hamilt->updateHk(ik);
module_esolver/esolver_ks_lcao_tddft.cpp:            if (this->psi != nullptr && (istep % GlobalV::out_interval == 0))
module_esolver/esolver_ks_lcao_tddft.cpp:                this->p_hamilt->matrix(h_mat, s_mat);
module_esolver/esolver_ks_lcao_tddft.cpp:							*this->LOWF.ParaV,
module_esolver/esolver_ks_lcao_tddft.cpp:							*this->LOWF.ParaV,
module_esolver/esolver_ks_lcao_tddft.cpp:    if (this->conv_elec)
module_esolver/esolver_ks_lcao_tddft.cpp:                    this->psi[0].fix_k(ik);
module_esolver/esolver_ks_lcao_tddft.cpp:                    this->pelec->print_psi(this->psi[0], istep);
module_esolver/esolver_ks_lcao_tddft.cpp:    if (!this->conv_elec)
module_esolver/esolver_ks_lcao_tddft.cpp:		this->pelec->pot->update_from_charge(this->pelec->charge, &GlobalC::ucell);
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec->f_en.descf = this->pelec->cal_delta_escf();
module_esolver/esolver_ks_lcao_tddft.cpp:        this->pelec->cal_converged();
module_esolver/esolver_ks_lcao_tddft.cpp:    if (istep >= (wf.init_wfc == "file" ? 0 : 1) && this->conv_elec)
module_esolver/esolver_ks_lcao_tddft.cpp:		if (this->psi_laststep == nullptr)
module_esolver/esolver_ks_lcao_tddft.cpp:			this->psi_laststep = new psi::Psi<std::complex<double>>(kv.nks,
module_esolver/esolver_ks_lcao_tddft.cpp:					this->LOWF.ParaV->ncol_bands,
module_esolver/esolver_ks_lcao_tddft.cpp:					this->LOWF.ParaV->nrow,
module_esolver/esolver_ks_lcao_tddft.cpp:			this->psi_laststep = new psi::Psi<std::complex<double>>(kv.nks, GlobalV::NBANDS, GlobalV::NLOCAL, nullptr);
module_esolver/esolver_ks_lcao_tddft.cpp:            if (this->Hk_laststep == nullptr)
module_esolver/esolver_ks_lcao_tddft.cpp:                this->Hk_laststep = new std::complex<double>*[kv.nks];
module_esolver/esolver_ks_lcao_tddft.cpp:                    this->Hk_laststep[ik] = new std::complex<double>[this->LOC.ParaV->nloc];
module_esolver/esolver_ks_lcao_tddft.cpp:                    ModuleBase::GlobalFunc::ZEROS(Hk_laststep[ik], this->LOC.ParaV->nloc);
module_esolver/esolver_ks_lcao_tddft.cpp:            if (this->Sk_laststep == nullptr)
module_esolver/esolver_ks_lcao_tddft.cpp:                this->Sk_laststep = new std::complex<double>*[kv.nks];
module_esolver/esolver_ks_lcao_tddft.cpp:                    this->Sk_laststep[ik] = new std::complex<double>[this->LOC.ParaV->nloc];
module_esolver/esolver_ks_lcao_tddft.cpp:                    ModuleBase::GlobalFunc::ZEROS(Sk_laststep[ik], this->LOC.ParaV->nloc);
module_esolver/esolver_ks_lcao_tddft.cpp:            this->psi->fix_k(ik);
module_esolver/esolver_ks_lcao_tddft.cpp:            this->psi_laststep->fix_k(ik);
module_esolver/esolver_ks_lcao_tddft.cpp:                this->p_hamilt->updateHk(ik);
module_esolver/esolver_ks_lcao_tddft.cpp:                this->p_hamilt->matrix(h_mat, s_mat);
module_esolver/esolver_ks_lcao_tddft.cpp:                BlasConnector::copy(this->LOC.ParaV->nloc, h_mat.p, 1, Hk_laststep[ik], 1);
module_esolver/esolver_ks_lcao_tddft.cpp:                BlasConnector::copy(this->LOC.ParaV->nloc, s_mat.p, 1, Sk_laststep[ik], 1);
module_esolver/esolver_ks_lcao_tddft.cpp:            this->cal_edm_tddft();
module_esolver/esolver_ks_lcao_tddft.cpp:    if (this->conv_elec)
module_esolver/esolver_ks_lcao_tddft.cpp:                                     << this->pelec_td->ekb(ik, ib) * ModuleBase::Ry_to_eV << std::endl;
module_esolver/esolver_ks_lcao_tddft.cpp:        dynamic_cast<elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->get_DM();
module_esolver/esolver_ks_lcao_tddft.cpp:                        this->psi,
module_esolver/esolver_ks_lcao_tddft.cpp:                        this->RA,
module_esolver/esolver_ks_lcao_tddft.cpp:						this->LM, // mohan add 2024-04-02
module_esolver/esolver_ks_lcao_tddft.cpp:						this->gen_h); // mohan add 2024-02
module_esolver/esolver_ks_lcao_tddft.cpp:    //this->LOC.edm_k_tddft.resize(kv.nks);
module_esolver/esolver_ks_lcao_tddft.cpp:    dynamic_cast<elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->get_DM()->EDMK.resize(kv.nks);
module_esolver/esolver_ks_lcao_tddft.cpp:        dynamic_cast<elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->get_DM()->get_DMK_pointer(ik);
module_esolver/esolver_ks_lcao_tddft.cpp:        dynamic_cast<elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->get_DM()->EDMK[ik];
module_esolver/esolver_ks_lcao_tddft.cpp:        dynamic_cast<elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->get_DM()->get_paraV_pointer();
module_esolver/esolver_ks_lcao_tddft.cpp:        const long nloc = this->LOC.ParaV->nloc;
module_esolver/esolver_ks_lcao_tddft.cpp:        //this->LOC.edm_k_tddft[ik].create(this->LOC.ParaV->ncol, this->LOC.ParaV->nrow);
module_esolver/esolver_ks_lcao_tddft.cpp:        tmp_edmk.create(this->LOC.ParaV->ncol, this->LOC.ParaV->nrow);
module_esolver/esolver_ks_lcao_tddft.cpp:        int nrow = this->LOC.ParaV->nrow;
module_esolver/esolver_ks_lcao_tddft.cpp:        int ncol = this->LOC.ParaV->ncol;
module_esolver/esolver_ks_lcao_tddft.cpp:        pzgetrf_(&nlocal, &nlocal, Sinv, &one_int, &one_int, this->LOC.ParaV->desc, ipiv, &info);
module_esolver/esolver_ks_lcao_tddft.cpp:                 this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                 this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc);
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc);
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc);
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                this->LOC.ParaV->desc);
module_esolver/esolver_ks_lcao_tddft.cpp:                 this->LOC.ParaV->desc,
module_esolver/esolver_ks_lcao_tddft.cpp:                 this->LOC.ParaV->desc);
module_esolver/esolver_ks_lcao_tddft.cpp:        //zcopy_(&nloc, tmp4, &inc, this->LOC.edm_k_tddft[ik].c, &inc);
module_esolver/esolver_ks_lcao_tddft.cpp:        //this->LOC.edm_k_tddft[ik].create(this->LOC.ParaV->ncol, this->LOC.ParaV->nrow);
module_esolver/esolver_ks_lcao_tddft.cpp:        tmp_edmk.create(this->LOC.ParaV->ncol, this->LOC.ParaV->nrow);
module_esolver/esolver_ks_lcao_tmpfunc.cpp:				this->p_chgmix->get_mixing_beta());
module_esolver/esolver_ks_lcao_tmpfunc.cpp:                 this->kv, 
module_esolver/esolver_ks_lcao_tmpfunc.cpp:                 this->p_chgmix->get_mixing_beta(), 
module_esolver/esolver_ks_lcao_tmpfunc.cpp:                 this->p_hamilt);
module_esolver/esolver_ks_lcao_tmpfunc.cpp:                 this->kv, 
module_esolver/esolver_ks_lcao_tmpfunc.cpp:                 this->p_chgmix->get_mixing_beta(), 
module_esolver/esolver_ks_lcao_tmpfunc.cpp:                 this->p_hamilt);
module_esolver/esolver_ks_lcao_tmpfunc.cpp:        GlobalC::ld.cal_e_delta_band_k(dm, this->kv.nks);
module_esolver/esolver_ks_lcao_tmpfunc.cpp:        GlobalC::ld.cal_e_delta_band_k(dm, this->kv.nks);
module_esolver/esolver_ks_pw.cpp:    this->classname = "ESolver_KS_PW";
module_esolver/esolver_ks_pw.cpp:    this->basisname = "PW";
module_esolver/esolver_ks_pw.cpp:    this->device = psi::device::get_device_type<Device>(this->ctx);
module_esolver/esolver_ks_pw.cpp:    if (this->device == psi::GpuDevice)
module_esolver/esolver_ks_pw.cpp:    if (this->phsol != nullptr)
module_esolver/esolver_ks_pw.cpp:        delete reinterpret_cast<hsolver::HSolverPW<T, Device>*>(this->phsol);
module_esolver/esolver_ks_pw.cpp:        this->phsol = nullptr;
module_esolver/esolver_ks_pw.cpp:    if (this->pelec != nullptr)
module_esolver/esolver_ks_pw.cpp:        delete reinterpret_cast<elecstate::ElecStatePW<T, Device>*>(this->pelec);
module_esolver/esolver_ks_pw.cpp:        this->pelec = nullptr;
module_esolver/esolver_ks_pw.cpp:    if (this->p_hamilt != nullptr)
module_esolver/esolver_ks_pw.cpp:        delete reinterpret_cast<hamilt::HamiltPW<T, Device>*>(this->p_hamilt);
module_esolver/esolver_ks_pw.cpp:        this->p_hamilt = nullptr;
module_esolver/esolver_ks_pw.cpp:    if (this->device == psi::GpuDevice)
module_esolver/esolver_ks_pw.cpp:        delete reinterpret_cast<psi::Psi<T, Device>*>(this->kspw_psi);
module_esolver/esolver_ks_pw.cpp:        delete reinterpret_cast<psi::Psi<std::complex<double>, Device>*>(this->__kspw_psi);
module_esolver/esolver_ks_pw.cpp:    delete this->psi;
module_esolver/esolver_ks_pw.cpp:    if (this->psi != nullptr)
module_esolver/esolver_ks_pw.cpp:        delete this->psi;
module_esolver/esolver_ks_pw.cpp:        this->psi = this->psi_init->allocate();
module_esolver/esolver_ks_pw.cpp:        this->psi = this->wf.allocate(this->kv.nkstot, this->kv.nks, this->kv.ngk.data(), this->pw_wfc->npwk_max);
module_esolver/esolver_ks_pw.cpp:    GlobalC::ppcell.init(GlobalC::ucell.ntype, &this->sf, this->pw_wfc);
module_esolver/esolver_ks_pw.cpp:    GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rhod);
module_esolver/esolver_ks_pw.cpp:    GlobalC::ppcell.init_vnl(GlobalC::ucell, this->pw_rhod);
module_esolver/esolver_ks_pw.cpp:        this->wf.init_at_1(&this->sf);
module_esolver/esolver_ks_pw.cpp:        this->wf.wfcinit(this->psi, this->pw_wfc);
module_esolver/esolver_ks_pw.cpp:    this->kspw_psi = GlobalV::device_flag == "gpu" 
module_esolver/esolver_ks_pw.cpp:                         ? new psi::Psi<T, Device>(this->psi[0])
module_esolver/esolver_ks_pw.cpp:                         : reinterpret_cast<psi::Psi<T, Device>*>(this->psi);
module_esolver/esolver_ks_pw.cpp:		this->kspw_psi = new psi::Psi<T, Device>(this->psi[0]);
module_esolver/esolver_ks_pw.cpp:		this->kspw_psi = reinterpret_cast<psi::Psi<T, Device>*>(this->psi);
module_esolver/esolver_ks_pw.cpp:        ModuleBase::Memory::record("Psi_single", sizeof(T) * this->psi[0].size());
module_esolver/esolver_ks_pw.cpp:    if (this->phsol == nullptr)
module_esolver/esolver_ks_pw.cpp:        this->phsol = new hsolver::HSolverPW<T, Device>(this->pw_wfc, &this->wf);
module_esolver/esolver_ks_pw.cpp:    if (this->pelec == nullptr)
module_esolver/esolver_ks_pw.cpp:        this->pelec = new elecstate::ElecStatePW<T, Device>(this->pw_wfc,
module_esolver/esolver_ks_pw.cpp:                                                            &(this->chr),
module_esolver/esolver_ks_pw.cpp:                                                            &(this->kv),
module_esolver/esolver_ks_pw.cpp:                                                            this->pw_rhod,
module_esolver/esolver_ks_pw.cpp:                                                            this->pw_rho,
module_esolver/esolver_ks_pw.cpp:                                                            this->pw_big);
module_esolver/esolver_ks_pw.cpp:    this->pelec->charge->allocate(GlobalV::NSPIN);
module_esolver/esolver_ks_pw.cpp:    this->pelec->omega = GlobalC::ucell.omega;
module_esolver/esolver_ks_pw.cpp:    if (this->pelec->pot == nullptr)
module_esolver/esolver_ks_pw.cpp:        this->pelec->pot = new elecstate::Potential(this->pw_rhod,
module_esolver/esolver_ks_pw.cpp:                                                    this->pw_rho,
module_esolver/esolver_ks_pw.cpp:                                                    &(this->sf),
module_esolver/esolver_ks_pw.cpp:                                                    &(this->pelec->f_en.etxc),
module_esolver/esolver_ks_pw.cpp:                                                    &(this->pelec->f_en.vtxc));
module_esolver/esolver_ks_pw.cpp:        this->allocate_psi_init();
module_esolver/esolver_ks_pw.cpp:    this->Init_GlobalC(inp, ucell);
module_esolver/esolver_ks_pw.cpp:        this->pelec->fixed_weights(GlobalV::ocp_kb);
module_esolver/esolver_ks_pw.cpp:		this->pw_wfc->initgrids(
module_esolver/esolver_ks_pw.cpp:				this->pw_rho->nx, 
module_esolver/esolver_ks_pw.cpp:				this->pw_rho->ny, 
module_esolver/esolver_ks_pw.cpp:				this->pw_rho->nz);
module_esolver/esolver_ks_pw.cpp:		this->pw_wfc->initparameters(
module_esolver/esolver_ks_pw.cpp:				this->kv.nks, 
module_esolver/esolver_ks_pw.cpp:				this->kv.kvec_d.data());
module_esolver/esolver_ks_pw.cpp:			MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
module_esolver/esolver_ks_pw.cpp:        this->pw_wfc->setuptransform();
module_esolver/esolver_ks_pw.cpp:        for (int ik = 0; ik < this->kv.nks; ++ik)
module_esolver/esolver_ks_pw.cpp:            this->kv.ngk[ik] = this->pw_wfc->npwk[ik];
module_esolver/esolver_ks_pw.cpp:        this->pw_wfc->collect_local_pw(inp.erf_ecut, inp.erf_height, inp.erf_sigma);
module_esolver/esolver_ks_pw.cpp:        delete this->phsol;
module_esolver/esolver_ks_pw.cpp:        this->phsol = new hsolver::HSolverPW<T, Device>(this->pw_wfc, &this->wf);
module_esolver/esolver_ks_pw.cpp:        delete this->pelec;
module_esolver/esolver_ks_pw.cpp:        this->pelec = new elecstate::ElecStatePW<T, Device>(this->pw_wfc,
module_esolver/esolver_ks_pw.cpp:                                                            &(this->chr),
module_esolver/esolver_ks_pw.cpp:                                                            (K_Vectors*)(&(this->kv)),
module_esolver/esolver_ks_pw.cpp:                                                            this->pw_rhod,
module_esolver/esolver_ks_pw.cpp:                                                            this->pw_rho,
module_esolver/esolver_ks_pw.cpp:                                                            this->pw_big);
module_esolver/esolver_ks_pw.cpp:        this->pelec->charge->allocate(GlobalV::NSPIN);
module_esolver/esolver_ks_pw.cpp:        this->pelec->omega = GlobalC::ucell.omega;
module_esolver/esolver_ks_pw.cpp:        delete this->pelec->pot;
module_esolver/esolver_ks_pw.cpp:        this->pelec->pot = new elecstate::Potential(this->pw_rhod,
module_esolver/esolver_ks_pw.cpp:                                                    this->pw_rho,
module_esolver/esolver_ks_pw.cpp:                                                    &(this->sf),
module_esolver/esolver_ks_pw.cpp:                                                    &(this->pelec->f_en.etxc),
module_esolver/esolver_ks_pw.cpp:                                                    &(this->pelec->f_en.vtxc));
module_esolver/esolver_ks_pw.cpp:        this->Init_GlobalC(inp, ucell);
module_esolver/esolver_ks_pw.cpp:        GlobalC::ppcell.init_vnl(GlobalC::ucell, this->pw_rhod);
module_esolver/esolver_ks_pw.cpp:        this->pw_wfc->initgrids(GlobalC::ucell.lat0,
module_esolver/esolver_ks_pw.cpp:                                this->pw_wfc->nx,
module_esolver/esolver_ks_pw.cpp:                                this->pw_wfc->ny,
module_esolver/esolver_ks_pw.cpp:                                this->pw_wfc->nz);
module_esolver/esolver_ks_pw.cpp:        this->pw_wfc->initparameters(false, INPUT.ecutwfc, this->kv.nks, this->kv.kvec_d.data());
module_esolver/esolver_ks_pw.cpp:        this->pw_wfc->collect_local_pw(inp.erf_ecut, inp.erf_height, inp.erf_sigma);
module_esolver/esolver_ks_pw.cpp:				this->psi_init->tabulate(); 
module_esolver/esolver_ks_pw.cpp:            this->wf.init_after_vc(this->kv.nks); // reallocate wanf2, the planewave expansion of lcao
module_esolver/esolver_ks_pw.cpp:            this->wf.init_at_1(&this->sf); // re-calculate tab_at, the overlap matrix between atomic pswfc and jlq
module_esolver/esolver_ks_pw.cpp:        GlobalC::paw_cell.set_libpaw_fft(this->pw_wfc->nx,this->pw_wfc->ny,this->pw_wfc->nz,
module_esolver/esolver_ks_pw.cpp:                                         this->pw_wfc->nx,this->pw_wfc->ny,this->pw_wfc->nz,
module_esolver/esolver_ks_pw.cpp:                                         this->pw_wfc->startz,this->pw_wfc->numz);
module_esolver/esolver_ks_pw.cpp:        this->init_after_vc(INPUT, GlobalC::ucell);
module_esolver/esolver_ks_pw.cpp:        this->CE.update_all_dis(GlobalC::ucell);
module_esolver/esolver_ks_pw.cpp:        this->CE.extrapolate_charge(
module_esolver/esolver_ks_pw.cpp:            this->pelec->charge,
module_esolver/esolver_ks_pw.cpp:            &this->sf);
module_esolver/esolver_ks_pw.cpp:    if (this->p_hamilt != nullptr)
module_esolver/esolver_ks_pw.cpp:        delete reinterpret_cast<hamilt::HamiltPW<T, Device>*>(this->p_hamilt);
module_esolver/esolver_ks_pw.cpp:        this->p_hamilt = nullptr;
module_esolver/esolver_ks_pw.cpp:    if (this->p_hamilt == nullptr)
module_esolver/esolver_ks_pw.cpp:		this->p_hamilt = new hamilt::HamiltPW<T, Device>(
module_esolver/esolver_ks_pw.cpp:				this->pelec->pot, 
module_esolver/esolver_ks_pw.cpp:				this->pw_wfc, 
module_esolver/esolver_ks_pw.cpp:				&this->kv);
module_esolver/esolver_ks_pw.cpp:        this->pelec->f_en.evdw = vdw_solver->get_energy();
module_esolver/esolver_ks_pw.cpp:		this->pelec->f_en.ewald_energy = H_Ewald_pw::compute_ewald(
module_esolver/esolver_ks_pw.cpp:				this->pw_rhod, 
module_esolver/esolver_ks_pw.cpp:				this->sf.strucFac);
module_esolver/esolver_ks_pw.cpp:    this->pelec->init_scf(istep, this->sf.strucFac);
module_esolver/esolver_ks_pw.cpp:				*(this->pelec->charge), 
module_esolver/esolver_ks_pw.cpp:				this->pw_rhod, 
module_esolver/esolver_ks_pw.cpp:    ModuleBase::matrix veff = this->pelec->pot->get_effective_v();
module_esolver/esolver_ks_pw.cpp:    GlobalC::ppcell.cal_effective_D(veff, this->pw_rhod, GlobalC::ucell);
module_esolver/esolver_ks_pw.cpp:			this->initialize_psi();
module_esolver/esolver_ks_pw.cpp:        Cal_Test::test_memory(this->pw_rho,
module_esolver/esolver_ks_pw.cpp:                              this->pw_wfc,
module_esolver/esolver_ks_pw.cpp:                              this->p_chgmix->get_mixing_mode(),
module_esolver/esolver_ks_pw.cpp:                              this->p_chgmix->get_mixing_ndim());
module_esolver/esolver_ks_pw.cpp:        nc.output_descriptor(this->psi[0],
module_esolver/esolver_ks_pw.cpp:                             this->kv.nks);
module_esolver/esolver_ks_pw.cpp:        this->nscf();
module_esolver/esolver_ks_pw.cpp:        this->p_chgmix->init_mixing();
module_esolver/esolver_ks_pw.cpp:        this->p_chgmix->mixing_restart_step = GlobalV::SCF_NMAX + 1;
module_esolver/esolver_ks_pw.cpp:    if (iter == this->p_chgmix->mixing_restart_step && GlobalV::MIXING_RESTART > 0.0)
module_esolver/esolver_ks_pw.cpp:        this->p_chgmix->init_mixing();
module_esolver/esolver_ks_pw.cpp:    this->pelec->f_en.deband_harris = this->pelec->cal_delta_eband();
module_esolver/esolver_ks_pw.cpp:        this->pelec->charge->save_rho_before_sum_band();
module_esolver/esolver_ks_pw.cpp:		this->psi_init = std::unique_ptr<psi_initializer<T, Device>>(
module_esolver/esolver_ks_pw.cpp:		this->psi_init = std::unique_ptr<psi_initializer<T, Device>>(
module_esolver/esolver_ks_pw.cpp:		this->psi_init = std::unique_ptr<psi_initializer<T, Device>>(
module_esolver/esolver_ks_pw.cpp:		this->psi_init = std::unique_ptr<psi_initializer<T, Device>>(
module_esolver/esolver_ks_pw.cpp:		this->psi_init = std::unique_ptr<psi_initializer<T, Device>>(
module_esolver/esolver_ks_pw.cpp:		this->psi_init = std::unique_ptr<psi_initializer<T, Device>>(
module_esolver/esolver_ks_pw.cpp:	this->psi_init->initialize(
module_esolver/esolver_ks_pw.cpp:			&this->sf, 
module_esolver/esolver_ks_pw.cpp:			this->pw_wfc, 
module_esolver/esolver_ks_pw.cpp:	this->psi_init->initialize(
module_esolver/esolver_ks_pw.cpp:			&this->sf, 
module_esolver/esolver_ks_pw.cpp:			this->pw_wfc, 
module_esolver/esolver_ks_pw.cpp:    this->psi_init->tabulate();
module_esolver/esolver_ks_pw.cpp:        for (int ik = 0; ik < this->pw_wfc->nks; ik++)
module_esolver/esolver_ks_pw.cpp:            this->psi->fix_k(ik);
module_esolver/esolver_ks_pw.cpp:            this->p_hamilt->updateHk(ik);
module_esolver/esolver_ks_pw.cpp:            this->psi_init->proj_ao_onkG(ik);
module_esolver/esolver_ks_pw.cpp:            std::weak_ptr<psi::Psi<T, Device>> psig = this->psi_init->share_psig();
module_esolver/esolver_ks_pw.cpp:            if (this->psi_init->method() != "random")
module_esolver/esolver_ks_pw.cpp:                        this->p_hamilt,
module_esolver/esolver_ks_pw.cpp:						*(this->kspw_psi), 
module_esolver/esolver_ks_pw.cpp:							this->p_hamilt,
module_esolver/esolver_ks_pw.cpp:							*(this->kspw_psi), 
module_esolver/esolver_ks_pw.cpp:            for (int iband = 0; iband < this->kspw_psi->get_nbands(); iband++)
module_esolver/esolver_ks_pw.cpp:                for (int ibasis = 0; ibasis < this->kspw_psi->get_nbasis(); ibasis++)
module_esolver/esolver_ks_pw.cpp:                    (*(this->kspw_psi))(iband, ibasis) = (*psig_)(iband, ibasis);
module_esolver/esolver_ks_pw.cpp:        this->psi_init->set_initialized(true);
module_esolver/esolver_ks_pw.cpp:    if (this->phsol != nullptr)
module_esolver/esolver_ks_pw.cpp:        this->pelec->f_en.eband = 0.0;
module_esolver/esolver_ks_pw.cpp:        this->pelec->f_en.demet = 0.0;
module_esolver/esolver_ks_pw.cpp:					&&!(this->psi_init->initialized())) 
module_esolver/esolver_ks_pw.cpp:				this->initialize_psi();
module_esolver/esolver_ks_pw.cpp:            this->phsol->solve(this->p_hamilt,      // hamilt::Hamilt<T, Device>* pHamilt,
module_esolver/esolver_ks_pw.cpp:                               this->kspw_psi[0],   // psi::Psi<T, Device>& psi,
module_esolver/esolver_ks_pw.cpp:                               this->pelec,         // elecstate::ElecState<T, Device>* pelec,
module_esolver/esolver_ks_pw.cpp:            std::weak_ptr<psi::Psi<T, Device>> psig = this->psi_init->share_psig();
module_esolver/esolver_ks_pw.cpp:            this->phsol->solve(this->p_hamilt,          // hamilt::Hamilt<T, Device>* pHamilt,
module_esolver/esolver_ks_pw.cpp:                               this->kspw_psi[0],       // psi::Psi<T, Device>& psi,
module_esolver/esolver_ks_pw.cpp:                               this->pelec,             // elecstate::ElecState<T, Device>* pelec,
module_esolver/esolver_ks_pw.cpp:				this->pelec->cal_bandgap();
module_esolver/esolver_ks_pw.cpp:				this->pelec->cal_bandgap_updw();
module_esolver/esolver_ks_pw.cpp:    this->pelec->set_exx(GlobalC::exx_lip.get_exx_energy()); // Peize Lin add 2019-03-09
module_esolver/esolver_ks_pw.cpp:    this->pelec->cal_energies(1);
module_esolver/esolver_ks_pw.cpp:				*(this->pelec->charge), 
module_esolver/esolver_ks_pw.cpp:				this->pw_rhod, 
module_esolver/esolver_ks_pw.cpp:    GlobalC::ucell.magnet.compute_magnetization(this->pelec->charge->nrxx,
module_esolver/esolver_ks_pw.cpp:                                                this->pelec->charge->nxyz,
module_esolver/esolver_ks_pw.cpp:                                                this->pelec->charge->rho,
module_esolver/esolver_ks_pw.cpp:                                                this->pelec->nelec_spin.data());
module_esolver/esolver_ks_pw.cpp:    this->pelec->f_en.deband = this->pelec->cal_delta_eband();
module_esolver/esolver_ks_pw.cpp:    if (!this->conv_elec)
module_esolver/esolver_ks_pw.cpp:		this->pelec->pot->update_from_charge(this->pelec->charge, &GlobalC::ucell);
module_esolver/esolver_ks_pw.cpp:        this->pelec->f_en.descf = this->pelec->cal_delta_escf();
module_esolver/esolver_ks_pw.cpp:        this->pelec->cal_converged();
module_esolver/esolver_ks_pw.cpp:        ModuleBase::matrix veff = this->pelec->pot->get_effective_v();
module_esolver/esolver_ks_pw.cpp:        GlobalC::ppcell.cal_effective_D(veff, this->pw_rhod, GlobalC::ucell);
module_esolver/esolver_ks_pw.cpp:    this->pelec->cal_energies(2);
module_esolver/esolver_ks_pw.cpp:    if (this->out_freq_elec && iter % this->out_freq_elec == 0)
module_esolver/esolver_ks_pw.cpp:                this->create_Output_Rho(is, iter, "tmp_").write();
module_esolver/esolver_ks_pw.cpp:                    this->create_Output_Kin(is, iter, "tmp_").write();
module_esolver/esolver_ks_pw.cpp:        if (this->wf.out_wfc_pw == 1 || this->wf.out_wfc_pw == 2)
module_esolver/esolver_ks_pw.cpp:            ModuleIO::write_wfc_pw(ssw.str(), this->psi[0], this->kv, this->pw_wfc);
module_esolver/esolver_ks_pw.cpp:    this->create_Output_Potential(istep).write();
module_esolver/esolver_ks_pw.cpp:        this->CE.save_files(istep,
module_esolver/esolver_ks_pw.cpp:                            this->pw_big,
module_esolver/esolver_ks_pw.cpp:                            this->pelec->charge,
module_esolver/esolver_ks_pw.cpp:                            &this->sf);
module_esolver/esolver_ks_pw.cpp:            this->create_Output_Rho(is, istep).write();
module_esolver/esolver_ks_pw.cpp:                this->create_Output_Kin(is, istep).write();
module_esolver/esolver_ks_pw.cpp:	if (this->wf.out_wfc_pw == 1 
module_esolver/esolver_ks_pw.cpp:			|| this->wf.out_wfc_pw == 2)
module_esolver/esolver_ks_pw.cpp:        ModuleIO::write_wfc_pw(ssw.str(), this->psi[0], this->kv, this->pw_wfc);
module_esolver/esolver_ks_pw.cpp:    ModuleIO::output_convergence_after_scf(this->conv_elec, this->pelec->f_en.etot);
module_esolver/esolver_ks_pw.cpp:    ModuleIO::output_efermi(this->conv_elec, this->pelec->eferm.ef); 
module_esolver/esolver_ks_pw.cpp:        this->pelec->print_eigenvalue(GlobalV::ofs_running);
module_esolver/esolver_ks_pw.cpp:    if (this->device == psi::GpuDevice)
module_esolver/esolver_ks_pw.cpp:        castmem_2d_d2h_op()(this->psi[0].get_device(),
module_esolver/esolver_ks_pw.cpp:                            this->kspw_psi[0].get_device(),
module_esolver/esolver_ks_pw.cpp:                            this->psi[0].get_pointer() - this->psi[0].get_psi_bias(),
module_esolver/esolver_ks_pw.cpp:                            this->kspw_psi[0].get_pointer() - this->kspw_psi[0].get_psi_bias(),
module_esolver/esolver_ks_pw.cpp:                            this->psi[0].size());
module_esolver/esolver_ks_pw.cpp:        bands_picked.resize(this->kspw_psi->get_nbands());
module_esolver/esolver_ks_pw.cpp:        ModuleBase::GlobalFunc::ZEROS(bands_picked.data(), this->kspw_psi->get_nbands());
module_esolver/esolver_ks_pw.cpp:        if (static_cast<int>(out_band_kb.size()) > this->kspw_psi->get_nbands())
module_esolver/esolver_ks_pw.cpp:        int length = std::min(static_cast<int>(out_band_kb.size()), this->kspw_psi->get_nbands());
module_esolver/esolver_ks_pw.cpp:        std::complex<double>* wfcr = new std::complex<double>[this->pw_rho->nxyz];
module_esolver/esolver_ks_pw.cpp:        double* rho_band = new double[this->pw_rho->nxyz];
module_esolver/esolver_ks_pw.cpp:        for (int ib = 0; ib < this->kspw_psi->get_nbands(); ++ib)
module_esolver/esolver_ks_pw.cpp:            for (int i = 0; i < this->pw_rho->nxyz; i++)
module_esolver/esolver_ks_pw.cpp:            for (int ik = 0; ik < this->kv.nks; ik++)
module_esolver/esolver_ks_pw.cpp:                this->psi->fix_k(ik);
module_esolver/esolver_ks_pw.cpp:                this->pw_wfc->recip_to_real(this->ctx, &psi[0](ib, 0), wfcr, ik);
module_esolver/esolver_ks_pw.cpp:                double w1 = static_cast<double>(this->kv.wk[ik] / GlobalC::ucell.omega);
module_esolver/esolver_ks_pw.cpp:                for (int i = 0; i < this->pw_rho->nxyz; i++)
module_esolver/esolver_ks_pw.cpp:                this->pw_big->bz,
module_esolver/esolver_ks_pw.cpp:                this->pw_big->nbz,
module_esolver/esolver_ks_pw.cpp:                this->pw_big->nplane,
module_esolver/esolver_ks_pw.cpp:                this->pw_big->startz_current,
module_esolver/esolver_ks_pw.cpp:                this->pw_rho->nx,
module_esolver/esolver_ks_pw.cpp:                this->pw_rho->ny,
module_esolver/esolver_ks_pw.cpp:                this->pw_rho->nz,
module_esolver/esolver_ks_pw.cpp:    return this->pelec->f_en.etot;
module_esolver/esolver_ks_pw.cpp:	if (this->__kspw_psi != nullptr)
module_esolver/esolver_ks_pw.cpp:		this->__kspw_psi = nullptr;
module_esolver/esolver_ks_pw.cpp:	if (this->__kspw_psi == nullptr)
module_esolver/esolver_ks_pw.cpp:        this->__kspw_psi = GlobalV::precision_flag == "single"
module_esolver/esolver_ks_pw.cpp:                               ? new psi::Psi<std::complex<double>, Device>(this->kspw_psi[0])
module_esolver/esolver_ks_pw.cpp:                               : reinterpret_cast<psi::Psi<std::complex<double>, Device>*>(this->kspw_psi);
module_esolver/esolver_ks_pw.cpp:			*this->pelec, 
module_esolver/esolver_ks_pw.cpp:			this->pw_rhod, 
module_esolver/esolver_ks_pw.cpp:			&this->sf, 
module_esolver/esolver_ks_pw.cpp:			&this->kv, 
module_esolver/esolver_ks_pw.cpp:			this->pw_wfc, 
module_esolver/esolver_ks_pw.cpp:			this->__kspw_psi);
module_esolver/esolver_ks_pw.cpp:    Stress_PW<double, Device> ss(this->pelec);
module_esolver/esolver_ks_pw.cpp:    if (this->__kspw_psi != nullptr)
module_esolver/esolver_ks_pw.cpp:        this->__kspw_psi = nullptr;
module_esolver/esolver_ks_pw.cpp:    if (this->__kspw_psi == nullptr)
module_esolver/esolver_ks_pw.cpp:		this->__kspw_psi = GlobalV::precision_flag == "single"
module_esolver/esolver_ks_pw.cpp:			? new psi::Psi<std::complex<double>, Device>(this->kspw_psi[0])
module_esolver/esolver_ks_pw.cpp:			: reinterpret_cast<psi::Psi<std::complex<double>, Device>*>(this->kspw_psi);
module_esolver/esolver_ks_pw.cpp:			this->pw_rhod,
module_esolver/esolver_ks_pw.cpp:			&this->sf,
module_esolver/esolver_ks_pw.cpp:			&this->kv,
module_esolver/esolver_ks_pw.cpp:			this->pw_wfc,
module_esolver/esolver_ks_pw.cpp:			this->psi,
module_esolver/esolver_ks_pw.cpp:			this->__kspw_psi);
module_esolver/esolver_ks_pw.cpp:    GlobalV::ofs_running << " !FINAL_ETOT_IS " << this->pelec->f_en.etot * ModuleBase::Ry_to_eV << " eV" << std::endl;
module_esolver/esolver_ks_pw.cpp:	ModuleIO::write_istate_info(this->pelec->ekb, this->pelec->wg, this->kv, &(GlobalC::Pkpoints));
module_esolver/esolver_ks_pw.cpp:        ModuleIO::write_dos_pw(this->pelec->ekb,
module_esolver/esolver_ks_pw.cpp:                               this->pelec->wg,
module_esolver/esolver_ks_pw.cpp:                               this->kv,
module_esolver/esolver_ks_pw.cpp:            GlobalV::ofs_running << " Fermi energy is " << this->pelec->eferm.ef << " Rydberg" << std::endl;
module_esolver/esolver_ks_pw.cpp:				<< this->pelec->eferm.ef_up 
module_esolver/esolver_ks_pw.cpp:				<< this->pelec->eferm.ef_dw 
module_esolver/esolver_ks_pw.cpp:                                this->pelec->ekb,
module_esolver/esolver_ks_pw.cpp:                                this->kv,
module_esolver/esolver_ks_pw.cpp:                for (int ik=0; ik<this->kv.nks; ik++)
module_esolver/esolver_ks_pw.cpp:                    this->wf.wanf2[ik].create(GlobalV::NLOCAL, this->wf.npwx);
module_esolver/esolver_ks_pw.cpp:                        this->wf.LCAO_in_pw_k(ik, this->wf.wanf2[ik]);
module_esolver/esolver_ks_pw.cpp:                //sp.get_both(GlobalV::NBANDS, GlobalV::NLOCAL, this->wf.wanf2, this->wf.evc);
module_esolver/esolver_ks_pw.cpp:                numerical_basis.output_overlap(this->psi[0], this->sf, this->kv, this->pw_wfc);
module_esolver/esolver_ks_pw.cpp:                    numerical_basis.output_overlap(this->psi[0], this->sf, this->kv, this->pw_wfc);
module_esolver/esolver_ks_pw.cpp:    if (this->wf.out_wfc_r == 1) // Peize Lin add 2021.11.21
module_esolver/esolver_ks_pw.cpp:				this->psi[0], 
module_esolver/esolver_ks_pw.cpp:				this->pw_wfc, 
module_esolver/esolver_ks_pw.cpp:				this->kv);
module_esolver/esolver_ks_pw.cpp:		this->KG(
module_esolver/esolver_ks_pw.cpp:				this->pelec->wg);
module_esolver/esolver_ks_pw.cpp:    if (this->phsol != nullptr)
module_esolver/esolver_ks_pw.cpp:        this->phsol->solve(this->p_hamilt, this->kspw_psi[0], this->pelec, GlobalV::KS_SOLVER, true);
module_esolver/esolver_ks_pw.cpp:    this->before_scf(istep_tmp);
module_esolver/esolver_ks_pw.cpp:    this->hamilt2estates(diag_ethr);
module_esolver/esolver_ks_pw.cpp:    this->pelec->calculate_weights();
module_esolver/esolver_ks_pw.cpp:    for (int ik = 0; ik < this->kv.nks; ik++)
module_esolver/esolver_ks_pw.cpp:			if (ik == (this->kv.nks / 2))
module_esolver/esolver_ks_pw.cpp:			<< "(" << this->kv.nkstot 
module_esolver/esolver_ks_pw.cpp:			<< "): " << this->kv.kvec_c[ik].x 
module_esolver/esolver_ks_pw.cpp:			<< this->kv.kvec_c[ik].y 
module_esolver/esolver_ks_pw.cpp:			<< " " << this->kv.kvec_c[ik].z << std::endl;
module_esolver/esolver_ks_pw.cpp:				<< this->kv.isk[ik] + 1 
module_esolver/esolver_ks_pw.cpp:				<< this->pelec->ekb(ik, ib) * ModuleBase::Ry_to_eV << " "
module_esolver/esolver_ks_pw.cpp:				<< this->pelec->wg(ik, ib) * this->kv.nks 
module_esolver/esolver_ks_pw.cpp:            this->pelec->cal_bandgap();
module_esolver/esolver_ks_pw.cpp:				<< this->pelec->bandgap * ModuleBase::Ry_to_eV 
module_esolver/esolver_ks_pw.cpp:			this->pelec->cal_bandgap_updw();
module_esolver/esolver_ks_pw.cpp:				<< this->pelec->bandgap_up * ModuleBase::Ry_to_eV 
module_esolver/esolver_ks_pw.cpp:				<< this->pelec->bandgap_dw * ModuleBase::Ry_to_eV 
module_esolver/esolver_ks_pw.cpp:				this->pelec->ekb, 
module_esolver/esolver_ks_pw.cpp:				this->pw_wfc, 
module_esolver/esolver_ks_pw.cpp:				this->pw_big, 
module_esolver/esolver_ks_pw.cpp:				this->kv, 
module_esolver/esolver_ks_pw.cpp:				this->psi);
module_esolver/esolver_ks_pw.cpp:				this->pw_wfc->npwk_max, 
module_esolver/esolver_ks_pw.cpp:				this->psi, 
module_esolver/esolver_ks_pw.cpp:				this->pw_rho, 
module_esolver/esolver_ks_pw.cpp:				this->pw_wfc, 
module_esolver/esolver_ks_pw.cpp:				this->kv);
module_esolver/esolver_ks_pw_tool.cpp:    const int nk = this->kv.nks;
module_esolver/esolver_ks_pw_tool.cpp:    hamilt::Velocity velop(this->pw_wfc, this->kv.isk.data(), &GlobalC::ppcell, &GlobalC::ucell, INPUT.cond_nonlocal);
module_esolver/esolver_ks_pw_tool.cpp:    const int npwx = this->wf.npwx;
module_esolver/esolver_ks_pw_tool.cpp:    const double ef = this->pelec->eferm.ef;
module_esolver/esolver_ks_pw_tool.cpp:    const int npw = this->kv.ngk[ik];
module_esolver/esolver_ks_pw_tool.cpp:    std::complex<double>* levc = &(this->psi[0](ik, 0, 0));
module_esolver/esolver_ks_pw_tool.cpp:    velop.act(this->psi, nbands * GlobalV::NPOL, levc, prevc);
module_esolver/esolver_ks_pw_tool.cpp:        int nkstot = this->kv.nkstot;
module_esolver/esolver_ks_pw_tool.cpp:        int ikglobal = this->kv.getik_global(ik);
module_esolver/esolver_ks_pw_tool.cpp:        double* enb = &(this->pelec->ekb(ik, 0));
module_esolver/esolver_of.cpp:    this->classname = "ESolver_OF";
module_esolver/esolver_of.cpp:    this->task_ = new char[60];
module_esolver/esolver_of.cpp:    delete[] this->pphi_;
module_esolver/esolver_of.cpp:        delete[] this->pdirect_[i];
module_esolver/esolver_of.cpp:        delete[] this->pdLdphi_[i];
module_esolver/esolver_of.cpp:        delete[] this->pdEdphi_[i];
module_esolver/esolver_of.cpp:        delete[] this->precip_dir_[i];
module_esolver/esolver_of.cpp:    delete[] this->pdirect_;
module_esolver/esolver_of.cpp:    delete[] this->pdLdphi_;
module_esolver/esolver_of.cpp:    delete[] this->pdEdphi_;
module_esolver/esolver_of.cpp:    delete[] this->precip_dir_;
module_esolver/esolver_of.cpp:    delete[] this->nelec_;
module_esolver/esolver_of.cpp:    delete[] this->theta_;
module_esolver/esolver_of.cpp:    delete[] this->mu_;
module_esolver/esolver_of.cpp:    delete[] this->task_;
module_esolver/esolver_of.cpp:    delete this->ptemp_rho_;
module_esolver/esolver_of.cpp:    delete this->tf_;
module_esolver/esolver_of.cpp:    delete this->vw_;
module_esolver/esolver_of.cpp:    delete this->wt_;
module_esolver/esolver_of.cpp:    delete this->lkt_;
module_esolver/esolver_of.cpp:    delete this->opt_cg_;
module_esolver/esolver_of.cpp:    delete this->opt_tn_;
module_esolver/esolver_of.cpp:    delete this->opt_dcsrch_;
module_esolver/esolver_of.cpp:    delete this->opt_cg_mag_;
module_esolver/esolver_of.cpp:    this->of_kinetic_ = inp.of_kinetic;
module_esolver/esolver_of.cpp:    this->of_method_ = inp.of_method;
module_esolver/esolver_of.cpp:    this->of_conv_ = inp.of_conv;
module_esolver/esolver_of.cpp:    this->of_tole_ = inp.of_tole;
module_esolver/esolver_of.cpp:    this->of_tolp_ = inp.of_tolp;
module_esolver/esolver_of.cpp:    this->max_iter_ = inp.scf_nmax;
module_esolver/esolver_of.cpp:    this->dV_ = ucell.omega / this->pw_rho->nxyz;
module_esolver/esolver_of.cpp:    this->init_elecstate(ucell);
module_esolver/esolver_of.cpp:    this->pelec->init_scf(0, sf.strucFac); // atomic_rho, v_of_rho, set_vrs
module_esolver/esolver_of.cpp:    ModuleBase::matrix veff = this->pelec->pot->get_effective_v();
module_esolver/esolver_of.cpp:    GlobalC::ppcell.cal_effective_D(veff, this->pw_rho, ucell);
module_esolver/esolver_of.cpp:    this->nelec_ = new double[GlobalV::NSPIN];
module_esolver/esolver_of.cpp:        this->nelec_[0] = GlobalV::nelec;
module_esolver/esolver_of.cpp:        this->pelec->init_nelec_spin();
module_esolver/esolver_of.cpp:        this->nelec_[0] = this->pelec->nelec_spin[0];
module_esolver/esolver_of.cpp:        this->nelec_[1] = this->pelec->nelec_spin[1];
module_esolver/esolver_of.cpp:    this->init_kedf(inp);
module_esolver/esolver_of.cpp:    this->init_opt();
module_esolver/esolver_of.cpp:    this->allocate_array();
module_esolver/esolver_of.cpp:    this->dV_ = ucell.omega / this->pw_rho->nxyz;
module_esolver/esolver_of.cpp:        GlobalC::Pgrid.init(this->pw_rho->nx,
module_esolver/esolver_of.cpp:                            this->pw_rho->ny,
module_esolver/esolver_of.cpp:                            this->pw_rho->nz,
module_esolver/esolver_of.cpp:                            this->pw_rho->nplane,
module_esolver/esolver_of.cpp:                            this->pw_rho->nrxx,
module_esolver/esolver_of.cpp:        this->sf.setup_structure_factor(&ucell, this->pw_rho);
module_esolver/esolver_of.cpp:    this->init_elecstate(ucell);
module_esolver/esolver_of.cpp:    this->init_kedf(inp);
module_esolver/esolver_of.cpp:    this->init_opt();
module_esolver/esolver_of.cpp:    delete this->psi_;
module_esolver/esolver_of.cpp:    this->psi_ = new psi::Psi<double>(1, GlobalV::NSPIN, this->pw_rho->nrxx);
module_esolver/esolver_of.cpp:        this->pphi_[is] = this->psi_->get_pointer(is);
module_esolver/esolver_of.cpp:    delete this->ptemp_rho_;
module_esolver/esolver_of.cpp:    this->ptemp_rho_ = new Charge();
module_esolver/esolver_of.cpp:    this->ptemp_rho_->set_rhopw(this->pw_rho);
module_esolver/esolver_of.cpp:    this->ptemp_rho_->allocate(GlobalV::NSPIN);
module_esolver/esolver_of.cpp:        delete[] this->pdLdphi_[is];
module_esolver/esolver_of.cpp:        delete[] this->pdEdphi_[is];
module_esolver/esolver_of.cpp:        delete[] this->pdirect_[is];
module_esolver/esolver_of.cpp:        delete[] this->precip_dir_[is];
module_esolver/esolver_of.cpp:        this->pdLdphi_[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of.cpp:        this->pdEdphi_[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of.cpp:        this->pdirect_[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of.cpp:        this->precip_dir_[is] = new std::complex<double>[pw_rho->npw];
module_esolver/esolver_of.cpp:    this->before_opt(istep, ucell);
module_esolver/esolver_of.cpp:    this->iter_ = 0;
module_esolver/esolver_of.cpp:        this->update_potential(ucell);
module_esolver/esolver_of.cpp:        this->energy_llast_ = this->energy_last_;
module_esolver/esolver_of.cpp:        this->energy_last_ = this->energy_current_;
module_esolver/esolver_of.cpp:        this->energy_current_ = this->cal_energy();
module_esolver/esolver_of.cpp:		if (this->check_exit())
module_esolver/esolver_of.cpp:        this->optimize(ucell);
module_esolver/esolver_of.cpp:        this->update_rho();
module_esolver/esolver_of.cpp:        this->iter_++;
module_esolver/esolver_of.cpp:    this->after_opt(istep, ucell);
module_esolver/esolver_of.cpp:        this->init_after_vc(INPUT, ucell);
module_esolver/esolver_of.cpp:    this->pelec->init_scf(istep, sf.strucFac);
module_esolver/esolver_of.cpp:    this->pelec->f_en.ewald_energy = H_Ewald_pw::compute_ewald(ucell, this->pw_rho, sf.strucFac);
module_esolver/esolver_of.cpp:        srho.begin(is, *(pelec->charge), this->pw_rho, GlobalC::Pgrid, GlobalC::ucell.symm);
module_esolver/esolver_of.cpp:            for (int ibs = 0; ibs < this->pw_rho->nrxx; ++ibs)
module_esolver/esolver_of.cpp:                pelec->charge->rho[is][ibs] = this->nelec_[is] / this->pelec->omega;
module_esolver/esolver_of.cpp:                this->pphi_[is][ibs] = sqrt(pelec->charge->rho[is][ibs]);
module_esolver/esolver_of.cpp:            for (int ibs = 0; ibs < this->pw_rho->nrxx; ++ibs)
module_esolver/esolver_of.cpp:                this->pphi_[is][ibs] = sqrt(pelec->charge->rho[is][ibs]);
module_esolver/esolver_of.cpp:        this->mu_[is] = 0;
module_esolver/esolver_of.cpp:        this->theta_[is] = 0.;
module_esolver/esolver_of.cpp:        ModuleBase::GlobalFunc::ZEROS(this->pdLdphi_[is], this->pw_rho->nrxx);
module_esolver/esolver_of.cpp:        ModuleBase::GlobalFunc::ZEROS(this->pdEdphi_[is], this->pw_rho->nrxx);
module_esolver/esolver_of.cpp:        ModuleBase::GlobalFunc::ZEROS(this->pdirect_[is], this->pw_rho->nrxx);
module_esolver/esolver_of.cpp:        this->theta_[0] = 0.2;
module_esolver/esolver_of.cpp:    this->pelec->pot->update_from_charge(pelec->charge, &ucell); // Hartree + XC + external
module_esolver/esolver_of.cpp:    this->kinetic_potential(pelec->charge->rho,
module_esolver/esolver_of.cpp:                            this->pphi_,
module_esolver/esolver_of.cpp:                            this->pelec->pot->get_effective_v()); // (kinetic + Hartree + XC + external) * 2 * phi
module_esolver/esolver_of.cpp:        const double* vr_eff = this->pelec->pot->get_effective_v(is);
module_esolver/esolver_of.cpp:        for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of.cpp:            this->pdEdphi_[is][ir] = vr_eff[ir];
module_esolver/esolver_of.cpp:        this->mu_[is] = this->cal_mu(this->pphi_[is], this->pdEdphi_[is], this->nelec_[is]);
module_esolver/esolver_of.cpp:        for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of.cpp:            this->pdLdphi_[is][ir] = this->pdEdphi_[is][ir] - 2. * this->mu_[is] * this->pphi_[is][ir];
module_esolver/esolver_of.cpp:    this->normdLdphi_llast_ = this->normdLdphi_last_;
module_esolver/esolver_of.cpp:    this->normdLdphi_last_ = this->normdLdphi_;
module_esolver/esolver_of.cpp:    this->normdLdphi_ = 0.;
module_esolver/esolver_of.cpp:        this->normdLdphi_ += this->inner_product(this->pdLdphi_[is], this->pdLdphi_[is], this->pw_rho->nrxx, 1.0);
module_esolver/esolver_of.cpp:    Parallel_Reduce::reduce_all(this->normdLdphi_);
module_esolver/esolver_of.cpp:    this->normdLdphi_ = sqrt(this->normdLdphi_ / this->pw_rho->nxyz / GlobalV::NSPIN);
module_esolver/esolver_of.cpp: * @brief Get the optimization direction (this->pdirection_) and the step length (this->theta)
module_esolver/esolver_of.cpp:    this->get_direction();
module_esolver/esolver_of.cpp:        ptemp_phi[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of.cpp:        for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of.cpp:            ptemp_phi[is][ir] = this->pphi_[is][ir];
module_esolver/esolver_of.cpp:            this->ptemp_rho_->rho[is][ir] = ptemp_phi[is][ir] * ptemp_phi[is][ir];
module_esolver/esolver_of.cpp:    this->adjust_direction();
module_esolver/esolver_of.cpp:    this->check_direction(dEdtheta, ptemp_phi, ucell);
module_esolver/esolver_of.cpp:    // this->test_direction(dEdtheta, ptemp_phi, ucell);
module_esolver/esolver_of.cpp:    this->get_step_length(dEdtheta, ptemp_phi, ucell);
module_esolver/esolver_of.cpp:        for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of.cpp:            this->pphi_[is][ir]
module_esolver/esolver_of.cpp:                = this->pphi_[is][ir] * cos(this->theta_[is]) + this->pdirect_[is][ir] * sin(this->theta_[is]);
module_esolver/esolver_of.cpp:            pelec->charge->rho[is][ir] = this->pphi_[is][ir] * this->pphi_[is][ir];
module_esolver/esolver_of.cpp:    //         srho.begin(is, *(pelec->charge), this->pw_rho, GlobalC::Pgrid, GlobalC::ucell.symm);
module_esolver/esolver_of.cpp:    //         for (int ibs = 0; ibs < this->pw_rho->nrxx; ++ibs)
module_esolver/esolver_of.cpp:    //             this->pphi_[is][ibs] = sqrt(pelec->charge->rho[is][ibs]);
module_esolver/esolver_of.cpp:    this->conv_ = false;
module_esolver/esolver_of.cpp:    if (this->normdLdphi_ < this->of_tolp_)
module_esolver/esolver_of.cpp:    if (this->iter_ >= 3 && std::abs(this->normdLdphi_ - this->normdLdphi_last_) < 1e-10
module_esolver/esolver_of.cpp:        && std::abs(this->normdLdphi_ - this->normdLdphi_llast_) < 1e-10)
module_esolver/esolver_of.cpp:    if (this->iter_ >= 3 && std::abs(this->energy_current_ - this->energy_last_) < this->of_tole_
module_esolver/esolver_of.cpp:        && std::abs(this->energy_current_ - this->energy_llast_) < this->of_tole_)
module_esolver/esolver_of.cpp:    this->conv_ = (this->of_conv_ == "energy" && energyConv) || (this->of_conv_ == "potential" && potConv)
module_esolver/esolver_of.cpp:                  || (this->of_conv_ == "both" && potConv && energyConv);
module_esolver/esolver_of.cpp:    this->print_info();
module_esolver/esolver_of.cpp:    if (this->conv_ || this->iter_ >= this->max_iter_)
module_esolver/esolver_of.cpp:    else if (this->of_conv_ == "potential" && potHold)
module_esolver/esolver_of.cpp:    ModuleIO::output_convergence_after_scf(this->conv_, this->pelec->f_en.etot);
module_esolver/esolver_of.cpp:        this->CE_.save_files(istep,
module_esolver/esolver_of.cpp:                             this->pw_big,
module_esolver/esolver_of.cpp:                             this->pelec->charge,
module_esolver/esolver_of.cpp:                             &this->sf);
module_esolver/esolver_of.cpp:                this->pw_big->bz,
module_esolver/esolver_of.cpp:                this->pw_big->nbz,
module_esolver/esolver_of.cpp:                this->pw_rho->nplane,
module_esolver/esolver_of.cpp:                this->pw_rho->startz_current,
module_esolver/esolver_of.cpp:                this->pelec->charge->rho[is],
module_esolver/esolver_of.cpp:                this->iter_,
module_esolver/esolver_of.cpp:                this->pw_rho->nx,
module_esolver/esolver_of.cpp:                this->pw_rho->ny,
module_esolver/esolver_of.cpp:                this->pw_rho->nz,
module_esolver/esolver_of.cpp:                this->mu_[is],
module_esolver/esolver_of.cpp:                this->pw_big->bz,
module_esolver/esolver_of.cpp:                this->pw_big->nbz,
module_esolver/esolver_of.cpp:                this->pw_rho->nplane,
module_esolver/esolver_of.cpp:                this->pw_rho->startz_current,
module_esolver/esolver_of.cpp:                this->pw_rho->nx,
module_esolver/esolver_of.cpp:                this->pw_rho->ny,
module_esolver/esolver_of.cpp:                this->pw_rho->nz,
module_esolver/esolver_of.cpp:                this->pelec->pot->get_effective_v(),
module_esolver/esolver_of.cpp:            this->pw_big->bz,
module_esolver/esolver_of.cpp:            this->pw_big->nbz,
module_esolver/esolver_of.cpp:            this->pw_rho,
module_esolver/esolver_of.cpp:            this->pelec->charge,
module_esolver/esolver_of.cpp:            this->pelec->pot->get_fixed_v());
module_esolver/esolver_of.cpp:    GlobalV::ofs_running << " !FINAL_ETOT_IS " << this->pelec->f_en.etot * ModuleBase::Ry_to_eV << " eV" << std::endl;
module_esolver/esolver_of.cpp:    this->pelec->cal_energies(2);
module_esolver/esolver_of.cpp:    double kinetic_energy = this->kinetic_energy(); // kinetic energy
module_esolver/esolver_of.cpp:        pseudopot_energy += this->inner_product(this->pelec->pot->get_fixed_v(),
module_esolver/esolver_of.cpp:                                                this->pw_rho->nrxx,
module_esolver/esolver_of.cpp:                                                this->dV_);
module_esolver/esolver_of.cpp:    this->pelec->f_en.ekinetic = kinetic_energy;
module_esolver/esolver_of.cpp:    this->pelec->f_en.eion_elec = pseudopot_energy;
module_esolver/esolver_of.cpp:    this->pelec->f_en.etot += kinetic_energy + pseudopot_energy;
module_esolver/esolver_of.cpp:    return this->pelec->f_en.etot;
module_esolver/esolver_of.cpp:    ff.cal_force(force, *pelec, this->pw_rho, &GlobalC::ucell.symm, &sf);
module_esolver/esolver_of.cpp:    this->kinetic_stress(kinetic_stress_);
module_esolver/esolver_of.cpp:    OF_Stress_PW ss(this->pelec, this->pw_rho);
module_esolver/esolver_of.h:        return this->iter_;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "tf" || this->of_kinetic_ == "tf+" || this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:		if (this->tf_ == nullptr)
module_esolver/esolver_of_interface.cpp:			this->tf_ = new KEDF_TF();
module_esolver/esolver_of_interface.cpp:        this->tf_->set_para(this->pw_rho->nrxx, this->dV_, inp.of_tf_weight);
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "vw" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "tf+" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "wt"
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:		if (this->vw_ == nullptr)
module_esolver/esolver_of_interface.cpp:			this->vw_ = new KEDF_vW();
module_esolver/esolver_of_interface.cpp:        this->vw_->set_para(this->dV_, inp.of_vw_weight);
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:		if (this->wt_ == nullptr)
module_esolver/esolver_of_interface.cpp:			this->wt_ = new KEDF_WT();
module_esolver/esolver_of_interface.cpp:        this->wt_->set_para(this->dV_,
module_esolver/esolver_of_interface.cpp:                            this->nelec_[0],
module_esolver/esolver_of_interface.cpp:                            this->pw_rho);
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:		if (this->lkt_ == nullptr)
module_esolver/esolver_of_interface.cpp:			this->lkt_ = new KEDF_LKT();
module_esolver/esolver_of_interface.cpp:        this->lkt_->set_para(this->dV_, inp.of_lkt_a);
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "tf" || this->of_kinetic_ == "tf+" || this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:        this->tf_->tf_potential(prho, rpot);
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:        this->wt_->wt_potential(prho, this->pw_rho, rpot);
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:        this->lkt_->lkt_potential(prho, this->pw_rho, rpot);
module_esolver/esolver_of_interface.cpp:        for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "vw" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "tf+" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "wt"
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:        this->vw_->vw_potential(pphi, this->pw_rho, rpot);
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "tf" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "tf+" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:        kinetic_energy += this->tf_->tf_energy;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "vw" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "tf+" 
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "wt"
module_esolver/esolver_of_interface.cpp:     || this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:        kinetic_energy += this->vw_->vw_energy;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:        kinetic_energy += this->wt_->wt_energy;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:        kinetic_energy += this->lkt_->lkt_energy;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "tf" || this->of_kinetic_ == "tf+" || this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:        this->tf_->get_stress(this->pelec->omega);
module_esolver/esolver_of_interface.cpp:        kinetic_stress_ += this->tf_->stress;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "vw" || this->of_kinetic_ == "tf+" || this->of_kinetic_ == "wt"
module_esolver/esolver_of_interface.cpp:        || this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:        this->vw_->get_stress(this->pphi_, this->pw_rho);
module_esolver/esolver_of_interface.cpp:        kinetic_stress_ += this->vw_->stress;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "wt")
module_esolver/esolver_of_interface.cpp:        this->wt_->get_stress(pelec->charge->rho, this->pw_rho, GlobalV::of_vw_weight);
module_esolver/esolver_of_interface.cpp:        kinetic_stress_ += this->wt_->stress;
module_esolver/esolver_of_interface.cpp:    if (this->of_kinetic_ == "lkt")
module_esolver/esolver_of_interface.cpp:        this->lkt_->get_stress(pelec->charge->rho, this->pw_rho);
module_esolver/esolver_of_interface.cpp:        kinetic_stress_ += this->lkt_->stress;
module_esolver/esolver_of_interface.cpp:	if (this->opt_dcsrch_ == nullptr)
module_esolver/esolver_of_interface.cpp:		this->opt_dcsrch_ = new ModuleBase::Opt_DCsrch();
module_esolver/esolver_of_interface.cpp:    if (this->of_method_ == "tn")
module_esolver/esolver_of_interface.cpp:		if (this->opt_tn_ == nullptr)
module_esolver/esolver_of_interface.cpp:			this->opt_tn_ = new ModuleBase::Opt_TN();
module_esolver/esolver_of_interface.cpp:        this->opt_tn_->allocate(this->pw_rho->nrxx);
module_esolver/esolver_of_interface.cpp:        this->opt_tn_->set_para(this->dV_);
module_esolver/esolver_of_interface.cpp:    else if (this->of_method_ == "cg1" || this->of_method_ == "cg2")
module_esolver/esolver_of_interface.cpp:		if (this->opt_cg_ == nullptr)
module_esolver/esolver_of_interface.cpp:			this->opt_cg_ = new ModuleBase::Opt_CG();
module_esolver/esolver_of_interface.cpp:		this->opt_cg_->allocate(this->pw_rho->nrxx);
module_esolver/esolver_of_interface.cpp:        this->opt_cg_->set_para(this->dV_);
module_esolver/esolver_of_interface.cpp:        this->opt_dcsrch_->set_paras(1e-4, 1e-2);
module_esolver/esolver_of_interface.cpp:    else if (this->of_method_ == "bfgs")
module_esolver/esolver_of_interface.cpp:        this->opt_cg_mag_ = new ModuleBase::Opt_CG;
module_esolver/esolver_of_interface.cpp:        this->opt_cg_mag_->allocate(GlobalV::NSPIN);
module_esolver/esolver_of_interface.cpp:        if (this->of_method_ == "tn")
module_esolver/esolver_of_interface.cpp:            this->tn_spin_flag_ = is;
module_esolver/esolver_of_interface.cpp:            opt_tn_->next_direct(this->pphi_[is],
module_esolver/esolver_of_interface.cpp:                                 this->pdLdphi_[is],
module_esolver/esolver_of_interface.cpp:                                 this->flag_,
module_esolver/esolver_of_interface.cpp:                                 this->pdirect_[is],
module_esolver/esolver_of_interface.cpp:        else if (this->of_method_ == "cg1")
module_esolver/esolver_of_interface.cpp:            opt_cg_->next_direct(this->pdLdphi_[is], 1, this->pdirect_[is]);
module_esolver/esolver_of_interface.cpp:        else if (this->of_method_ == "cg2")
module_esolver/esolver_of_interface.cpp:            opt_cg_->next_direct(this->pdLdphi_[is], 2, this->pdirect_[is]);
module_esolver/esolver_of_interface.cpp:        else if (this->of_method_ == "bfgs")
module_esolver/esolver_of_interface.cpp:        strcpy(this->task_, "START");
module_esolver/esolver_of_interface.cpp:            this->pelec->cal_energies(2);
module_esolver/esolver_of_interface.cpp:            temp_energy = this->pelec->f_en.etot;
module_esolver/esolver_of_interface.cpp:            kinetic_energy = this->kinetic_energy();
module_esolver/esolver_of_interface.cpp:            pseudopot_energy = this->inner_product(this->pelec->pot->get_fixed_v(),
module_esolver/esolver_of_interface.cpp:                                                   this->ptemp_rho_->rho[0],
module_esolver/esolver_of_interface.cpp:                                                   this->pw_rho->nrxx,
module_esolver/esolver_of_interface.cpp:                                                   this->dV_);
module_esolver/esolver_of_interface.cpp:            this->opt_dcsrch_->dcSrch(temp_energy, dEdtheta[0], this->theta_[0], this->task_);
module_esolver/esolver_of_interface.cpp:            if (strncmp(this->task_, "FG", 2) == 0) // continue line search
module_esolver/esolver_of_interface.cpp:                for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_interface.cpp:                        = this->pphi_[0][i] * cos(this->theta_[0]) + this->pdirect_[0][i] * sin(this->theta_[0]);
module_esolver/esolver_of_interface.cpp:                    this->ptemp_rho_->rho[0][i] = ptemp_phi[0][i] * ptemp_phi[0][i];
module_esolver/esolver_of_interface.cpp:                this->cal_dEdtheta(ptemp_phi, this->ptemp_rho_, ucell, this->theta_, dEdtheta);
module_esolver/esolver_of_interface.cpp:                if (numDC > this->max_dcsrch_)
module_esolver/esolver_of_interface.cpp:            else if (strncmp(this->task_, "CO", 2) == 0) // convergence achieved
module_esolver/esolver_of_interface.cpp:            else if (strncmp(this->task_, "WA", 2) == 0) // warning of line search
module_esolver/esolver_of_interface.cpp:                GlobalV::ofs_warning << "ESolver_OF linesearch: WARNING " << this->task_ << std::endl;
module_esolver/esolver_of_interface.cpp:                std::cout << this->task_ << std::endl;
module_esolver/esolver_of_interface.cpp:            else if (strncmp(this->task_, "ER", 2) == 0) // ERROR in line search
module_esolver/esolver_of_interface.cpp:                GlobalV::ofs_warning << "ESolver_OF linesearch: ERROR " << this->task_ << std::endl;
module_esolver/esolver_of_interface.cpp:                std::cout << this->task_ << std::endl;
module_esolver/esolver_of_interface.cpp:        //     this->opt_cg_mag_->refresh();
module_esolver/esolver_of_interface.cpp:        //         this->opt_cg_mag_->next_direct(dEdtheta, 1, pthetaDir);
module_esolver/esolver_of_interface.cpp:        //         dEdalpha = this->inner_product(dEdtheta, pthetaDir, 2, 1.);
module_esolver/esolver_of_interface.cpp:        //             dEdalpha = this->inner_product(dEdtheta, pthetaDir, 2, 1);
module_esolver/esolver_of_interface.cpp:        //         this->opt_dcsrch_->set_paras(1e-4, 1e-2, 1e-12, 0., ModuleBase::PI/maxThetaDir);
module_esolver/esolver_of_interface.cpp:        //         strcpy(this->task_, "START");
module_esolver/esolver_of_interface.cpp:        //             this->pelec->f_en.calculate_etot(this->pw_rho->nrxx, this->pw_rho->nxyz);
module_esolver/esolver_of_interface.cpp:        //             temp_energy = this->pelec->f_en.etot;
module_esolver/esolver_of_interface.cpp:        //             kinetic_energy = this->kinetic_energy();
module_esolver/esolver_of_interface.cpp:        //                 pseudopot_energy += this->inner_product(GlobalC::pot.vltot, ptemp_rho_[is],
module_esolver/esolver_of_interface.cpp:        //                 this->pw_rho->nrxx, this->dV_);
module_esolver/esolver_of_interface.cpp:        //             this->opt_dcsrch_->dcSrch(temp_energy, dEdalpha, thetaAlpha, this->task_);
module_esolver/esolver_of_interface.cpp:        //             if (strncmp(this->task_, "FG", 2) == 0)
module_esolver/esolver_of_interface.cpp:        //                     temp_theta[is] = this->theta_[is] + thetaAlpha * pthetaDir[is];
module_esolver/esolver_of_interface.cpp:        //                     for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of_interface.cpp:        //                         ptemp_phi[is][ir] = this->pphi_[is][ir] * cos(temp_theta[is]) +
module_esolver/esolver_of_interface.cpp:        //                         this->pdirect_[is][ir] * sin(temp_theta[is]); ptemp_rho_[is][ir] = ptemp_phi[is][ir]
module_esolver/esolver_of_interface.cpp:        //                 this->cal_dEdtheta(ptemp_phi, ptemp_rho_, temp_theta, dEdtheta);
module_esolver/esolver_of_interface.cpp:        //                 dEdalpha = this->inner_product(dEdtheta, pthetaDir, 2, 1);
module_esolver/esolver_of_interface.cpp:        //             else if (strncmp(this->task_, "CO", 2) == 0)
module_esolver/esolver_of_interface.cpp:        //             else if (strncmp(this->task_, "WA", 2) == 0)
module_esolver/esolver_of_interface.cpp:        //                 GlobalV::ofs_warning << "ESolver_OF linesearch: WARNING " << this->task_ << std::endl;
module_esolver/esolver_of_interface.cpp:        //                 cout << this->task_ << endl;
module_esolver/esolver_of_interface.cpp:        //             else if (strncmp(this->task_, "ER", 2) == 0)
module_esolver/esolver_of_interface.cpp:        //                 GlobalV::ofs_warning << "ESolver_OF linesearch: ERROR " << this->task_ << std::endl;
module_esolver/esolver_of_interface.cpp:        //                 cout << this->task_ << endl;
module_esolver/esolver_of_interface.cpp:        //         for (int is = 0; is < GlobalV::NSPIN; ++is) this->theta_[is] += thetaAlpha * pthetaDir[is];
module_esolver/esolver_of_tool.cpp: * @brief Initialize this->pelec, as well as this->pelec->pot
module_esolver/esolver_of_tool.cpp:    delete this->pelec;
module_esolver/esolver_of_tool.cpp:    this->pelec = new elecstate::ElecState((Charge*)(&chr), this->pw_rho, pw_big);
module_esolver/esolver_of_tool.cpp:    this->pelec->charge->allocate(GlobalV::NSPIN);
module_esolver/esolver_of_tool.cpp:    this->pelec->omega = ucell.omega;
module_esolver/esolver_of_tool.cpp:    delete this->pelec->pot;
module_esolver/esolver_of_tool.cpp:    this->pelec->pot = new elecstate::Potential(this->pw_rhod,
module_esolver/esolver_of_tool.cpp:                                                this->pw_rho,
module_esolver/esolver_of_tool.cpp:                                                &(this->sf),
module_esolver/esolver_of_tool.cpp:                                                &(this->pelec->f_en.etxc),
module_esolver/esolver_of_tool.cpp:                                                &(this->pelec->f_en.vtxc));
module_esolver/esolver_of_tool.cpp:        this->pelec->pot->pot_register(pot_register_in);
module_esolver/esolver_of_tool.cpp: * @brief Allocate the arrays, as well as this->psi_ and this->ptemp_rho_.
module_esolver/esolver_of_tool.cpp:    this->psi_ = new psi::Psi<double>(1, GlobalV::NSPIN, this->pw_rho->nrxx);
module_esolver/esolver_of_tool.cpp:    ModuleBase::Memory::record("OFDFT::Psi", sizeof(double) * GlobalV::NSPIN * this->pw_rho->nrxx);
module_esolver/esolver_of_tool.cpp:    this->pphi_ = new double*[GlobalV::NSPIN];
module_esolver/esolver_of_tool.cpp:        this->pphi_[is] = this->psi_->get_pointer(is);
module_esolver/esolver_of_tool.cpp:    delete this->ptemp_rho_;
module_esolver/esolver_of_tool.cpp:    this->ptemp_rho_ = new Charge();
module_esolver/esolver_of_tool.cpp:    this->ptemp_rho_->set_rhopw(this->pw_rho);
module_esolver/esolver_of_tool.cpp:    this->ptemp_rho_->allocate(GlobalV::NSPIN);
module_esolver/esolver_of_tool.cpp:    this->mu_ = new double[GlobalV::NSPIN];
module_esolver/esolver_of_tool.cpp:    this->theta_ = new double[GlobalV::NSPIN];
module_esolver/esolver_of_tool.cpp:    this->pdLdphi_ = new double*[GlobalV::NSPIN];
module_esolver/esolver_of_tool.cpp:    this->pdEdphi_ = new double*[GlobalV::NSPIN];
module_esolver/esolver_of_tool.cpp:    this->pdirect_ = new double*[GlobalV::NSPIN];
module_esolver/esolver_of_tool.cpp:    this->precip_dir_ = new std::complex<double>*[GlobalV::NSPIN];
module_esolver/esolver_of_tool.cpp:        this->pdLdphi_[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of_tool.cpp:        this->pdEdphi_[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of_tool.cpp:        this->pdirect_[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of_tool.cpp:        this->precip_dir_[is] = new std::complex<double>[pw_rho->npw];
module_esolver/esolver_of_tool.cpp:    ModuleBase::Memory::record("OFDFT::pdLdphi_", sizeof(double) * GlobalV::NSPIN * this->pw_rho->nrxx);
module_esolver/esolver_of_tool.cpp:    ModuleBase::Memory::record("OFDFT::pdEdphi_", sizeof(double) * GlobalV::NSPIN * this->pw_rho->nrxx);
module_esolver/esolver_of_tool.cpp:    ModuleBase::Memory::record("OFDFT::pdirect_", sizeof(double) * GlobalV::NSPIN * this->pw_rho->nrxx);
module_esolver/esolver_of_tool.cpp:    ModuleBase::Memory::record("OFDFT::precip_dir_", sizeof(std::complex<double>) * GlobalV::NSPIN * this->pw_rho->npw);
module_esolver/esolver_of_tool.cpp:        dEdtemp_phi[is] = new double[this->pw_rho->nrxx];
module_esolver/esolver_of_tool.cpp:        if (is == this->tn_spin_flag_)
module_esolver/esolver_of_tool.cpp:            temp_phi[is] = this->pphi_[is];
module_esolver/esolver_of_tool.cpp:        for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of_tool.cpp:            this->ptemp_rho_->rho[is][ir] = temp_phi[is][ir] * temp_phi[is][ir];
module_esolver/esolver_of_tool.cpp:    this->pelec->pot->update_from_charge(this->ptemp_rho_, &GlobalC::ucell);
module_esolver/esolver_of_tool.cpp:    ModuleBase::matrix& vr_eff = this->pelec->pot->get_effective_v();
module_esolver/esolver_of_tool.cpp:    this->kinetic_potential(this->ptemp_rho_->rho, temp_phi, vr_eff);
module_esolver/esolver_of_tool.cpp:    for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_tool.cpp:        dEdtemp_phi[this->tn_spin_flag_][i] = vr_eff(this->tn_spin_flag_, i);
module_esolver/esolver_of_tool.cpp:    double temp_mu = this->cal_mu(ptemp_phi, dEdtemp_phi[this->tn_spin_flag_], this->nelec_[this->tn_spin_flag_]);
module_esolver/esolver_of_tool.cpp:    for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_tool.cpp:        rdLdphi[i] = dEdtemp_phi[this->tn_spin_flag_][i] - 2. * temp_mu * ptemp_phi[i];
module_esolver/esolver_of_tool.cpp:    double* dphi_dtheta = new double[this->pw_rho->nrxx];
module_esolver/esolver_of_tool.cpp:    this->pelec->pot->update_from_charge(temp_rho, &ucell);
module_esolver/esolver_of_tool.cpp:    ModuleBase::matrix& vr_eff = this->pelec->pot->get_effective_v();
module_esolver/esolver_of_tool.cpp:    this->kinetic_potential(temp_rho->rho, ptemp_phi, vr_eff);
module_esolver/esolver_of_tool.cpp:        for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of_tool.cpp:            this->pdEdphi_[is][ir] = vr_eff(is, ir);
module_esolver/esolver_of_tool.cpp:            dphi_dtheta[ir] = -this->pphi_[is][ir] * sin(ptheta[is]) + this->pdirect_[is][ir] * cos(ptheta[is]);
module_esolver/esolver_of_tool.cpp:        rdEdtheta[is] = this->inner_product(this->pdEdphi_[is], dphi_dtheta, this->pw_rho->nrxx, this->dV_);
module_esolver/esolver_of_tool.cpp:    double mu = this->inner_product(pphi, pdEdphi, this->pw_rho->nrxx, this->dV_);
module_esolver/esolver_of_tool.cpp:            pw_rho->real2recip(this->pdirect_[is], this->precip_dir_[is]);
module_esolver/esolver_of_tool.cpp:            pw_rho->recip2real(this->precip_dir_[is], this->pdirect_[is]);
module_esolver/esolver_of_tool.cpp:            = this->inner_product(this->pphi_[0], this->pdirect_[0], this->pw_rho->nrxx, this->dV_);
module_esolver/esolver_of_tool.cpp:        for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_tool.cpp:            temp_theta += pow(this->pdirect_[0][i] + this->pphi_[0][i], 2);
module_esolver/esolver_of_tool.cpp:            this->pdirect_[0][i] = this->pdirect_[0][i] - this->pphi_[0][i] * inner_phi_direction / this->nelec_[0];
module_esolver/esolver_of_tool.cpp:            = this->inner_product(this->pdirect_[0], this->pdirect_[0], this->pw_rho->nrxx, this->dV_);
module_esolver/esolver_of_tool.cpp:        for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_tool.cpp:            this->pdirect_[0][i] = std::sqrt(this->nelec_[0]) * this->pdirect_[0][i] / norm_direction;
module_esolver/esolver_of_tool.cpp:        this->theta_[0] = std::min(this->theta_[0], temp_theta);
module_esolver/esolver_of_tool.cpp:                = this->inner_product(this->pphi_[is], this->pdirect_[is], this->pw_rho->nrxx, this->dV_);
module_esolver/esolver_of_tool.cpp:            for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_tool.cpp:                this->pdirect_[is][i]
module_esolver/esolver_of_tool.cpp:                    = this->pdirect_[is][i] - this->pphi_[is][i] * inner_phi_direction / this->nelec_[is];
module_esolver/esolver_of_tool.cpp:                = this->inner_product(this->pdirect_[is], this->pdirect_[is], this->pw_rho->nrxx, this->dV_);
module_esolver/esolver_of_tool.cpp:            for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_tool.cpp:                this->pdirect_[is][i] = std::sqrt(this->nelec_[is]) * this->pdirect_[is][i] / norm_direction;
module_esolver/esolver_of_tool.cpp:            this->theta_[is] = 0.;
module_esolver/esolver_of_tool.cpp:    this->cal_dEdtheta(ptemp_phi, this->ptemp_rho_, ucell, temp_theta, dEdtheta);
module_esolver/esolver_of_tool.cpp:            for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of_tool.cpp:                this->pdirect_[is][ir] = -this->pdLdphi_[is][ir];
module_esolver/esolver_of_tool.cpp:            this->adjust_direction();
module_esolver/esolver_of_tool.cpp:            this->cal_dEdtheta(ptemp_phi, this->ptemp_rho_, ucell, temp_theta, dEdtheta);
module_esolver/esolver_of_tool.cpp:    if (this->iter_ == 0)
module_esolver/esolver_of_tool.cpp:            this->theta_[0] = 0.001 * i;
module_esolver/esolver_of_tool.cpp:            for (int ir = 0; ir < this->pw_rho->nrxx; ++ir)
module_esolver/esolver_of_tool.cpp:                    = this->pphi_[0][ir] * cos(this->theta_[0]) + this->pdirect_[0][ir] * sin(this->theta_[0]);
module_esolver/esolver_of_tool.cpp:            this->cal_dEdtheta(ptemp_phi, ptemp_rho_, ucell, this->theta_, dEdtheta);
module_esolver/esolver_of_tool.cpp:            this->pelec->cal_energies(2);
module_esolver/esolver_of_tool.cpp:            temp_energy = this->pelec->f_en.etot;
module_esolver/esolver_of_tool.cpp:            kinetic_energy = this->kinetic_energy();
module_esolver/esolver_of_tool.cpp:            pseudopot_energy = this->inner_product(this->pelec->pot->get_fixed_v(),
module_esolver/esolver_of_tool.cpp:                                                   this->ptemp_rho_->rho[0],
module_esolver/esolver_of_tool.cpp:                                                   this->pw_rho->nrxx,
module_esolver/esolver_of_tool.cpp:                                                   this->dV_);
module_esolver/esolver_of_tool.cpp:            if (this->theta_[0] == 0)
module_esolver/esolver_of_tool.cpp:    if (this->iter_ == 0)
module_esolver/esolver_of_tool.cpp:    // double minPot = this->pdEdphi_[0][0];
module_esolver/esolver_of_tool.cpp:    // double maxPot = this->pdEdphi_[0][0];
module_esolver/esolver_of_tool.cpp:    // for (int i = 0; i < this->pw_rho->nrxx; ++i)
module_esolver/esolver_of_tool.cpp:    //     if (this->pdEdphi_[0][i] < minPot) minPot = this->pdEdphi_[0][i];
module_esolver/esolver_of_tool.cpp:    //     if (this->pdEdphi_[0][i] > maxPot) maxPot = this->pdEdphi_[0][i];
module_esolver/esolver_of_tool.cpp:    std::cout << std::setw(6) << this->iter_ << std::setw(22) << std::scientific
module_esolver/esolver_of_tool.cpp:              << std::setprecision(12) << this->energy_current_ / 2. << std::setw(12) << std::setprecision(3)
module_esolver/esolver_of_tool.cpp:              << this->mu_[0] / 2. << std::setw(12) << this->theta_[0] << std::setw(12) << this->normdLdphi_
module_esolver/esolver_of_tool.cpp:              << std::setw(12) << (this->energy_current_ - this->energy_last_) / 2. << std::endl;
module_esolver/esolver_of_tool.cpp:    GlobalV::ofs_running << "\nIter" << this->iter_ << ": the norm of potential is " << this->normdLdphi_ << std::endl;
module_esolver/esolver_of_tool.cpp:    if (INPUT.printe > 0 && ((this->iter_ + 1) % INPUT.printe == 0 || this->conv_ || this->iter_ == GlobalV::SCF_NMAX))
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->pelec->f_en.etot);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->pelec->f_en.ekinetic);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->pelec->f_en.hartree_energy);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->pelec->f_en.etxc - this->pelec->f_en.etxcc);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->pelec->f_en.eion_elec);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->pelec->f_en.ewald_energy);
module_esolver/esolver_of_tool.cpp:        if (this->of_kinetic_ == "tf" || this->of_kinetic_ == "tf+" || this->of_kinetic_ == "wt")
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->tf_->tf_energy);
module_esolver/esolver_of_tool.cpp:        if (this->of_kinetic_ == "vw" || this->of_kinetic_ == "tf+" || this->of_kinetic_ == "wt"
module_esolver/esolver_of_tool.cpp:            || this->of_kinetic_ == "lkt")
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->vw_->vw_energy);
module_esolver/esolver_of_tool.cpp:        if (this->of_kinetic_ == "wt")
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->wt_->wt_energy);
module_esolver/esolver_of_tool.cpp:        if (this->of_kinetic_ == "lkt")
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->lkt_->lkt_energy);
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->pelec->f_en.evdw);
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->pelec->f_en.evdw);
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->pelec->f_en.esol_el);
module_esolver/esolver_of_tool.cpp:            energies_Ry.push_back(this->pelec->f_en.esol_cav);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->pelec->f_en.etot);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->mu_[0]);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->mu_[1]);
module_esolver/esolver_of_tool.cpp:        energies_Ry.push_back(this->mu_[0]);
module_esolver/esolver_sdft_pw.cpp:    this->nche_sto = inp.nche_sto;
module_esolver/esolver_sdft_pw.cpp:    this->method_sto = inp.method_sto;
module_esolver/esolver_sdft_pw.cpp:    this->pelec = new elecstate::ElecStatePW_SDFT(pw_wfc,
module_esolver/esolver_sdft_pw.cpp:                                                  this->pw_rhod,
module_esolver/esolver_sdft_pw.cpp:                                                  this->pw_rho,
module_esolver/esolver_sdft_pw.cpp:    this->pelec->charge->allocate(GlobalV::NSPIN);
module_esolver/esolver_sdft_pw.cpp:    this->pelec->omega = ucell.omega;
module_esolver/esolver_sdft_pw.cpp:    if (this->pelec->pot == nullptr)
module_esolver/esolver_sdft_pw.cpp:        this->pelec->pot = new elecstate::Potential(pw_rhod,
module_esolver/esolver_sdft_pw.cpp:                                                    &(this->pelec->f_en.etxc),
module_esolver/esolver_sdft_pw.cpp:                                                    &(this->pelec->f_en.vtxc));
module_esolver/esolver_sdft_pw.cpp:        GlobalTemp::veff = &(this->pelec->pot->get_effective_v());
module_esolver/esolver_sdft_pw.cpp:        this->pelec->fixed_weights(GlobalV::ocp_kb);
module_esolver/esolver_sdft_pw.cpp:    this->Init_GlobalC(inp, ucell); // temporary
module_esolver/esolver_sdft_pw.cpp:            Init_Sto_Orbitals(this->stowf, inp.seed_sto);
module_esolver/esolver_sdft_pw.cpp:            Init_Sto_Orbitals_Ecut(this->stowf, inp.seed_sto, kv, *pw_wfc, inp.initsto_ecut);
module_esolver/esolver_sdft_pw.cpp:		Init_Com_Orbitals(this->stowf);
module_esolver/esolver_sdft_pw.cpp:    this->stowf.shchi = new psi::Psi<std::complex<double>>(kv.nks, stowf.nchip_max, wf.npwx, kv.ngk.data());
module_esolver/esolver_sdft_pw.cpp:        this->stowf.chiortho = new psi::Psi<std::complex<double>>(kv.nks, stowf.nchip_max, wf.npwx, kv.ngk.data());
module_esolver/esolver_sdft_pw.cpp:    this->phsol = new hsolver::HSolverPW_SDFT(&kv, pw_wfc, &wf, this->stowf, inp.method_sto);
module_esolver/esolver_sdft_pw.cpp:		Update_Sto_Orbitals(this->stowf, INPUT.seed_sto);
module_esolver/esolver_sdft_pw.cpp:    // this->pelec->print_eigenvalue(GlobalV::ofs_running);
module_esolver/esolver_sdft_pw.cpp:    this->pelec->cal_energies(2);
module_esolver/esolver_sdft_pw.cpp:        this->CE.save_files(istep,
module_esolver/esolver_sdft_pw.cpp:                            this->pw_big,
module_esolver/esolver_sdft_pw.cpp:                            this->pelec->charge,
module_esolver/esolver_sdft_pw.cpp:                            &this->sf);
module_esolver/esolver_sdft_pw.cpp:            const double ef_tmp = this->pelec->eferm.get_efval(is);
module_esolver/esolver_sdft_pw.cpp:    ModuleIO::output_convergence_after_scf(this->conv_elec, this->pelec->f_en.etot);
module_esolver/esolver_sdft_pw.cpp:    this->pelec->f_en.eband = 0.0;
module_esolver/esolver_sdft_pw.cpp:    this->pelec->f_en.demet = 0.0;
module_esolver/esolver_sdft_pw.cpp:	this->phsol->solve(
module_esolver/esolver_sdft_pw.cpp:			this->p_hamilt, 
module_esolver/esolver_sdft_pw.cpp:			this->psi[0], 
module_esolver/esolver_sdft_pw.cpp:			this->pelec, 
module_esolver/esolver_sdft_pw.cpp:			this->stowf, 
module_esolver/esolver_sdft_pw.cpp:            srho.begin(is, *(this->pelec->charge), pw_rho, GlobalC::Pgrid, GlobalC::ucell.symm);
module_esolver/esolver_sdft_pw.cpp:        this->pelec->f_en.deband = this->pelec->cal_delta_eband();
module_esolver/esolver_sdft_pw.cpp:    return this->pelec->f_en.etot;
module_esolver/esolver_sdft_pw.cpp:			*this->pelec, 
module_esolver/esolver_sdft_pw.cpp:			this->psi, 
module_esolver/esolver_sdft_pw.cpp:			this->stowf);
module_esolver/esolver_sdft_pw.cpp:			*this->pelec, 
module_esolver/esolver_sdft_pw.cpp:			this->psi, 
module_esolver/esolver_sdft_pw.cpp:			this->stowf, 
module_esolver/esolver_sdft_pw.cpp:    GlobalV::ofs_running << " !FINAL_ETOT_IS " << this->pelec->f_en.etot * ModuleBase::Ry_to_eV << " eV" << std::endl;
module_esolver/esolver_sdft_pw.cpp:    ModuleIO::write_istate_info(this->pelec->ekb, this->pelec->wg, kv, &(GlobalC::Pkpoints));
module_esolver/esolver_sdft_pw.cpp:    int nche_test = this->nche_sto;
module_esolver/esolver_sdft_pw.cpp:        this->caldos(
module_esolver/esolver_sdft_pw.cpp:        this->sKG(cond_nche,
module_esolver/esolver_sdft_pw.cpp:        this->nscf();
module_esolver/esolver_sdft_pw.cpp:    this->before_scf(istep);
module_esolver/esolver_sdft_pw.cpp:    this->hamilt2density(istep, iter, diag_thr);
module_esolver/esolver_sdft_pw.cpp:    this->pelec->cal_energies(2);
module_esolver/esolver_sdft_pw_tool.cpp:        this->start = st_per;
module_esolver/esolver_sdft_pw_tool.cpp:        this->num_per = num_per;
module_esolver/esolver_sdft_pw_tool.cpp:    //         tmpemin = std::min(tmpemin, this->pelec->ekb(ik, GlobalV::NBANDS - 1));
module_esolver/esolver_sdft_pw_tool.cpp:        this->p_hamilt->updateHk(ik);
module_esolver/esolver_sdft_pw_tool.cpp:    const double mu = this->pelec->eferm.ef;
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "cal_jmatrix");
module_esolver/esolver_sdft_pw_tool.cpp:    const float mu = static_cast<float>(this->pelec->eferm.ef);
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "cal_jmatrix");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::TITLE(this->classname, "sKG");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "sKG");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::Chebyshev<double> che(this->nche_sto);
module_esolver/esolver_sdft_pw_tool.cpp:    const double mu = this->pelec->eferm.ef;
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "kloop");
module_esolver/esolver_sdft_pw_tool.cpp:            this->p_hamilt->updateHk(ik);
module_esolver/esolver_sdft_pw_tool.cpp:            double Emax_KS = std::max(stoiter.stofunc.Emin, this->pelec->ekb(ik, GlobalV::NBANDS - 1));
module_esolver/esolver_sdft_pw_tool.cpp:                if (Emax_KS - this->pelec->ekb(ik, cutib0) > dEcut)
module_esolver/esolver_sdft_pw_tool.cpp:            double Emin_KS = (cutib0 < GlobalV::NBANDS) ? this->pelec->ekb(ik, cutib0) : stoiter.stofunc.Emin;
module_esolver/esolver_sdft_pw_tool.cpp:        int perbands_sto = this->stowf.nchip[ik];
module_esolver/esolver_sdft_pw_tool.cpp:            en_all = &(this->pelec->ekb(ik, GlobalV::NBANDS - allbands_ks));
module_esolver/esolver_sdft_pw_tool.cpp:                en[ib] = this->pelec->ekb(ik, ib0_ks + ib);
module_esolver/esolver_sdft_pw_tool.cpp:			jjcorr_ks(ik, nt, dt, dEcut, this->pelec->wg, velop, ct11, ct12, ct22);
module_esolver/esolver_sdft_pw_tool.cpp:            ModuleBase::timer::tick(this->classname, "evolution");
module_esolver/esolver_sdft_pw_tool.cpp:            ModuleBase::timer::tick(this->classname, "evolution");
module_esolver/esolver_sdft_pw_tool.cpp:            ModuleBase::timer::tick(this->classname, "ddot_real");
module_esolver/esolver_sdft_pw_tool.cpp:            ModuleBase::timer::tick(this->classname, "ddot_real");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "kloop");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "sKG");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::TITLE(this->classname, "caldos");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "caldos");
module_esolver/esolver_sdft_pw_tool.cpp:        int nchip_new = ceil((double)this->stowf.nchip_max / npart);
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "Tracepoly");
module_esolver/esolver_sdft_pw_tool.cpp:            this->p_hamilt->updateHk(ik);
module_esolver/esolver_sdft_pw_tool.cpp:        const int nchipk = this->stowf.nchip[ik];
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "Tracepoly");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "DOS Loop");
module_esolver/esolver_sdft_pw_tool.cpp:                double* en = &(this->pelec->ekb(ik, 0));
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "DOS Loop");
module_esolver/esolver_sdft_pw_tool.cpp:    ModuleBase::timer::tick(this->classname, "caldos");
module_esolver/io_npz.cpp:    const Parallel_Orbitals* paraV = this->LOWF.ParaV;
module_esolver/io_npz.cpp:    const Parallel_Orbitals* paraV = this->LM->ParaV;
module_hamilt_general/hamilt.h:        syncmem_op()(this->ctx, this->ctx, spsi, psi_in, static_cast<size_t>(nbands * nrow));
module_hamilt_general/module_surchem/surchem.cpp:    this->TOTN_real = nullptr;
module_hamilt_general/module_surchem/surchem.cpp:    this->delta_phi = nullptr;
module_hamilt_general/module_surchem/surchem.cpp:    this->epspot = nullptr;
module_hamilt_general/module_surchem/surchem.cpp:    this->clear();
module_hamilt_general/module_xc/exx_info.h:		:info_lip(this->info_global),
module_hamilt_general/module_xc/exx_info.h:		 info_ri(this->info_global){}
module_hamilt_general/operator.cpp:    if(this->hpsi != nullptr) delete this->hpsi;
module_hamilt_general/operator.cpp:    Operator* last = this->next_op;
module_hamilt_general/operator.cpp:    Operator* last_sub = this->next_sub_op;
module_hamilt_general/operator.cpp:    T* tmhpsi = this->get_hpsi(input);
module_hamilt_general/operator.cpp:    if (this->in_place)
module_hamilt_general/operator.cpp:        // ModuleBase::GlobalFunc::COPYARRAY(this->hpsi->get_pointer(), hpsi_pointer, this->hpsi->size());
module_hamilt_general/operator.cpp:        syncmem_op()(this->ctx, this->ctx, hpsi_pointer, this->hpsi->get_pointer(), this->hpsi->size());
module_hamilt_general/operator.cpp:        delete this->hpsi;
module_hamilt_general/operator.cpp:        this->hpsi = new psi::Psi<T, Device>(hpsi_pointer, *psi_input, 1, nbands / psi_input->npol);
module_hamilt_general/operator.cpp:            op->act(psi_wrapper, *this->hpsi, nbands);
module_hamilt_general/operator.cpp:            op->act(nbands, psi_input->get_nbasis(), psi_input->npol, tmpsi_in, this->hpsi->get_pointer(), psi_input->get_ngk(op->ik));
module_hamilt_general/operator.cpp:    Operator* node((Operator*)this->next_op);
module_hamilt_general/operator.cpp:    return hpsi_info(this->hpsi, psi::Range(1, 0, 0, nbands / psi_input->npol), hpsi_pointer);
module_hamilt_general/operator.cpp:    this->ik = ik_in;
module_hamilt_general/operator.cpp:    if(this->next_op != nullptr) {
module_hamilt_general/operator.cpp:        this->next_op->init(ik_in);
module_hamilt_general/operator.cpp:    if(next->next_op != nullptr) this->add(next->next_op);
module_hamilt_general/operator.cpp:    if(this->hpsi != nullptr) 
module_hamilt_general/operator.cpp:        delete this->hpsi;
module_hamilt_general/operator.cpp:        this->hpsi = nullptr;
module_hamilt_general/operator.cpp:        this->in_place = true;
module_hamilt_general/operator.cpp:        this->hpsi = new psi::Psi<T, Device>(std::get<0>(info)[0], 1, nbands_range);
module_hamilt_general/operator.cpp:        this->in_place = false;
module_hamilt_general/operator.cpp:        this->hpsi = new psi::Psi<T, Device>(hpsi_pointer, std::get<0>(info)[0], 1, nbands_range);
module_hamilt_general/operator.cpp:    hpsi_pointer = this->hpsi->get_pointer();
module_hamilt_general/operator.cpp:    size_t total_hpsi_size = nbands_range * this->hpsi->get_nbasis();
module_hamilt_general/operator.cpp:    set_memory_op()(this->ctx, hpsi_pointer, 0, total_hpsi_size);
module_hamilt_general/operator.h:    /// run this->act function for the first operator and run all act() for other nodes in chain table 
module_hamilt_general/operator.h:    virtual int get_ik() const { return this->ik; }
module_hamilt_general/operator.h:    int get_act_type() const { return this->act_type; }
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:    this->lgd_now = lgd;
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:    if(this->init_DM)
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:		this->DM = new double**[GlobalV::NSPIN];
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:		this->DM_pool = new double *[GlobalV::NSPIN];
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:			this->DM_pool[is]=new double [size_lgd_squre];
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:			this->DM[is] = new double*[lgd_now];
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:		this->init_DM = true;
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:        this->lgd_last = lgd_now;
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:        this->init_DM = false;
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:    this->dm2g.setAlltoallvParameter(this->ParaV->comm_2D, GlobalV::NLOCAL, this->ParaV->blacs_ctxt, this->ParaV->nb, this->lgd_now, this->LOWF->gridt->trace_lo);
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:    this->init_dm_2d(nks);
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:        this->LOWF->gamma_file(psid, pelec);
module_hamilt_lcao/hamilt_lcaodft/DM_gamma.cpp:    this->dm2g.cal_dk_gamma_from_2D(this->dm_gamma, this->DM, GlobalV::NSPIN, GlobalV::NLOCAL, this->lgd_now, GlobalV::ofs_running);
module_hamilt_lcao/hamilt_lcaodft/DM_gamma_2d_to_grid.cpp:    this->comm_2D = comm_2D;
module_hamilt_lcao/hamilt_lcaodft/DM_gamma_2d_to_grid.cpp:// transform dm_gamma[is].c to this->DM[is]
module_hamilt_lcao/hamilt_lcaodft/DM_gamma_2d_to_grid.cpp:            receiver_buffer, receiver_size_process, receiver_displacement_process, MPI_DOUBLE, this->comm_2D);
module_hamilt_lcao/hamilt_lcaodft/DM_gamma_2d_to_grid.cpp:        // put data from receiver buffer to this->DM[is]
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:    this->nnrg_now = nnrg;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:    if (this->init_DM_R)
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:        this->DM_R = new double *[GlobalV::NSPIN];
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:            this->DM_R[is] = new double[nnrg_now];
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:        this->nnrg_last = nnrg_now;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:        this->init_DM_R = true;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:        this->init_DM_R = false;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:    this->init_dm_2d(nks);
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                                this->LOWF->wfc_k_grid,
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                                   this->LOWF->wfc_k_grid,
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[is][gstart + iv] = DM_ATOM[is][iv].real();
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                        this->DM_R[0][gstart + iv] = DM_ATOM[0][iv].real() + DM_ATOM[3][iv].real();
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[1][gstart + iv] = DM_ATOM[1][iv].real() + DM_ATOM[2][iv].real();
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[2][gstart + iv] = DM_ATOM[1][iv].imag() - DM_ATOM[2][iv].imag();
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[3][gstart + iv] = DM_ATOM[0][iv].real() - DM_ATOM[3][iv].real();
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[1][gstart + iv] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[2][gstart + iv] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[3][gstart + iv] = DM_ATOM[0][iv].real() - DM_ATOM[3][iv].real();
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[1][gstart + iv] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[2][gstart + iv] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/DM_k.cpp:                            this->DM_R[3][gstart + iv] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:        this->calForcePwPart(fvl_dvl,
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:        this->calStressPwPart(sigmadvl,
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:    this->integral_part(GlobalV::GAMMA_ONLY_LOCAL,
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:        this->flk.finish_k(lm);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            this->forceSymmetry(fcs, symm);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // this->print_force("OVERLAP    FORCE",foverlap,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            //  this->print_force("TVNL_DPHI  force",ftvnl_dphi,GlobalV::TEST_FORCE);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            //  this->print_force("VNL_DBETA  force",fvnl_dbeta,GlobalV::TEST_FORCE);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // this->print_force("T_VNL      FORCE",ftvnl,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // this->print_force("VL_dPHI    FORCE",fvl_dphi,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // this->print_force("VL_dVL     FORCE",fvl_dvl,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // 	this->print_force("VLOCAL     FORCE",fvlocal,GlobalV::TEST_FORCE);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // this->print_force("EWALD      FORCE",fewalds,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // this->print_force("NLCC       FORCE",fcc,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:            // this->print_force("SCC        FORCE",fscc,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:                // this->print_force("EFIELD     FORCE",fefield,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:                // this->print_force("EFIELD_TDDFT     FORCE",fefield_tddft,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:                // this->print_force("GATEFIELD     FORCE",fgate,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:                // this->print_force("IMP_SOL     FORCE",fsol,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:                // this->print_force("VDW        FORCE",force_vdw,1,ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:                // this->print_force("DeePKS 	FORCE", GlobalC::ld.F_delta, 1, ry);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:        // this->printforce_total(ry, istestf, fcs);
module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp:                     *this->RA,
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->ParaV = DM->get_paraV_pointer();
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->allocate_gamma(*this->ParaV, gen_h, lm);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->cal_foverlap(isforce, isstress, psid, pelec, lm, foverlap, soverlap);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->cal_ftvnl_dphi(DM, lm, isforce, isstress, ftvnl_dphi, stvnl_dphi);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->cal_fvnl_dbeta(DM, isforce, isstress, fvnl_dbeta, svnl_dbeta);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->cal_fvl_dphi(loc.DM, isforce, isstress, pelec->pot, gint_gamma, fvl_dphi, svl_dphi);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->finish_ftable_gamma(lm);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:    this->ParaV = &pv;
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:				*this->ParaV, 
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma.cpp:				*this->ParaV, 
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_edm.cpp:    const Parallel_Orbitals* pv = this->ParaV;
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_tvnl.cpp:                const int iw1_local = this->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_tvnl.cpp:                const int iw2_local = this->ParaV->global2local_col(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_tvnl.cpp:                    const int iw1_local = this->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_tvnl.cpp:                        const int iw2_local = this->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_tvnl.cpp:            const int mu = this->ParaV->global2local_row(j);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_tvnl.cpp:            const int nu = this->ParaV->global2local_col(i);
module_hamilt_lcao/hamilt_lcaodft/FORCE_gamma_tvnl.cpp:                const int index = mu * this->ParaV->ncol + nu;
module_hamilt_lcao/hamilt_lcaodft/FORCE_k.cpp:	this->allocate_k(
module_hamilt_lcao/hamilt_lcaodft/FORCE_k.cpp:	this->cal_foverlap_k(
module_hamilt_lcao/hamilt_lcaodft/FORCE_k.cpp:	this->cal_ftvnl_dphi_k(
module_hamilt_lcao/hamilt_lcaodft/FORCE_k.cpp:	this->cal_fvl_dphi_k(
module_hamilt_lcao/hamilt_lcaodft/FORCE_k.cpp:	this->cal_fvnl_dbeta_k(
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:		this->build_Nonlocal_beta_new(HlocR, GlobalC::ucell, GlobalC::ORB, GlobalC::UOT, &(GlobalC::GridD));
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:		this->build_Nonlocal_mu_new(HlocR, false, GlobalC::ucell, GlobalC::ORB, GlobalC::UOT, &(GlobalC::GridD));
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:    this->build_ST_new('T', false, GlobalC::ucell, GlobalC::ORB, GlobalC::UOT, &(GlobalC::GridD), HlocR);
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:	this->build_ST_new('S', false, GlobalC::ucell, GlobalC::ORB, GlobalC::UOT, &(GlobalC::GridD), SlocR);
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:	const Parallel_Orbitals* pv = this->LM->ParaV;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:                                    this->LM->set_HSgamma(iw1_all, iw2_all, olm[0], HSloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->SlocR_soc[nnr] = olm1[is];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->Hloc_fixedR_soc[nnr] = olm1[is];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:									this->LM->set_force (iw1_all, iw2_all,	olm[0], olm[1], olm[2], dtype);
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:									if(cal_stress) this->LM->set_stress (iw1_all, iw2_all, olm[0], olm[1], olm[2], dtype, dtau);
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DSloc_Rx[nnr] = olm[0];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DSloc_Ry[nnr] = olm[1];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DSloc_Rz[nnr] = olm[2];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DSloc_Rx[nnr] = olm[0];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DSloc_Ry[nnr] = olm[1];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DSloc_Rz[nnr] = olm[2];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DSloc_Rx[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DSloc_Ry[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DSloc_Rz[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DH_r[nnr*3] = dtau.x;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DH_r[nnr*3 + 1] = dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DH_r[nnr*3 + 2] = dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DHloc_fixedR_x[nnr] = olm[0];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DHloc_fixedR_y[nnr] = olm[1];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DHloc_fixedR_z[nnr] = olm[2];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->stvnl11[nnr] = olm[0] * dtau.x;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->stvnl12[nnr] = olm[0] * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->stvnl13[nnr] = olm[0] * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->stvnl22[nnr] = olm[1] * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->stvnl23[nnr] = olm[1] * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->stvnl33[nnr] = olm[2] * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_x[nnr] = olm[0];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_y[nnr] = olm[1];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_z[nnr] = olm[2];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl11[nnr] = olm[0] * dtau.x;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl12[nnr] = olm[0] * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl13[nnr] = olm[0] * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl22[nnr] = olm[1] * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl23[nnr] = olm[1] * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl33[nnr] = olm[2] * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_x[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_y[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_z[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl11[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl12[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl13[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl22[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl23[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:													this->LM->stvnl33[nnr] = 0.0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:    const Parallel_Orbitals* pv = this->LM->ParaV;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:										this->LM->Hloc_fixedR_soc[nnr+nnr_inner] += nlm_tmp;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:                                                this->LM->set_HSgamma(iw1_all, iw2_all, nlm_tmp, NLloc);//N stands for nonlocal.
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_x[nnr+nnr_inner] += nlm_2[0][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_y[nnr+nnr_inner] += nlm_2[1][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_z[nnr+nnr_inner] += nlm_2[2][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_x[nnr+nnr_inner] += nlm_2[0][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_y[nnr+nnr_inner] += nlm_2[1][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_z[nnr+nnr_inner] += nlm_2[2][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_x[nnr+nnr_inner] += nlm_2[0][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_y[nnr+nnr_inner] += nlm_2[1][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_z[nnr+nnr_inner] += nlm_2[2][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_x[nnr+nnr_inner] += nlm_2[0][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_y[nnr+nnr_inner] += nlm_2[1][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:												this->LM->DHloc_fixedR_z[nnr+nnr_inner] += nlm_2[2][p1]*nlm_1[p2]*
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->set_force (iw1_all, iw2_all, nlm[0], nlm[1], nlm[2], 'N');
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DHloc_fixedR_x[nnr+nnr_inner] += nlm[0];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DHloc_fixedR_y[nnr+nnr_inner] += nlm[1];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:											this->LM->DHloc_fixedR_z[nnr+nnr_inner] += nlm[2];
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:	const Parallel_Orbitals* pv = this->LM->ParaV;
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:                            this->LM->set_HSgamma(iw1_all, iw2_all, nlm, HSloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp:                    this->LM->Hloc_fixed[i] += Nonlocal_thread[i];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    this->ParaV = &pv;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:		allocate_HS_gamma(this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:		allocate_HS_k(this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    this->Sloc.resize(nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    this->Hloc_fixed.resize(nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    this->Hloc.resize(nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    this->Sloc2.resize(nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    this->Hloc_fixed2.resize(nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    this->Hloc2.resize(nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->SlocR.resize(nnR);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:			this->Hloc_fixedR.resize(nnR);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->SlocR_soc.resize(nnR);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:			this->Hloc_fixedR_soc.resize(nnR);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    LCAO_Matrix::set_mat2d<double>(iw1_all, iw2_all, v, *this->ParaV, HSloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:		LCAO_Matrix::set_mat2d<std::complex<double>>(iw1_all, iw2_all, v, *this->ParaV, this->Sloc2.data());
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:		LCAO_Matrix::set_mat2d<std::complex<double>>(iw1_all, iw2_all, v, *this->ParaV, this->Hloc_fixed2.data());
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:		LCAO_Matrix::set_mat2d<std::complex<double>>(iw1_all, iw2_all, v, *this->ParaV, this->Hloc2.data());
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ir = this->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ic = this->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const long index = ir * this->ParaV->ncol + ic;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    if( index >= this->ParaV->nloc)
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        std::cout << " this->ParaV->nloc = " << this->ParaV->nloc << std::endl;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_x[index] += vx;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_y[index] += vy;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_z[index] += vz;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_x[index] -= vx;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_y[index] -= vy;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_z[index] -= vz;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_x[index] += vx;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_y[index] += vy;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_z[index] += vz;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ir = this->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ic = this->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const long index = ir * this->ParaV->ncol + ic;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    if( index >= this->ParaV->nloc)
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        std::cout << " this->ParaV->nloc = " << this->ParaV->nloc << std::endl;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_11[index] += vx * dtau.x;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_12[index] += vx * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_13[index] += vx * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_22[index] += vy * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_23[index] += vy * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DSloc_33[index] += vz * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_11[index] -= vx * dtau.x;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_12[index] -= vx * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_13[index] -= vx * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_22[index] -= vy * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_23[index] -= vy * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_33[index] -= vz * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_11[index] += vx * dtau.x;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_12[index] += vx * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_13[index] += vx * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_22[index] += vy * dtau.y;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_23[index] += vy * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        this->DHloc_fixed_33[index] += vz * dtau.z;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:					(long long)this->Sloc.size(), 
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:			ModuleBase::GlobalFunc::ZEROS(this->Sloc.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:					(long long)this->Hloc_fixed.size(), 
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::GlobalFunc::ZEROS(this->Hloc_fixed.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:					(long long)this->Hloc.size(), 
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::GlobalFunc::ZEROS(this->Hloc.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::BLOCK_TASK_DIST_1D(num_threads, thread_id, (long long)this->Sloc2.size(), (long long)256, beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::GlobalFunc::ZEROS(this->Sloc2.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::BLOCK_TASK_DIST_1D(num_threads, thread_id, (long long)this->Hloc_fixed2.size(), (long long)256, beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::GlobalFunc::ZEROS(this->Hloc_fixed2.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::BLOCK_TASK_DIST_1D(num_threads, thread_id, (long long)this->Hloc2.size(), (long long)256, beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            ModuleBase::GlobalFunc::ZEROS(this->Hloc2.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::BLOCK_TASK_DIST_1D(num_threads, thread_id, (long long)this->SlocR.size(), (long long)512, beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::GlobalFunc::ZEROS(this->SlocR.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::BLOCK_TASK_DIST_1D(num_threads, thread_id, (long long)this->Hloc_fixedR.size(), (long long)512, beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::GlobalFunc::ZEROS(this->Hloc_fixedR.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::BLOCK_TASK_DIST_1D(num_threads, thread_id, (long long)this->SlocR_soc.size(), (long long)256, beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::GlobalFunc::ZEROS(this->SlocR_soc.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::BLOCK_TASK_DIST_1D(num_threads, thread_id, (long long)this->Hloc_fixedR_soc.size(), (long long)256, beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                ModuleBase::GlobalFunc::ZEROS(this->Hloc_fixedR_soc.data() + beg, len);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    for(int i=0; i<this->ParaV->nrow; i++)
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        for(int j=0; j<this->ParaV->ncol; j++)
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:            const int index = i * this->ParaV->ncol + j;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    GlobalV::ofs_running << " nrow=" << this->ParaV->nrow << std::endl;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    GlobalV::ofs_running << " ncol=" << this->ParaV->ncol << std::endl;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    GlobalV::ofs_running << " element number = " << this->ParaV->ncol << std::endl;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                double v = Sloc[i*this->ParaV->ncol+j];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                double v = Hloc_fixed[i*this->ParaV->ncol+j];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                double v = Hloc[i*this->ParaV->ncol+j];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    for (long i=0; i<this->ParaV->nloc; i++)
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:	for (long i = 0; i < this->ParaV->nloc; i++)
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    Hloc_fixedR_tr[ix][iy][iz] = new double[this->ParaV->nloc];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    ModuleBase::GlobalFunc::ZEROS(Hloc_fixedR_tr[ix][iy][iz], this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    Hloc_fixedR_tr_soc[ix][iy][iz] = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    ModuleBase::GlobalFunc::ZEROS(Hloc_fixedR_tr_soc[ix][iy][iz], this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    HR_tr[ix][iy][iz] = new double[this->ParaV->nloc];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    ModuleBase::GlobalFunc::ZEROS(HR_tr[ix][iy][iz], this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    HR_tr_soc[ix][iy][iz] = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    ModuleBase::GlobalFunc::ZEROS(HR_tr_soc[ix][iy][iz], this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    SlocR_tr[ix][iy][iz] = new double[this->ParaV->nloc];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    ModuleBase::GlobalFunc::ZEROS(SlocR_tr[ix][iy][iz], this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    SlocR_tr_soc[ix][iy][iz] = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:                    ModuleBase::GlobalFunc::ZEROS(SlocR_tr_soc[ix][iy][iz], this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ir = this->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ic = this->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        index=ic*this->ParaV->nrow+ir;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        index=ir*this->ParaV->ncol+ic;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp://std::cout<<"this->ParaV->nloc: "<<this->ParaV->nloc<<std::endl;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    assert(index < this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ir = this->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    const int ic = this->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        index=ic*this->ParaV->nrow+ir;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:        index=ir*this->ParaV->ncol+ic;
module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp:    assert(index < this->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->cal_max_box_index();
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->nnrg = 0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->nnrg_index.resize(0);
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->nad = new int[GlobalC::ucell.nat];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->nlocdimg = new int[GlobalC::ucell.nat];	
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->nlocstartg = new int[GlobalC::ucell.nat];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:			if(this->in_this_processor[iat])
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->nlocstartg[iat] = this->nnrg;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->nad[iat] = 0;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:					if(this->in_this_processor[iat2])
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->nnrg_index.push_back(gridIntegral::gridIndex{this->nnrg, mu, nu, GlobalC::GridD.getBox(ad), atom1->nw, atom2->nw});
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->nnrg += nelement;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->nlocdimg[iat] += nelement; 
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->nad[iat]++;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	if(GlobalV::OUT_LEVEL != "m") ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,"nnrg",this->nnrg);
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->find_R2_sorted_index = new int*[GlobalC::ucell.nat];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:		this->find_R2_sorted_index[iat] = new int[nad[iat]];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->find_R2 = new int*[GlobalC::ucell.nat];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:		this->find_R2[iat] = new int[nad[iat]];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->find_R2st = new int*[GlobalC::ucell.nat];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:		this->find_R2st[iat] = new int[nad[iat]];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				if(this->in_this_processor[iat])
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:					if(this->in_this_processor[iat2])
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							find_R2[iat][count] = this->cal_RindexAtom(b1, b2, b3, iat2);
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->maxB1 = this->maxB2 = this->maxB3 = -10000;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	this->minB1 = this->minB2 = this->minB3 = 10000;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->maxB1 = std::max( GlobalC::GridD.getBox(ad).x, maxB1 ); 
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->maxB2 = std::max( GlobalC::GridD.getBox(ad).y, maxB2 ); 
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->maxB3 = std::max( GlobalC::GridD.getBox(ad).z, maxB3 ); 
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->minB1 = std::min( GlobalC::GridD.getBox(ad).x, minB1 ); 
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->minB2 = std::min( GlobalC::GridD.getBox(ad).y, minB2 ); 
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:				this->minB3 = std::min( GlobalC::GridD.getBox(ad).z, minB3 ); 
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	const int x1 = u1 - this->minB1;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	const int x2 = u2 - this->minB2;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	const int x3 = u3 - this->minB3;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	return (iat2 + (x3 + x2 * this->nB3 + x1 * this->nB2 * this->nB3) * GlobalC::ucell.nat);
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:    auto findR2 = this->find_R2[iat];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	auto findR2_index = this->find_R2_sorted_index[iat];
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:    const Parallel_Orbitals* pv = this->ParaV;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:					// this->SlocR = < phi_0i | phi_Rj >, where 0, R are the cell index
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:					// this->Hloc_fixed = < phi_0i | H_fixed | phi_Rj>
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->Sloc2[iic] += this->SlocR[index] * kphase;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->Hloc_fixed2[iic] += this->Hloc_fixedR[index] * kphase;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->Sloc2[iic] += this->SlocR_soc[index] * kphase;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:							this->Hloc_fixed2[iic] += this->Hloc_fixedR_soc[index] * kphase;
module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp:	assert(tot_index==this->ParaV->nnr);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LA = this->nA.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LB = this->nB.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:		const int rmesh = this->MOT.get_rmesh(this->nA.getRcut(),this->nB.getRcut()) ;
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:		this->Table_r[LAB].resize(rmesh,0);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:		this->Table_dr[LAB].resize(rmesh,0);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:		this->MOT.cal_ST_Phi12_R(
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->nA,
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->nB,
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->Table_r[LAB].data(),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->Table_dr[LAB].data());
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LA = this->nA.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LB = this->nB.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const size_t rmesh = this->MOT.get_rmesh(this->nA.getRcut(),this->nB.getRcut());
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:		this->Table_r[LAB].resize(rmesh,0);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:		this->Table_dr[LAB].resize(rmesh,0);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:		this->MOT.cal_ST_Phi12_R(
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->nA,
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->nB,
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->Table_r[LAB].data(),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			this->Table_dr[LAB].data());
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const double RcutA = this->nA.getRcut();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const double RcutB = this->nB.getRcut();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LA = this->nA.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LB = this->nB.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	for( const auto &tb_r : this->Table_r )
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:				this->MGT.Gaunt_Coefficients (
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MGT.get_lm_index(LA,mA),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MGT.get_lm_index(LB,mB),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MGT.get_lm_index(LAB,mAB));
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			const double ylm_solid = rly[ this->MGT.get_lm_index(LAB, mAB) ];
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MOT.get_rmesh(RcutA, RcutB),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MOT.dr,
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const double RcutA = this->nA.getRcut();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const double RcutB = this->nB.getRcut();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LA = this->nA.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:	const int LB = this->nB.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:    for (const auto& tb_r : this->Table_r)
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:				this->MGT.Gaunt_Coefficients (
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MGT.get_lm_index(LA,mA),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MGT.get_lm_index(LB,mB),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MGT.get_lm_index(LAB,mAB));
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:			const double ylm_solid = rly[ this->MGT.get_lm_index(LAB, mAB) ];
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:            const ModuleBase::Vector3<double> gylm_solid = grly[ this->MGT.get_lm_index(LAB, mAB) ];
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MOT.get_rmesh(RcutA, RcutB),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:					this->MOT.dr,
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:                    this->Table_dr.at(LAB).data(),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:                    this->MOT.get_rmesh(RcutA, RcutB),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.cpp:                    this->MOT.dr,
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb11.h:// this->Table_r[LAB][ir]
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const Numerical_Orbital_Lm & nA_short = (this->nA1.getNr()<=this->nA2.getNr()) ? this->nA1 : this->nA2;
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		nA_tmp[ir] = this->nA1.getPsi(ir) * this->nA2.getPsi(ir);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA1 = this->nA1.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA2 = this->nA2.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		this->nA[LA].set_orbital_info(
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		this->orb11s.insert( std::make_pair( LA, Center2_Orb::Orb11(this->nA[LA], nB, this->MOT, this->MGT) ) );
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		this->orb11s.at(LA).init_radial_table();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const Numerical_Orbital_Lm & nA_short = (this->nA1.getNr()<=this->nA2.getNr()) ? this->nA1 : this->nA2;
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		nA_tmp[ir] = this->nA1.getPsi(ir) * this->nA2.getPsi(ir);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA1 = this->nA1.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA2 = this->nA2.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		this->nA[LA].set_orbital_info(
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		this->orb11s.insert( std::make_pair( LA, Center2_Orb::Orb11(this->nA[LA], nB, this->MOT, this->MGT) ) );
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:		this->orb11s.at(LA).init_radial_table(radials);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA1 = this->nA1.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA2 = this->nA2.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	for( const auto& orb11 : this->orb11s )
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:				this->MGT.Gaunt_Coefficients (
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:					this->MGT.get_lm_index(LA1,mA1),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:					this->MGT.get_lm_index(LA2,mA2),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:					this->MGT.get_lm_index(LA,mA));
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA1 = this->nA1.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	const int LA2 = this->nA2.getL();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:	for( const auto& orb11 : this->orb11s )
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:				this->MGT.Gaunt_Coefficients (
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:					this->MGT.get_lm_index(LA1,mA1),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:					this->MGT.get_lm_index(LA2,mA2),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.cpp:					this->MGT.get_lm_index(LA,mA));
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb21.h:// this->orb11s[LA].Table_r[LAB][ir]
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:		this->nB[LB].set_orbital_info(
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:		this->orb21s.insert( std::make_pair( LB, Center2_Orb::Orb21( nA1, nA2, this->nB[LB], this->MOT, this->MGT ) ) );
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:		this->orb21s.at(LB).init_radial_table();
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:		this->nB[LB].set_orbital_info(
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:		this->orb21s.insert( std::make_pair( LB, Center2_Orb::Orb21( nA1, nA2, this->nB[LB], this->MOT, this->MGT ) ) );
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:		this->orb21s.at(LB).init_radial_table(radials);
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:	for( const auto& orb21 : this->orb21s )
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:				this->MGT.Gaunt_Coefficients (
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:					this->MGT.get_lm_index(LB1,mB1),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:					this->MGT.get_lm_index(LB2,mB2),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:					this->MGT.get_lm_index(LB,mB));
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:	for( const auto& orb21 : this->orb21s )
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:				this->MGT.Gaunt_Coefficients (
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:					this->MGT.get_lm_index(LB1,mB1),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:					this->MGT.get_lm_index(LB2,mB2),
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.cpp:					this->MGT.get_lm_index(LB,mB));
module_hamilt_lcao/hamilt_lcaodft/center2_orb-orb22.h:// this->orb21s[L34].psi2_center2[L12].Table_r[L1234][ir]
module_hamilt_lcao/hamilt_lcaodft/dm_2d.cpp:		this->dm_gamma.resize(GlobalV::NSPIN);
module_hamilt_lcao/hamilt_lcaodft/dm_2d.cpp:		this->dm_k.resize(nks);
module_hamilt_lcao/hamilt_lcaodft/dm_2d.cpp:                const int irrstart = this->ParaV->nlocstart[iat];
module_hamilt_lcao/hamilt_lcaodft/dm_2d.cpp:                        int mu = this->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/hamilt_lcaodft/dm_2d.cpp:                            int nu = this->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/hamilt_lcaodft/dm_2d.cpp:                assert(count == this->ParaV->nlocdim[iat]);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->classname = "HamiltLCAO";
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->kv = &kv_in;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->hR = new HContainer<TR>(LM_in->ParaV);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->sR = new HContainer<TR>(LM_in->ParaV);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->getOperator() = new OverlapNew<OperatorLCAO<TK, TR>>(
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->sR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        &(this->getSk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->kv = &kv_in;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->classname = "HamiltLCAO";
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->hR = new HContainer<TR>(LM_in->ParaV);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->sR = new HContainer<TR>(LM_in->ParaV);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->getSk(LM_in).resize(row_col_size);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->getHk(LM_in).resize(row_col_size);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->hR->fix_gamma();
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->getOperator() = new OverlapNew<OperatorLCAO<TK, TR>>(
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->sR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            &(this->getSk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->kv->kvec_d, 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->hR, 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(ekinetic);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        // in general case, target HR is this->hR, while target HK is LCAO_Matrix::Hloc
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->kv->kvec_d, 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->hR, 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(nonlocal);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR, // no explicit call yet
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->getOperator()->add(veff);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                                                                        this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                                                                        this->hR, // no explicit call yet
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                                                                        &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                                                                        this->kv->nks,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(deepks);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR,// no explicit call yet
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->kv->isk
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(dftu);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->getOperator() = new Veff<OperatorLCAO<TK, TR>>(
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR, 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->sR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            &(this->getSk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        if(this->getOperator() == nullptr)
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator() = overlap;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(overlap);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        // in general case, target HR is this->hR, while target HK is LCAO_Matrix::Hloc2
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(ekinetic);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        // in general case, target HR is this->hR, while target HK is LCAO_Matrix::Hloc2
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->getOperator()->add(nonlocal);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                                                    this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                                                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                                                    this->kv->nks,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(deepks);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->sR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->getOperator()->add(td_ekinetic);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->kv->kvec_d, 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR, 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(td_nonlocal);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR,// no explicit call yet
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->kv->isk
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->kv->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                    &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(dftu);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->hR,// no explicit call yet
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->kv->isk);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->getOperator()->add(sc_lambda);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->hR,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                &(this->getHk(LM_in)),
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                *this->kv,
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->getOperator()->add(exx);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    // if NSPIN==2, HR should be separated into two parts, save HR into this->hRS2
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->hRS2.resize(this->hR->get_nnr() * 2);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->hR->allocate(this->hRS2.data(), 0);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    ModuleBase::Memory::record("HamiltLCAO::hR", this->hR->get_memory_size() * memory_fold);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    ModuleBase::Memory::record("HamiltLCAO::sR", this->sR->get_memory_size());
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    auto op = dynamic_cast<OperatorLCAO<TK, TR>*>(this->getOperator());
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        if(GlobalV::VL_IN_H && this->kv->isk[ik] != GlobalV::CURRENT_SPIN)
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->hR->allocate(this->hRS2.data()+this->hRS2.size()/2*this->kv->isk[ik], 0);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            if(this->refresh_times > 0)
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                this->refresh_times--;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:                dynamic_cast<hamilt::OperatorLCAO<TK, TR>*>(this->ops)->set_hr_done(false);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        GlobalV::CURRENT_SPIN = this->kv->isk[ik];
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    this->getOperator()->init(ik);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    dynamic_cast<hamilt::OperatorLCAO<TK, TR>*>(this->ops)->set_hr_done(false);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->refresh_times = 1;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        if(this->hR->get_nnr() != this->hRS2.size()/2)
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:            this->hRS2.resize(this->hR->get_nnr() * 2); 
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        this->hR->allocate(this->hRS2.data(), 0);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    return this->ops;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    return this->hR;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    return this->sR;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:    ModuleBase::GlobalFunc::ZEROS(this->getSk(LM_in).data(), this->getSk(LM_in).size());
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        hamilt::folding_HR(*this->sR, this->getSk(LM_in).data(), this->kv->kvec_d[ik], nrow, 1);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp:        hamilt::folding_HR(*this->sR, this->getSk(LM_in).data(), this->kv->kvec_d[ik], ncol, 0);
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:        if (this->ops != nullptr)
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:            delete this->ops;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:        delete this->hR;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:        delete this->sR;
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:    /// get sk-pointer of std::vector<TK>, the return will be this->sk
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:    /// get HR pointer of *this->hR, which is a HContainer<TR> and contains H(R)
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:    /// get SR pointer of *this->sR, which is a HContainer<TR> and contains S(R)
module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.h:    // save them in this->hRS2;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->init_DM = false;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->lgd_now = 0;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->lgd_last = 0;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->init_DM_R = false;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    if (this->init_DM)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    if (this->init_DM_R)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->LOWF = &lowf;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->LOWF->gridt = &gt;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->allocate_gamma(gt.lgd, psi, pelec, kv.nks, istep);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->LOWF = &lowf;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->LOWF->gridt = &gt;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_charge.cpp:    this->allocate_DM_k(kv.nks, gt.nnrg);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:	if(this->complex_flag)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:        delete[] this->wfc_k_grid2;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:    if(this->wfck_flag)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:			delete[] this->wfc_k_grid[i];
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:		delete[] this->wfc_k_grid;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:    int ncol = this->ParaV->ncol_bands;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:        ncol = this->ParaV->ncol;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:        psid->resize(GlobalV::NSPIN, ncol, this->ParaV->nrow);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:        this->error = ModuleIO::read_wfc_nao(ctot, is, GlobalV::GAMMA_ONLY_LOCAL, GlobalV::NB2D, GlobalV::NBANDS, 
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:                                             GlobalV::NLOCAL, GlobalV::global_readin_dir, this->ParaV, psid, pelec);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:        Parallel_Common::bcast_int(this->error);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:        switch (this->error)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:        if (this->error)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:    this->nks = nks;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:	if(this->wfck_flag == false)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:		this->wfc_k_grid = new std::complex<double>**[nks];
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:			this->wfc_k_grid[ik] = new std::complex<double>*[GlobalV::NBANDS];
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:		this->wfck_flag = true;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:	if(this->complex_flag)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:		delete[] this->wfc_k_grid2;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:		this->complex_flag = false;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:		this->wfc_k_grid2=new std::complex<double> [nks*page];
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:				this->wfc_k_grid[ik][ib] = &wfc_k_grid2[ik*page+ib*lgd];
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:			this->complex_flag = true;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:            psi->resize(nkstot, this->ParaV->ncol_bands, this->ParaV->nrow);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:            this->error = ModuleIO::read_wfc_nao_complex(ctot, ik, GlobalV::NB2D, GlobalV::NBANDS, GlobalV::NLOCAL, 
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:                                    GlobalV::global_readin_dir, kvec_c[ik], this->ParaV, psi, pelec);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:            Parallel_Common::bcast_int(this->error);
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:            switch (this->error)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:            if (this->error)
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:    const Parallel_Orbitals* pv = this->ParaV;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:				info = this->set_wfc_grid(naroc, pv->nb,
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:				info = this->set_wfc_grid(naroc, pv->nb,
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:    const Parallel_Orbitals* pv = this->ParaV;
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:				info = this->set_wfc_grid(naroc, pv->nb,
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.cpp:				info = this->set_wfc_grid(naroc, pv->nb,
module_hamilt_lcao/hamilt_lcaodft/local_orbital_wfc.h:			int mu_local = this->gridt->trace_lo[igrow];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    this->cal_type = lcao_deepks;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    this->initialize_HR(GridD_in, LM_in->ParaV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    if (this->H_V_delta != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        delete this->H_V_delta;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    //this->H_V_delta = new HContainer<TR>(paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->H_V_delta = new HContainer<TR>(paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->H_V_delta->fix_gamma();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    this->adjs_all.clear();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    this->adjs_all.reserve(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->nlm_tot.resize(ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->nlm_tot.resize(1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            if (this->ucell->cal_dtau(iat0, iat1, R_index1).norm() * this->ucell->lat0
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->adjs_all.push_back(adjs);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:                    this->H_V_delta->insert_pair(tmp);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            this->pre_calculate_nlm(iat0, nlm_tot[iat0]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->H_V_delta->allocate(nullptr, true);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->hR->add(*this->H_V_delta);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->hR->allocate(nullptr, false);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        const Parallel_Orbitals* pv = this->LM->ParaV;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_projected_DM(this->DM,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            *this->ucell,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_descriptor(this->ucell->nat);        
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_gedm(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        //GlobalC::ld.add_v_delta(*this->ucell,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->H_V_delta->set_zero();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->calculate_HR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    this->hR->add(*this->H_V_delta);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_projected_DM_k(this->DM,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            *this->ucell,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_descriptor(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_gedm(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        //GlobalC::ld.add_v_delta_k(*this->ucell, GlobalC::ORB, GlobalC::GridD, this->LM->ParaV->nnr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        if(this->H_V_delta == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            this->H_V_delta = new hamilt::HContainer<double>(*this->hR);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->H_V_delta->set_zero();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->calculate_HR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    this->hR->add(*this->H_V_delta);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_projected_DM_k(this->DM,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            *this->ucell,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_descriptor(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        GlobalC::ld.cal_gedm(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        //    .add_v_delta_k(*this->ucell, GlobalC::ORB, GlobalC::GridD, this->LM->ParaV->nnr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        if(this->H_V_delta == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            this->H_V_delta = new hamilt::HContainer<std::complex<double>>(*this->hR);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->H_V_delta->set_zero();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        this->calculate_HR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    this->hR->add(*this->H_V_delta);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    const Parallel_Orbitals* paraV = this->LM->ParaV;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    AdjacentAtomInfo& adjs = this->adjs_all[iat0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    if(this->H_V_delta->size_atom_pairs() == 0)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    const Parallel_Orbitals* paraV = this->H_V_delta->get_atom_pair(0).get_paraV();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    for (int iat0 = 0; iat0 < this->ucell->nat; iat0++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        AdjacentAtomInfo& adjs = this->adjs_all[iat0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        if(nlm_tot.size() != this->ucell->nat)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:            this->pre_calculate_nlm(iat0, nlm_tot[iat00]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:                hamilt::BaseMatrix<TR>* tmp = this->H_V_delta->find_matrix(iat1, iat2, R_vector[0], R_vector[1], R_vector[2]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:                this->cal_HR_IJR(hr_current.data(), row_size, col_size, tmp->get_pointer());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:    ModuleBase::GlobalFunc::ZEROS(h_delta_k, this->hK->size());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        const int nrow = this->LM->ParaV->get_row_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        hamilt::folding_HR(*this->H_V_delta, h_delta_k, this->kvec_d[ik], nrow, 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        const int ncol = this->LM->ParaV->get_col_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp:        hamilt::folding_HR(*this->H_V_delta, h_delta_k, this->kvec_d[ik], ncol, 0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    if(this->dftu->get_dmr(0) == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    const hamilt::HContainer<double>* dmR_tmp[this->nspin];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    dmR_tmp[0] = this->dftu->get_dmr(0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    if(this->nspin==2) dmR_tmp[1] = this->dftu->get_dmr(1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    for (int iat0 = 0; iat0 < this->ucell->nat; iat0++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:        const int target_L = this->dftu->orbital_corr[T0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:        AdjacentAtomInfo& adjs = this->adjs_all[atom_index++];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:                        T1, L1, N1, M1, T0, dtau * this->ucell->lat0, 1 /*cal_deri*/, nlm);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:                for(int iw =0;iw < this->ucell->atoms[T0].nw; iw++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:                    const int L0 = this->ucell->atoms[T0].iw2l[iw];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:        std::vector<double> occ(tlp1 * tlp1 * this->nspin, 0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:            occ[i] = this->dftu->locale[iat0][target_L][0][is].c[ii];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:        const double u_value = this->dftu->U[T0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:        this->cal_v_of_u(occ, tlp1, u_value, &VU[0], eu_tmp);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:                const hamilt::BaseMatrix<double>* tmp[this->nspin];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:                if(this->nspin == 2)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:                    if (cal_force) this->cal_force_IJR(iat1, iat2, paraV, nlm_tot[ad1], nlm_tot[ad2], VU, tmp, this->nspin, force_tmp1, force_tmp2);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:                    if (cal_stress) this->cal_stress_IJR(iat1, iat2, paraV, nlm_tot[ad1], nlm_tot[ad2], VU, tmp, this->nspin, dis1, dis2, stress_tmp.data());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:        const double weight = this->ucell->lat0 / this->ucell->omega;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_force_stress.hpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->cal_type = lcao_dftu;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->ucell = &ucell_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->dftu = dftu_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    assert(this->ucell != nullptr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->initialize_HR(GridD_in, &paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->nspin = GlobalV::NSPIN;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->adjs_all.clear();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->adjs_all.reserve(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        const int target_L = this->dftu->orbital_corr[T0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:            if (this->ucell->cal_dtau(iat0, iat1, R_index1).norm() * this->ucell->lat0
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        this->adjs_all.push_back(adjs);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    if(this->precal_nlm_done) return;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    nlm_tot.resize(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        const int target_L = this->dftu->orbital_corr[T0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        AdjacentAtomInfo& adjs = this->adjs_all[atom_index++];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                        T1, L1, N1, M1, T0, dtau * this->ucell->lat0, 0 /*cal_deri*/, nlm);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                for(int iw =0;iw < this->ucell->atoms[T0].nw; iw++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                    const int L0 = this->ucell->atoms[T0].iw2l[iw];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                for(int iw =0;iw < this->ucell->atoms[T0].nw; iw++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                    const int L0 = this->ucell->atoms[T0].iw2l[iw];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->precal_nlm_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    if(this->dftu->get_dmr(0) == nullptr && this->dftu->initialed_locale == false)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        //will update this->dftu->locale and this->dftu->EU
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        if(this->current_spin == 0) this->dftu->EU = 0.0;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    const Parallel_Orbitals* paraV = this->hR->get_atom_pair(0).get_paraV();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    this->cal_nlm_all(paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    for (int iat0 = 0; iat0 < this->ucell->nat; iat0++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        const int target_L = this->dftu->orbital_corr[T0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        AdjacentAtomInfo& adjs = this->adjs_all[atom_index++];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        const int spin_fold = (this->nspin == 4) ? 4 : 1;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        if(this->dftu->initialed_locale == false)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:            const hamilt::HContainer<double>* dmR_current = this->dftu->get_dmr(this->current_spin);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                        this->cal_occ(iat1, iat2, paraV, nlm1, nlm2, tmp->get_pointer(), occ);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                if(this->nspin==1) occ[i] *= 0.5;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                this->dftu->locale[iat0][target_L][0][this->current_spin].c[i] = occ[i];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                occ[i] = this->dftu->locale[iat0][target_L][0][this->current_spin].c[i];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        const double u_value = this->dftu->U[T0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        this->cal_v_of_u(occ, tlp1, u_value, VU_tmp.data(), this->dftu->EU);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:        this->transfer_vu(VU_tmp, VU);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                hamilt::BaseMatrix<TR>* tmp = this->hR->find_matrix(iat1, iat2, R_vector[0], R_vector[1], R_vector[2]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:                    this->cal_HR_IJR(iat1, iat2, paraV, nlm1, nlm2, VU, tmp->get_pointer());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    if(this->nspin==1) this->dftu->EU *= 2.0;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    if(this->current_spin == this->nspin-1 || this->nspin==4) this->dftu->initialed_locale = false;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    // update this->current_spin: only nspin=2 iterate change it between 0 and 1
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    if(this->nspin == 2) this->current_spin = 1 - this->current_spin;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.h:     * @brief search the nearest neighbor atoms and save them into this->adjs_all
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.h:     * @brief calculate the <phi|alpha^I> overlap values and save them in this->nlm_tot
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->cal_type = lcao_fixed;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->ucell = ucell_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    assert(this->ucell != nullptr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->initialize_HR(GridD_in, paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    if (this->allocated)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        delete this->HR_fixed;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            if (this->ucell->cal_dtau(iat1, iat2, R_index2).norm() * this->ucell->lat0
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        this->adjs_all.push_back(adjs);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            this->hR->insert_pair(tmp);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->hR->allocate(nullptr, true);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    if(this->HR_fixed==nullptr || this->HR_fixed->size_atom_pairs()<=0)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    const Parallel_Orbitals* paraV = this->HR_fixed->get_atom_pair(0).get_paraV();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    for (int iat1 = 0; iat1 < this->ucell->nat; iat1++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        AdjacentAtomInfo& adjs = this->adjs_all[iat1];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            ModuleBase::Vector3<double> dtau = this->ucell->cal_dtau(iat1, iat2, R_index2);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            hamilt::BaseMatrix<TR>* tmp = this->HR_fixed->find_matrix(iat1, iat2, R_index2.x, R_index2.y, R_index2.z);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:                this->cal_HR_IJR(iat1, iat2, paraV, dtau, tmp->get_pointer());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->ucell->iat2iait(iat1, &I1, &T1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->ucell->iat2iait(iat2, &I2, &T2);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    Atom& atom1 = this->ucell->atoms[T1];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    Atom& atom2 = this->ucell->atoms[T2];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    const ModuleBase::Vector3<double>& tau1 = this->ucell->get_tau(iat1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:                    T2, L2, N2, M2, dtau * this->ucell->lat0, olm);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->HR_fixed = static_cast<hamilt::HContainer<TR>*>(HR_fixed_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    this->allocated = false;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    if (!this->HR_fixed_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        if (this->HR_fixed == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            this->HR_fixed = new hamilt::HContainer<TR>(*this->hR);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            this->HR_fixed->set_zero();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            this->allocated = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        if(this->next_sub_op != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:            static_cast<OperatorLCAO<TK, TR>*>(this->next_sub_op)->set_HR_fixed(this->HR_fixed);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        this->calculate_HR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        this->HR_fixed_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:    if(this->next_sub_op == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/ekinetic_new.cpp:        this->hR->add(*(this->HR_fixed));
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/meta_lcao.h:        this->cal_type = lcao_gint;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/meta_lcao.h:        this->cal_type = lcao_gint;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->cal_type = lcao_fixed;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->ucell = ucell_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    assert(this->ucell != nullptr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->initialize_HR(GridD_in, paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    if (this->allocated)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        delete this->HR_fixed;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->adjs_all.clear();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->adjs_all.reserve(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:            if (this->ucell->cal_dtau(iat0, iat1, R_index1).norm() * this->ucell->lat0
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                < orb.Phi[T1].getRcut() + this->ucell->infoNL.Beta[T0].get_rcut_max())
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        this->adjs_all.push_back(adjs);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                this->hR->insert_pair(tmp);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->hR->allocate(nullptr, true);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    const Parallel_Orbitals* paraV = this->HR_fixed->get_atom_pair(0).get_paraV();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    for (int iat0 = 0; iat0 < this->ucell->nat; iat0++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    for (int iat0 = 0; iat0 < this->ucell->nat; iat0++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        AdjacentAtomInfo& adjs = this->adjs_all[iat0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                        T1, L1, N1, M1, T0, dtau * this->ucell->lat0, 0 /*cal_deri*/, nlm);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                                      this->ucell->infoNL,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                hamilt::BaseMatrix<TR>* tmp = this->HR_fixed->find_matrix(iat1, iat2, R_vector[0], R_vector[1], R_vector[2]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                    this->cal_HR_IJR(iat1, iat2, T0, paraV, nlm_tot[ad1], nlm_tot[ad2], tmp->get_pointer());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                for (int no = 0; no < this->ucell->atoms[T0].ncpp.non_zero_count_soc[is]; no++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                    const int p1 = this->ucell->atoms[T0].ncpp.index1_soc[is][no];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                    const int p2 = this->ucell->atoms[T0].ncpp.index2_soc[is][no];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:                    this->ucell->atoms[T0].ncpp.get_d(is, p1, p2, tmp_d);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->HR_fixed = static_cast<hamilt::HContainer<TR>*>(HR_fixed_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    this->allocated = false;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    if (!this->HR_fixed_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        if (this->HR_fixed == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:            this->HR_fixed = new hamilt::HContainer<TR>(*this->hR);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:            this->HR_fixed->set_zero();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:            this->allocated = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        if(this->next_sub_op != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:            static_cast<OperatorLCAO<TK, TR>*>(this->next_sub_op)->set_HR_fixed(this->HR_fixed);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        this->calculate_HR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        this->HR_fixed_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:    if(this->next_sub_op == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/nonlocal_new.cpp:        this->hR->add(*(this->HR_fixed));
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:    std::vector<double> eff_pot(this->LM->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:    for (int irc = 0; irc < this->LM->ParaV->nloc; irc++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:        this->LM->Hloc[irc] += eff_pot[irc];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:    std::vector<std::complex<double>> eff_pot(this->LM->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:    for (int irc = 0; irc < this->LM->ParaV->nloc; irc++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:        this->LM->Hloc2[irc] += eff_pot[irc];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:    std::vector<std::complex<double>> eff_pot(this->LM->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:    for (int irc = 0; irc < this->LM->ParaV->nloc; irc++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.cpp:        this->LM->Hloc2[irc] += eff_pot[irc];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_dftu_lcao.h:        this->cal_type = lcao_dftu;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:    BlasConnector::axpy(this->LM->ParaV->get_local_size(), 1.0, this->LM->Hexxd_k_load[ik].data(), 1, this->LM->Hloc.data(), 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:    BlasConnector::axpy(this->LM->ParaV->get_local_size(), 1.0, this->LM->Hexxc_k_load[ik].data(), 1, this->LM->Hloc2.data(), 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:    BlasConnector::axpy(this->LM->ParaV->get_local_size(), 1.0, this->LM->Hexxc_k_load[ik].data(), 1, this->LM->Hloc2.data(), 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:    if (this->two_level_step != nullptr && *this->two_level_step == 0 && !this->restart) return;  //in the non-exx loop, do nothing 
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:        if (this->restart && this->two_level_step != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:            if (*this->two_level_step == 0)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                if (this->LM->Hexxd_k_load.size() > 0)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                    this->LM->Hexxd_k_load.clear();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                    this->LM->Hexxd_k_load.shrink_to_fit();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                else if (this->LM->Hexxc_k_load.size() > 0)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                    this->LM->Hexxc_k_load.clear();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                    this->LM->Hexxc_k_load.shrink_to_fit();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                this->Hexxd == nullptr ? *this->LM->Hexxd : *this->Hexxd,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                *this->LM->ParaV,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                *this->hK);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                this->Hexxc == nullptr ? *this->LM->Hexxc : *this->Hexxc,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                *this->LM->ParaV,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.cpp:                *this->hK);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:        this->cal_type = lcao_exx;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                this->LM->Hexxd_k_load.resize(this->kv.nks);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                for (int ik = 0; ik < this->kv.nks; ik++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                    this->LM->Hexxd_k_load[ik].resize(this->LM->ParaV->get_local_size(), 0.0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                        this->LM->ParaV->get_local_size(), this->LM->Hexxd_k_load[ik].data(), false);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                this->LM->Hexxc_k_load.resize(this->kv.nks);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                for (int ik = 0; ik < this->kv.nks; ik++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                    this->LM->Hexxc_k_load[ik].resize(this->LM->ParaV->get_local_size(), 0.0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/op_exx_lcao.h:                        this->LM->ParaV->get_local_size(), this->LM->Hexxc_k_load[ik].data(), false);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->hmatrix_k = this->LM->Hloc.data();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    if ((this->new_e_iteration && ik == 0) || hsolver::HSolverLCAO<double>::out_mat_hs[0])
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        if (this->smatrix_k == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->smatrix_k = new double[this->LM->Sloc.size()];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->allocated_smatrix = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        BlasConnector::copy(this->LM->Sloc.size(), this->LM->Sloc.data(), inc, this->smatrix_k, inc);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        this->new_e_iteration = false;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->hmatrix_k = this->LM->Hloc2.data();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->smatrix_k = this->LM->Sloc2.data();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->hmatrix_k = this->LM->Hloc2.data();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->smatrix_k = this->LM->Sloc2.data();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->LM->zeros_HSgamma('H');
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->LM->zeros_HSk('H');
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->LM->zeros_HSk('H');
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->hr_done = hr_done_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    if(this->is_first_node)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        this->refresh_h();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->hR->set_zero();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    switch(this->cal_type)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->contributeHk(ik_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:                this->contributeHR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->contributeHk(ik_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:                this->contributeHR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->contributeHk(ik_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->contributeHR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->contributeHk(ik_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            this->contributeHk(ik_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    if(this->next_op != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:            dynamic_cast<OperatorLCAO<TK, TR>*>(this->next_op)->hr_done = this->hr_done;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        this->next_op->init(ik_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:    this->hr_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        const int nrow = this->LM->ParaV->get_row_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        hamilt::folding_HR(*this->hR, this->hK->data(), this->kvec_d[ik], nrow, 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        const int ncol = this->LM->ParaV->get_col_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.cpp:        hamilt::folding_HR(*this->hR, this->hK->data(), this->kvec_d[ik], ncol, 0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:        if (this->allocated_smatrix)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:            delete[] this->smatrix_k;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:        this->get_hs_pointers();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:                               (size_t)this->LM->ParaV->nrow,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:                               (size_t)this->LM->ParaV->ncol,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:                               this->LM->ParaV->desc};
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:                               (size_t)this->LM->ParaV->nrow,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:                               (size_t)this->LM->ParaV->ncol,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:                               this->LM->ParaV->desc};
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:        hk_in = MatrixBlock<TK>{hmatrix_k, (size_t)this->LM->ParaV->nrow, (size_t)this->LM->ParaV->ncol, nullptr};
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/operator_lcao.h:        sk_in = MatrixBlock<TK>{smatrix_k, (size_t)this->LM->ParaV->nrow, (size_t)this->LM->ParaV->ncol, nullptr};
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->cal_type = lcao_overlap;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->ucell = ucell_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->SR = SR_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->SK_pointer = SK_pointer_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    assert(this->ucell != nullptr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    assert(this->SR != nullptr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    assert(this->SK_pointer != nullptr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->initialize_SR(GridD_in, paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:            if (this->ucell->cal_dtau(iat1, iat2, R_index).norm() * this->ucell->lat0
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    for (int iap = 0; iap < this->SR->size_atom_pairs(); ++iap)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:        hamilt::AtomPair<TR>& tmp = this->SR->get_atom_pair(iap);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:            this->cal_SR_IJR(iat1, iat2, paraV, dtau, data_pointer);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:        this->SR->fix_gamma();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->ucell->iat2iait(iat1, &I1, &T1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->ucell->iat2iait(iat2, &I2, &T2);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    Atom& atom1 = this->ucell->atoms[T1];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    Atom& atom2 = this->ucell->atoms[T2];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    const ModuleBase::Vector3<double>& tau1 = this->ucell->get_tau(iat1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:                    T2, L2, N2, M2, dtau * this->ucell->lat0, olm);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    if (this->SR_fixed_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->calculate_SR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->SR_fixed_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    if (this->kvec_d[ik] == this->kvec_d_old && std::is_same<TK, double>::value)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    ModuleBase::GlobalFunc::ZEROS(this->SK_pointer->data(), this->SK_pointer->size());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:        const int nrow = this->SR->get_atom_pair(0).get_paraV()->get_row_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:        hamilt::folding_HR(*this->SR, this->SK_pointer->data(), this->kvec_d[ik], nrow, 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:        const int ncol = this->SR->get_atom_pair(0).get_paraV()->get_col_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:        hamilt::folding_HR(*this->SR, this->SK_pointer->data(), this->kvec_d[ik], ncol, 0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    this->kvec_d_old = this->kvec_d[ik];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:    if(this->SK_pointer != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/overlap_new.cpp:        return this->SK_pointer->data();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:    std::vector<std::complex<double>> h_lambda(this->LM->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:    sc.cal_h_lambda(&h_lambda[0], this->LM->Sloc2, ModuleBase::GlobalFunc::IS_COLUMN_MAJOR_KS_SOLVER(), this->isk[ik]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:    for (int irc = 0; irc < this->LM->ParaV->nloc; irc++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:        this->LM->Hloc2[irc] += h_lambda[irc];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:    std::vector<std::complex<double>> h_lambda(this->LM->ParaV->nloc);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:    sc.cal_h_lambda(&h_lambda[0], this->LM->Sloc2, ModuleBase::GlobalFunc::IS_COLUMN_MAJOR_KS_SOLVER(), this->isk[ik]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:    for (int irc = 0; irc < this->LM->ParaV->nloc; irc++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.cpp:        this->LM->Hloc2[irc] += h_lambda[irc];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/sc_lambda_lcao.h:        this->cal_type = lcao_sc_lambda;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->LM = LM_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->ucell = ucell_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->cal_type = lcao_tddft_velocity;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->Grid = GridD_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->init_td();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->initialize_HR(Grid,this->LM->ParaV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    if (this->hR_tmp != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        delete this->hR_tmp;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    if(this->hR_tmp==nullptr || this->hR_tmp->size_atom_pairs()<=0)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    const Parallel_Orbitals* paraV = this->hR_tmp->get_atom_pair(0).get_paraV();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    for (int iat1 = 0; iat1 < this->ucell->nat; iat1++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        AdjacentAtomInfo& adjs = this->adjs_all[iat1];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            ModuleBase::Vector3<double> dtau = this->ucell->cal_dtau(iat1, iat2, R_index2);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            hamilt::BaseMatrix<std::complex<double>>* tmp = this->hR_tmp->find_matrix(iat1, iat2, R_index2.x, R_index2.y, R_index2.z);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            hamilt::BaseMatrix<TR>* tmp1 = this->SR->find_matrix(iat1, iat2, R_index2.x, R_index2.y, R_index2.z);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:                this->cal_HR_IJR(iat1, iat2, paraV, dtau, tmp->get_pointer(),tmp1->get_pointer());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->ucell->iat2iait(iat1, &I1, &T1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->ucell->iat2iait(iat2, &I2, &T2);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    Atom& atom1 = this->ucell->atoms[T1];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    Atom& atom2 = this->ucell->atoms[T2];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    const ModuleBase::Vector3<double>& tau1 = this->ucell->get_tau(iat1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->MOT.allocate(
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:	this->MOT.init_Table_Spherical_Bessel (2, 1, Lmax_used, Lmax, 1, GlobalC::ORB, GlobalC::ucell.infoNL.Beta);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:	this->MGT.init_Gaunt_CH( Lmax );
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:	this->MGT.init_Gaunt( Lmax );
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:									this->MOT, this->MGT)));
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->hR_tmp = static_cast<hamilt::HContainer<std::complex<double>>*>(hR_tmp_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->allocated = false;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->adjs_all.clear();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->adjs_all.reserve(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            if (this->ucell->cal_dtau(iat1, iat2, R_index2).norm() * this->ucell->lat0
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->adjs_all.push_back(adjs);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    for (int i = 0; i < this->hR->size_atom_pairs(); ++i)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        hamilt::AtomPair<TR>& tmp = this->hR->get_atom_pair(i);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            this->hR_tmp->insert_pair(tmp1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    this->hR_tmp->allocate(nullptr,true);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    //const Parallel_Orbitals* paraV = this->hR->get_atom_pair(0).get_paraV();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:    if (!this->hR_tmp_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        if (this->hR_tmp == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->hR_tmp = new hamilt::HContainer<std::complex<double>>(this->LM->ParaV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->initialize_HR_tmp(this->LM->ParaV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->allocated = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        if(this->next_sub_op != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            static_cast<OperatorLCAO<TK, TR>*>(this->next_sub_op)->set_HR_fixed(this->hR_tmp);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->calculate_HR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        this->hR_tmp_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:        elecstate::H_TDDFT_pw::td_hR = this->hR_tmp;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            const int nrow = this->LM->ParaV->get_row_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            hamilt::folding_HR(*this->hR_tmp, this->hK->data(), this->kvec_d[ik], nrow, 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            const int ncol = this->LM->ParaV->get_col_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_ekinetic_lcao.cpp:            hamilt::folding_HR(*this->hR_tmp, this->hK->data(), this->kvec_d[ik], ncol, 0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->cal_type = lcao_tddft_velocity;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->ucell = ucell_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->LM = LM_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->Grid = GridD_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    assert(this->ucell != nullptr);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->init_td();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->initialize_HR(Grid,this->LM->ParaV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    if (this->allocated)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        delete this->hR_tmp;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->adjs_all.clear();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->adjs_all.reserve(this->ucell->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            if (this->ucell->cal_dtau(iat0, iat1, R_index1).norm() * this->ucell->lat0
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                < orb.Phi[T1].getRcut() + this->ucell->infoNL.Beta[T0].get_rcut_max())
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        this->adjs_all.push_back(adjs);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    for (int i = 0; i < this->hR->size_atom_pairs(); ++i)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        hamilt::AtomPair<TR>& tmp = this->hR->get_atom_pair(i);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            this->hR_tmp->insert_pair(tmp1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->hR_tmp->allocate(nullptr,true);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    const Parallel_Orbitals* paraV = this->hR_tmp->get_atom_pair(0).get_paraV();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    for (int iat0 = 0; iat0 < this->ucell->nat; iat0++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    for (int iat0 = 0; iat0 < this->ucell->nat; iat0++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        AdjacentAtomInfo& adjs = this->adjs_all[iat0];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                                            this->ucell->infoNL,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                                            tau1 * this->ucell->lat0,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                                            tau0 * this->ucell->lat0,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                                            this->ucell->infoNL,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                                            tau1 * this->ucell->lat0,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                                            tau0 * this->ucell->lat0,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                hamilt::BaseMatrix<std::complex<double>>* tmp = this->hR_tmp->find_matrix(iat1, iat2, R_vector[0], R_vector[1], R_vector[2]);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                    this->cal_HR_IJR(iat1, iat2, T0, paraV, nlm_tot[ad1], nlm_tot[ad2], tmp->get_pointer());
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    const int npol = this->ucell->get_npol();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                for (int no = 0; no < this->ucell->atoms[T0].ncpp.non_zero_count_soc[is]; no++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                    const int p1 = this->ucell->atoms[T0].ncpp.index1_soc[is][no];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                    const int p2 = this->ucell->atoms[T0].ncpp.index2_soc[is][no];
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                    //this->ucell->atoms[T0].ncpp.get_d(is, p1, p2, tmp_d);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:                    this->ucell->atoms[T0].ncpp.get_d(is, p2, p1, tmp_d);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->hR_tmp = static_cast<hamilt::HContainer<std::complex<double>>*>(hR_tmp_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    this->allocated = false;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:    if (!this->hR_tmp_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        if (this->hR_tmp == nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            this->hR_tmp = new hamilt::HContainer<std::complex<double>>(this->LM->ParaV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            this->initialize_HR_tmp(this->LM->ParaV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            this->allocated = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        if(this->next_sub_op != nullptr)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            static_cast<OperatorLCAO<TK, TR>*>(this->next_sub_op)->set_HR_fixed(this->hR_tmp);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        this->calculate_HR();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:        this->hR_tmp_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            const int nrow = this->LM->ParaV->get_row_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            folding_HR(*this->hR_tmp, this->hK->data(), this->kvec_d[ik], nrow, 1);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            const int ncol = this->LM->ParaV->get_col_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/td_nonlocal_lcao.cpp:            folding_HR(*this->hR_tmp, this->hK->data(), this->kvec_d[ik], ncol, 0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/test_sc_lambda_lcao.cpp:                                                                                                     this->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/test_sc_lambda_lcao.cpp:                                                                                                     this->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/test_sc_lambda_lcao.cpp:                                                                                                     this->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/test_sc_lambda_lcao.cpp:                                                                                                      this->kvec_d,
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/test_sc_lambda_lcao.cpp:        = hamilt::OperatorScLambda<hamilt::OperatorLCAO<double, double>>(nullptr, this->kvec_d, nullptr, nullptr, isk);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:	this->iat2iwt.resize(this->nat);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:	this->npol = npol_in;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:	for(int it = 0;it < this->ntype; it++)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:			this->iat2iwt[iat] = iwt;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:			iwt += atoms[it].nw * this->npol;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:    if(!this->hr_done)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:        this->hr_done = true;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:    this->contributeHk(ik_in);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:    if (!this->is_first_node)
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:        const int ncol = this->hR->get_atom_pair(0).get_paraV()->get_col_size();
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:        hamilt::folding_HR(*this->hR, this->hK->data(), this->kvec_d[ik], ncol, 0);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:LCAO_Orbitals::LCAO_Orbitals() {this->Phi = new Numerical_Orbital[1];}
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:    this->rcut_max = 1.0;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/test/tmp_mocks.cpp:    this->rcut = 1.0;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:                this->hR->insert_pair(tmp);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    this->hR->allocate(nullptr, true);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    double* vr_eff1 = this->pot->get_effective_v(GlobalV::CURRENT_SPIN);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    double* vofk_eff1 = this->pot->get_effective_vofk(GlobalV::CURRENT_SPIN);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    this->GK->reset_spin(GlobalV::CURRENT_SPIN);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:        this->GK->cal_gint(&inout);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:        this->GK->cal_gint(&inout);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:            vr_eff1 = this->pot->get_effective_v(is);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:                vofk_eff1 = this->pot->get_effective_vofk(is);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:                this->GK->cal_gint(&inout);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:                this->GK->cal_gint(&inout);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    this->GK->transfer_pvpR(this->hR);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    const double* vr_eff1 = this->pot->get_effective_v(GlobalV::CURRENT_SPIN);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    const double* vofk_eff1 = this->pot->get_effective_vofk(GlobalV::CURRENT_SPIN);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:        this->GG->cal_vlocal(&inout,  this->new_e_iteration);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:        this->GG->cal_vlocal(&inout,  this->new_e_iteration);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    this->GG->transfer_pvpR(this->hR);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.cpp:    this->new_e_iteration = false;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.h:        this->cal_type = lcao_gint;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.h:        this->initialize_HR(ucell_in, GridD_in, paraV);
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.h:        this->cal_type = lcao_gint;
module_hamilt_lcao/hamilt_lcaodft/operator_lcao/veff_lcao.h:        this->initialize_HR(ucell_in, GridD_in, paraV);
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:		this->delete_grid();
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:	this->na_proc = GlobalC::ucell.nat;
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:	this->na_each = new int[na_proc];
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:	this->info = new int**[na_proc];
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:	this->na_proc = 0;
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:	this->iat2ca = new int[GlobalC::ucell.nat];
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:	this->na_each = new int[na_proc];
module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp:	this->info = new int**[na_proc];
module_hamilt_lcao/hamilt_lcaodft/wavefunc_in_pw.cpp:                                            ModuleBase::WARNING_QUIT("this->wf.atomic_wfc()", "error: too many wfcs");
module_hamilt_lcao/hamilt_lcaodft/wavefunc_in_pw.cpp:										ModuleBase::WARNING_QUIT("this->wf.atomic_wfc()", "error: too many wfcs");
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    for (int inl = 0;inl < this->inlmax;inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        for (int inl = 0;inl < this->inlmax;inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->lmaxd = lm;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->nmaxd = nm;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    GlobalV::ofs_running << " lmax of descriptor = " << this->lmaxd << std::endl;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->inlmax = tot_inl;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        pdm_size = (this->lmaxd * 2 + 1) * (this->lmaxd * 2 + 1);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        for(int il = 0; il < this->lmaxd + 1; il++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->des_per_atom=pdm_size;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->pdm = new double* [this->inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    for (int inl = 0;inl < this->inlmax;inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->pdm[inl] = new double[pdm_size];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        ModuleBase::GlobalFunc::ZEROS(this->pdm[inl], pdm_size);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->des_per_atom=0; // mohan add 2021-04-21
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        for (int l = 0; l <= this->lmaxd; l++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->des_per_atom += orb.Alpha[0].getNchi(l) * (2 * l + 1);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->n_descriptor = nat * this->des_per_atom;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->init_index(ntype, nat, na, tot_inl, orb);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->allocate_nlm(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->pv = &pv_in;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    delete[] this->alpha_index;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->alpha_index = new ModuleBase::IntArray[ntype];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    delete[] this->inl_index;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->inl_index = new ModuleBase::IntArray[ntype];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    delete[] this->inl_l;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->inl_l = new int[this->inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    ModuleBase::GlobalFunc::ZEROS(this->inl_l, this->inlmax);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->alpha_index[it].create(
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->lmaxd + 1, // l starts from 0
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->nmaxd,
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            2 * this->lmaxd + 1); // m ==> 2*l+1
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->inl_index[it].create(
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->lmaxd + 1,
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->nmaxd); 
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            for (int l = 0; l < this->lmaxd + 1; l++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:                        this->alpha_index[it](ia, l, n, m) = alpha;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:                    this->inl_index[it](ia, l, n) = inl;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:                    this->inl_l[inl] = l;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    assert(this->n_descriptor == alpha);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    GlobalV::ofs_running << " descriptors_per_atom " << this->des_per_atom << std::endl;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    GlobalV::ofs_running << " total_descriptors " << this->n_descriptor << std::endl;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->nlm_save.resize(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->nlm_save_k.resize(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->gdmx = new double** [nat];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->gdmy = new double** [nat];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->gdmz = new double** [nat];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->gdmx[iat] = new double* [inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->gdmy[iat] = new double* [inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->gdmz[iat] = new double* [inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->gdmx[iat][inl] = new double [(2 * lmaxd + 1) * (2 * lmaxd + 1)];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->gdmy[iat][inl] = new double [(2 * lmaxd + 1) * (2 * lmaxd + 1)];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->gdmz[iat][inl] = new double[(2 * lmaxd + 1) * (2 * lmaxd + 1)];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->nat_gdm = nat;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            delete[] this->gdmx[iat][inl];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            delete[] this->gdmy[iat][inl];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            delete[] this->gdmz[iat][inl];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        delete[] this->gdmx[iat];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        delete[] this->gdmy[iat];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        delete[] this->gdmz[iat];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    delete[] this->gdmx;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    delete[] this->gdmy;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    delete[] this->gdmz;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->gdm_epsl = new double** [6];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->gdm_epsl[ipol] = new double* [inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->gdm_epsl[ipol][inl] = new double [(2 * lmaxd + 1) * (2 * lmaxd + 1)];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            delete[] this->gdm_epsl[ipol][inl];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        delete[] this->gdm_epsl[ipol];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    delete[] this->gdm_epsl;
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->H_V_delta.resize(pv->nloc);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        ModuleBase::GlobalFunc::ZEROS(this->H_V_delta.data(), pv->nloc);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->H_V_delta_k[ik].resize(pv->nloc);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            ModuleBase::GlobalFunc::ZEROS(this->H_V_delta_k[ik].data(), pv->nloc);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    const int pdm_size = (this->lmaxd * 2 + 1) * (this->lmaxd * 2 + 1);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->gedm = new double* [this->inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    for (int inl = 0;inl < this->inlmax;inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->gedm[inl] = new double[pdm_size];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        ModuleBase::GlobalFunc::ZEROS(this->gedm[inl], pdm_size);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->init_gdmx(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->init_gdmepsl();
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:    this->orbital_pdm_shell = new double*** [nks];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        this->orbital_pdm_shell[iks] = new double** [1];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            this->orbital_pdm_shell[iks][hl] = new double* [this->inlmax];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            for(int inl = 0; inl < this->inlmax; inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:                this->orbital_pdm_shell[iks][hl][inl] = new double [(2 * this->lmaxd + 1) * (2 * this->lmaxd + 1)];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:                ModuleBase::GlobalFunc::ZEROS(orbital_pdm_shell[iks][hl][inl], (2 * this->lmaxd + 1) * (2 * this->lmaxd + 1));
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            for (int inl = 0;inl < this->inlmax; inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:                delete[] this->orbital_pdm_shell[iks][hl][inl];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:            delete[] this->orbital_pdm_shell[iks][hl];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:        delete[] this->orbital_pdm_shell[iks];
module_hamilt_lcao/module_deepks/LCAO_deepks.cpp:     delete[] this->orbital_pdm_shell;    
module_hamilt_lcao/module_deepks/LCAO_deepks.h:    int get_hr_cal(){ return this->hr_cal; }
module_hamilt_lcao/module_deepks/LCAO_deepks.h:    void set_hr_cal(bool cal){ this->hr_cal = cal; }
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:    this->F_delta.zero_out();
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:    int nrow = this->pv->nrow;
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            std::vector<double> nlm1 = this->nlm_save[iat][ad1][row_indexes[iw1]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                nlm2[dim] = this->nlm_save[iat][ad2][col_indexes[iw2]][dim+1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                    const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                                nlm[dim] += this->gedm[inl][m1*nm+m2]*nlm1[ib+m1]*nlm2[dim][ib+m2];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(iat, 0) -= 2 * *dm_current * nlm[0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(iat, 1) -= 2 * *dm_current * nlm[1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(iat, 2) -= 2 * *dm_current * nlm[2];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(ibt2, 0) += 2 * *dm_current * nlm[0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(ibt2, 1) += 2 * *dm_current * nlm[1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(ibt2, 2) += 2 * *dm_current * nlm[2];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                nlm1 = this->nlm_save[iat][ad2][col_indexes[iw2]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                    nlm2[i] = this->nlm_save[iat][ad1][row_indexes[iw1]][i+1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                                    nlm_t[dim] += this->gedm[inl][m1*nm+m2]*nlm1[ib+m1]*nlm2[dim][ib+m2];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:    this->F_delta.zero_out();
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:    int nrow = this->pv->nrow;
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            std::vector<double> nlm1 = this->nlm_save_k[iat][key_1][row_indexes[iw1]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                nlm2[dim] = this->nlm_save_k[iat][key_2][col_indexes[iw2]][dim+1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                    const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                                nlm[dim] += this->gedm[inl][m1*nm+m2]*nlm1[ib+m1]*nlm2[dim][ib+m2];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(ibt2, 0) += 2.0 * *dm_current * nlm[0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(ibt2, 1) += 2.0 * *dm_current * nlm[1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(ibt2, 2) += 2.0 * *dm_current * nlm[2];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(iat, 0) -= 2.0 * *dm_current * nlm[0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(iat, 1) -= 2.0 * *dm_current * nlm[1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                            this->F_delta(iat, 2) -= 2.0 * *dm_current * nlm[2];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                nlm1 = this->nlm_save_k[iat][key_2][col_indexes[iw2]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                    nlm2[i] = this->nlm_save_k[iat][key_1][row_indexes[iw1]][i+1];
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_fdelta.cpp:                                                    nlm_t[dim] += this->gedm[inl][m1*nm+m2]*nlm1[ib+m1]*nlm2[dim][ib+m2];
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:            ofs << dm[mu * this->pv->nrow + nu] << " ";
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                ofs << dm[ik][mu * this->pv->nrow + nu] << " ";
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                npy_des.push_back(this->d_tensor[inl].index({im}).item().toDouble());
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:        const long unsigned dshape[] = {static_cast<unsigned long>(nat), static_cast<unsigned long>(this->des_per_atom)};
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:            for(int i = 0; i < this->des_per_atom; i++)
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                npy_des.push_back(this->d_tensor[iat].index({i}).item().toDouble());
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:        const long unsigned dshape[] = {static_cast<unsigned long>(nat), static_cast<unsigned long>(this->des_per_atom)};
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:        = {static_cast<unsigned long>(nat), 3UL, static_cast<unsigned long>(nat), static_cast<unsigned long>(this->des_per_atom)};
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                for(int p=0;p<this->des_per_atom;++p)
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                    npy_gvx.push_back(this->gvx_tensor.index({ ibt, i, iat, p }).item().toDouble());
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:    const long unsigned gshape[] = {6UL, static_cast<unsigned long>(nat), static_cast<unsigned long>(this->des_per_atom)};
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:            for(int p=0;p<this->des_per_atom;++p)
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                npy_gvepsl.push_back(this->gvepsl_tensor.index({ i, ibt, p }).item().toDouble());
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                                    static_cast<unsigned long>(this->des_per_atom)};
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                for(int p=0; p<this->des_per_atom; ++p)
module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp:                    npy_orbital_precalc.push_back(this->orbital_precalc_tensor.index({iks, hl, iat, p }).item().toDouble());
module_hamilt_lcao/module_deepks/LCAO_deepks_odelta.cpp:    this->o_delta.zero_out();
module_hamilt_lcao/module_deepks/LCAO_deepks_odelta.cpp:                        this->o_delta(0,hl) += dm_hl[hl][is](nu, mu) * this->H_V_delta[index];
module_hamilt_lcao/module_deepks/LCAO_deepks_odelta.cpp:        Parallel_Reduce::reduce_all(this->o_delta(0, hl));
module_hamilt_lcao/module_deepks/LCAO_deepks_odelta.cpp:                        o_delta_k += dm_hl[hl][ik](nu, mu) * this->H_V_delta_k[ik][iic];
module_hamilt_lcao/module_deepks/LCAO_deepks_odelta.cpp:            this->o_delta(ik,hl) = o_delta_k.real();
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        pdm_size = (this->lmaxd * 2 + 1) * (this->lmaxd * 2 + 1);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        for(int il = 0; il < this->lmaxd + 1; il++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    if (GlobalV::init_chg == "file" && !this->init_pdm) //for DeePKS NSCF calculation 
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        for(int inl=0;inl<this->inlmax;inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        this->init_pdm = true;
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    int nrow = this->pv->nrow;
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                for(int il = 0; il < this->lmaxd + 1; il++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                    const double* row_ptr = this->nlm_save[iat][ad1][row_indexes[irow]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                        const double* col_ptr = this->nlm_save[iat][ad2][col_indexes[icol]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                            const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                    for(int il = 0; il < this->lmaxd + 1; il++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    allsum_deepks(this->inlmax,pdm_size,this->pdm);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        pdm_size = (this->lmaxd * 2 + 1) * (this->lmaxd * 2 + 1);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        for(int il = 0; il < this->lmaxd + 1; il++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    if (GlobalV::init_chg == "file" && !this->init_pdm) //for DeePKS NSCF calculation 
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        for(int inl=0;inl<this->inlmax;inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        this->init_pdm = true;
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                for(int il = 0; il < this->lmaxd + 1; il++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                if(this->nlm_save_k[iat].find(key_1) == this->nlm_save_k[iat].end()) continue;
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                    const double* row_ptr = this->nlm_save_k[iat][key_1][row_indexes[irow]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                    if(this->nlm_save_k[iat].find(key_2) == this->nlm_save_k[iat].end()) continue;
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                        const double* col_ptr = this->nlm_save_k[iat][key_2][col_indexes[icol]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                            const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                    for(int il = 0; il < this->lmaxd + 1; il++)
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    allsum_deepks(this->inlmax,pdm_size,this->pdm);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    const int pdm_size = (this->lmaxd * 2 + 1) * (this->lmaxd * 2 + 1);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    int nrow = this->pv->nrow;
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                            std::vector<double> nlm1 = this->nlm_save[iat][ad1][row_indexes[iw1]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                            std::vector<std::vector<double>> nlm2 = this->nlm_save[iat][ad2][col_indexes[iw2]];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                    const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                nlm1 = this->nlm_save[iat][ad2][col_indexes[iw2]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                nlm2 = this->nlm_save[iat][ad1][row_indexes[iw1]];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        allsum_deepks(this->inlmax,size,this->gdmx[iat]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        allsum_deepks(this->inlmax,size,this->gdmy[iat]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        allsum_deepks(this->inlmax,size,this->gdmz[iat]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:            allsum_deepks(this->inlmax,size,this->gdm_epsl[ipol]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    int nrow = this->pv->nrow;
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                            std::vector<double> nlm1 = this->nlm_save_k[iat][key_1][row_indexes[iw1l]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                            std::vector<std::vector<double>> nlm2 = this->nlm_save_k[iat][key_2][col_indexes[iw2l]];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                    const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                nlm1 = this->nlm_save_k[iat][key_2][col_indexes[iw2l]][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                nlm2 = this->nlm_save_k[iat][key_1][row_indexes[iw1l]];
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:                                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        allsum_deepks(this->inlmax,size,this->gdmx[iat]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        allsum_deepks(this->inlmax,size,this->gdmy[iat]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:        allsum_deepks(this->inlmax,size,this->gdmz[iat]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:            allsum_deepks(this->inlmax,size,this->gdm_epsl[ipol]);
module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp:    const int pdm_size = (this->lmaxd * 2 + 1) * (this->lmaxd * 2 + 1);
module_hamilt_lcao/module_deepks/LCAO_deepks_psialpha.cpp:                this->nlm_save[iat].resize(GridD.getAdjacentNum()+1);
module_hamilt_lcao/module_deepks/LCAO_deepks_psialpha.cpp:                    this->nlm_save[iat][ad].clear();
module_hamilt_lcao/module_deepks/LCAO_deepks_psialpha.cpp:                        this->nlm_save[iat][ad].insert({all_indexes[iw1l],nlm});
module_hamilt_lcao/module_deepks/LCAO_deepks_psialpha.cpp:                    this->nlm_save_k[iat][key_1]=nlm_cur;
module_hamilt_lcao/module_deepks/LCAO_deepks_psialpha.cpp:                        nlm = this->nlm_save[iat][ad][iw1];
module_hamilt_lcao/module_deepks/LCAO_deepks_psialpha.cpp:                        nlm = this->nlm_save_k[iat][key_1][iw1];
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    if (!this->d_tensor.empty())
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->d_tensor.erase(this->d_tensor.begin(), this->d_tensor.end());
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->d_tensor.push_back(tmp);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->cal_descriptor_equiv(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    if (!this->d_tensor.empty())
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->d_tensor.erase(this->d_tensor.begin(), this->d_tensor.end());
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    if (!this->pdm_tensor.empty())
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->pdm_tensor.erase(this->pdm_tensor.begin(), this->pdm_tensor.end());
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    for (int inl = 0;inl < this->inlmax;++inl)
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                tmp.index_put_({m1, m2}, this->pdm[inl][m1 * nm + m2]);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        //torch::Tensor tmp = torch::from_blob(this->pdm[inl], { nm, nm }, torch::requires_grad());
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->pdm_tensor.push_back(tmp);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->d_tensor.push_back(torch::ones({ nm }, torch::requires_grad(true)));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        std::tuple<torch::Tensor, torch::Tensor> d_v(this->d_tensor[inl], vd);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                ofs << ucell.atoms[it].label << " atom_index " << ia + 1 << " n_descriptor " << this->des_per_atom << std::endl;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            ofs << ucell.atoms[it].label << " atom_index " << iat + 1 << " n_descriptor " << this->des_per_atom << std::endl;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            for(int i = 0; i < this->des_per_atom; i ++)
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                ofs << this->pdm[iat][i] << " ";
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->cal_gvdm(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        int nlmax = this->inlmax/nat;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                        int nm = 2*this->inl_l[inl]+1;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                                if(i==0) mmv.push_back(this->gdmx[ibt][inl][m1*nm+m2]);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                                if(i==1) mmv.push_back(this->gdmy[ibt][inl][m1*nm+m2]);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                                if(i==2) mmv.push_back(this->gdmz[ibt][inl][m1*nm+m2]);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            this->gdmr_vector.push_back(torch::stack(bmmv, 0)); //nbt*3*nat*nm*nm
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gdmr_vector.size()==nlmax);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            gvx_vector.push_back(at::einsum("bxamn, avmn->bxav", {this->gdmr_vector[nl], this->gevdm_vector[nl]}));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->gvx_tensor = torch::cat(gvx_vector, -1);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gvx_tensor.size(0) == nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gvx_tensor.size(1) == 3);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gvx_tensor.size(2) == nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gvx_tensor.size(3) == this->des_per_atom);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->cal_gvdm(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        int nlmax = this->inlmax/nat;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                        int nm = 2*this->inl_l[inl]+1;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                                 mmv.push_back(this->gdm_epsl[i][inl][m1*nm+m2]);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            this->gdmepsl_vector.push_back(torch::stack(bmmv, 0)); //nbt*3*nat*nm*nm
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gdmepsl_vector.size()==nlmax);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            gvepsl_vector.push_back(at::einsum("bamn, avmn->bav", {this->gdmepsl_vector[nl], this->gevdm_vector[nl]}));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->gvepsl_tensor = torch::cat(gvepsl_vector, -1);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gvepsl_tensor.size(0) == 6);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gvepsl_tensor.size(1) == nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        assert(this->gvepsl_tensor.size(2) == this->des_per_atom);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            int nm = 2*this->inl_l[inl]+1;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            torch::Tensor tmp_x = this->pdm_tensor[inl].reshape({nm, nm}).unsqueeze(0).repeat({nm, 1, 1});
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->gevdm_vector.push_back(avmm);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    assert(this->gevdm_vector.size() == nlmax);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        this->module = torch::jit::load(deepks_model);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    //using this->pdm_tensor
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    inputs.push_back(torch::cat(this->d_tensor, 0).reshape({ 1, nat, this->des_per_atom }));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->E_delta = ec[0].item().toDouble() * 2;//Ry; *2 is for Hartree to Ry
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->gedm_tensor = torch::autograd::grad(ec, this->pdm_tensor, gedm_shell, /*retain_grad=*/true, /*create_graph=*/false, /*allow_unused=*/true);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                this->gedm[inl][index] = this->gedm_tensor[inl].index({ m1,m2 }).item().toDouble() * 2;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                ofs << this->gedm[inl][index] << " ";
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->cal_gvdm(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->init_orbital_pdm_shell(1);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                    const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                    const double* row_ptr = this->nlm_save[iat][ad1][row_indexes[irow]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                        const double* col_ptr = this->nlm_save[iat][ad2][col_indexes[icol]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    for(int inl = 0; inl < this->inlmax; inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        Parallel_Reduce::reduce_all(this->orbital_pdm_shell[0][0][inl], (2 * this->lmaxd + 1) * (2 * this->lmaxd + 1));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    int nlmax = this->inlmax/nat;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                int nm = 2*this->inl_l[inl]+1;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                        mmv.push_back(this->orbital_pdm_shell[iks][0][inl][m1*nm+m2]);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        orbital_precalc_vector.push_back(at::einsum("kiamn, avmn->kiav", {orbital_pdm_shell_vector[nl], this->gevdm_vector[nl]}));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->orbital_precalc_tensor = torch::cat(orbital_precalc_vector, -1);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->del_orbital_pdm_shell(1);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->cal_gvdm(nat);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->init_orbital_pdm_shell(nks);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                    const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                if(this->nlm_save_k[iat].find(key_1) == this->nlm_save_k[iat].end()) continue;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                    const double* row_ptr = this->nlm_save_k[iat][key_1][row_indexes[irow]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                    if(this->nlm_save_k[iat].find(key_2) == this->nlm_save_k[iat].end()) continue;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                        const double* col_ptr = this->nlm_save_k[iat][key_2][col_indexes[icol]][0].data();
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                            const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:            for(int inl = 0; inl < this->inlmax; inl++)
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                Parallel_Reduce::reduce_all(this->orbital_pdm_shell[iks][hl][inl], (2 * this->lmaxd + 1)* (2 * this->lmaxd + 1));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    int nlmax = this->inlmax/nat;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                    int nm = 2*this->inl_l[inl]+1;
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:                            mmv.push_back(this->orbital_pdm_shell[iks][hl][inl][m1*nm+m2]);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:        orbital_precalc_vector.push_back(at::einsum("kiamn, avmn->kiav", {orbital_pdm_shell_vector[nl], this->gevdm_vector[nl]}));
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->orbital_precalc_tensor = torch::cat(orbital_precalc_vector, -1);
module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp:    this->del_orbital_pdm_shell(nks);
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:    ModuleBase::GlobalFunc::ZEROS(this->H_V_delta.data(), pv->nrow * pv->ncol); //init before calculate
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                            std::vector<double> nlm1 = this->nlm_save[iat][ad1][iw1_all][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                            std::vector<double> nlm2 = this->nlm_save[iat][ad2][iw2_all][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                                    const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                                            nlm += this->gedm[inl][m1*nm+m2]*nlm1[ib+m1]*nlm2[ib+m2];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                            this->H_V_delta[iic] += nlm;
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:    ModuleBase::GlobalFunc::ZEROS(this->H_V_deltaR, nnr_in);
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                                std::vector<double> nlm1 = this->nlm_save_k[iat][key_1][iw1_all][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                                std::vector<double> nlm2 = this->nlm_save_k[iat][key_2][iw2_all][0];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                                        const int inl = this->inl_index[T0](I0, L0, N0);
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                                                nlm += this->gedm[inl][m1*nm+m2]*nlm1[ib+m1]*nlm2[ib+m2];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                                this->H_V_deltaR[nnr+nnr_inner] += nlm;
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:    this->e_delta_band = 0;
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                    //this->e_delta_band += dm[is](nu, mu) * this->H_V_delta[index];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:					this->e_delta_band += dm[is][nu*this->pv->nrow+mu] * this->H_V_delta[index];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:    Parallel_Reduce::reduce_all(this->e_delta_band);
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:                    //e_delta_band_k += dm[ik](nu, mu) * this->H_V_delta_k[ik][iic];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:					e_delta_band_k += dm[ik][nu * this->pv->nrow + mu] * this->H_V_delta_k[ik][iic];
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:    this->e_delta_band = e_delta_band_k.real();
module_hamilt_lcao/module_deepks/LCAO_deepks_vdelta.cpp:    Parallel_Reduce::reduce_all(this->e_delta_band);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("S_I_mu_alpha.dat","S_I_mu_alpha_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("psialpha.dat","psialpha_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("dpsialpha_x.dat","dpsialpha_x_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("dpsialpha_y.dat","dpsialpha_y_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("dpsialpha_z.dat","dpsialpha_z_ref.dat");	
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->read_dm();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->set_dm_new();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.cal_projected_DM(dm_new,
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->read_dm_k(kv.nkstot);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->set_dm_k_new();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.cal_projected_DM_k(dm_k_new,
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.check_projected_dm();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("pdm.dat","pdm_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.init_gdmx(ucell.nat);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.cal_gdmx(dm_new[0],
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.cal_gdmx_k(dm_k_new,
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.check_gdmx(ucell.nat);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref(ss.str(),ss1.str());
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref(ss.str(),ss1.str());
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref(ss.str(),ss1.str());
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.cal_descriptor(ucell.nat);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.check_descriptor(ucell);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("descriptor.dat","descriptor_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.cal_gvx(ucell.nat);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.check_gvx(ucell.nat);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref(ss.str(),ss1.str());
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref(ss.str(),ss1.str());
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref(ss.str(),ss1.str());
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.load_model("model.ptg");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:        this->ld.allocate_V_delta(ucell.nat);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:        this->ld.allocate_V_delta(ucell.nat, kv.nkstot);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.cal_gedm(ucell.nat);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	ofs << std::setprecision(10) << this->ld.E_delta << std::endl;
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("E_delta.dat","E_delta_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->ld.check_gedm();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("gedm.dat","gedm_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:        this->ld.cal_e_delta_band(dm_new);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->folding_nnr(kv);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:        this->ld.cal_e_delta_band_k(dm_k_new, kv.nkstot);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	ofs << std::setprecision(10) << this->ld.e_delta_band << std::endl;
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("E_delta_bands.dat","E_delta_bands_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.add_v_delta(ucell,
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:        this->ld.check_v_delta();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref("H_V_delta.dat","H_V_delta_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->cal_nnr();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.allocate_V_deltaR(nnr);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.add_v_delta_k(ucell,
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->ld.check_v_delta_k(nnr);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:		this->compare_with_ref("H_V_deltaR.dat","H_V_deltaR_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->compare_with_ref("F_delta.dat","F_delta_ref.dat");
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:	this->total_check+=1;
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:				this->failed_check+=1;
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test.cpp:				this->failed_check+=1;
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:    this->count_ntype();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:	this->set_parameters();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:    this->setup_cell();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:	this->setup_kpt();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:	this->set_ekcut();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:	this->set_orbs(ucell.lat0);
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:	this->prep_neighbour();
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:    this->ParaO.set_global2local(GlobalV::NLOCAL, GlobalV::NLOCAL,
module_hamilt_lcao/module_deepks/test/LCAO_deepks_test_prep.cpp:	this->kv.set(
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->nspin = nspin_in;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		bool read_succesfully = this->read_kpoints(
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->set_both_kvec(reciprocal_vec, latvec, ofs_running);
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->normalize_wk(deg);
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->set_kup_and_kdw(ofs_running);
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->print_klists(ofs_running);
module_hamilt_lcao/module_deepks/test/klist_1.cpp:			this->Monkhorst_Pack(nmp, koffset, k_type);
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->kc_done = true;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->kd_done = true;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				int nks_special = this->nkstot;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->kc_done = true;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				int nks_special = this->nkstot;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->renew(nkstot * nspin);//mohan fix bug 2009-09-01
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->kd_done = true;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->nkstot = mpnx * mpny * mpnz;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->renew(nkstot * nspin); // mohan fix bug 2009-09-01
module_hamilt_lcao/module_deepks/test/klist_1.cpp:		this->kd_done = true;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_d[i].x
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_d[i].y
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_d[i].z
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->wk[i] << std::endl;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:			sum += this->wk[ik];
module_hamilt_lcao/module_deepks/test/klist_1.cpp:			this->wk[ik] /= sum;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:			this->wk[ik] *= degspin;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->isk[ik] = 0;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->kvec_c[ik+nkstot] = kvec_c[ik];
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->kvec_d[ik+nkstot] = kvec_d[ik];
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->wk[ik+nkstot]     = wk[ik];
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->isk[ik]        = 0;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->isk[ik+nkstot]    = 1;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:			this->nkstot *= 2;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				this->isk[ik] = 0;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_c[i].x
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_c[i].y
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_c[i].z
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->wk[i] << std::endl;
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_d[i].x
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_d[i].y
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->kvec_d[i].z
module_hamilt_lcao/module_deepks/test/klist_1.cpp:				<< std::setw(20) << this->wk[i] << std::endl;
module_hamilt_lcao/module_deepks/test/nnr.cpp:	this->nnr = 0;
module_hamilt_lcao/module_deepks/test/nnr.cpp:		assert(index==this->nnr);
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:    const Parallel_Orbitals* pv = this->ParaV;
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:    for (const auto& sc_elem1 : this->get_atomCounts())
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:        int nw_it1 = this->get_orbitalCounts().at(it1);
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:            int iat1 = this->get_iat(it1, ia1);
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:            for (int iw1 = 0; iw1 < nw_it1*this->npol_; iw1++)
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                int iwt1 = this->get_iwt(it1, ia1, iw1);
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                for (const auto& sc_elem2 : this->get_atomCounts())
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                    int nw_it2 = this->get_orbitalCounts().at(it2);
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                        int iat2 = this->get_iat(it2, ia2);
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                        for (int iw2 = 0; iw2 < nw_it2*this->npol_; iw2++)
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                            int iwt2 = this->get_iwt(it2, ia2, iw2);
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                            ModuleBase::Vector3<double> lambda = (this->lambda_[iat1] + this->lambda_[iat2]) / 2.0;
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                                if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                                else if (this->nspin_ == 4)
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                                if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/cal_h_lambda.cpp:                                else if (this->nspin_ == 4)
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:    int nw = this->get_nw();
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:    const int nlocal = (this->nspin_ == 4) ? nw / 2 : nw;
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:    ModuleBase::matrix MecMulP(this->nspin_, nlocal, true), orbMulP(this->nspin_, nlocal, true);
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:    for(size_t ik = 0; ik != this->kv_.nks; ++ik)
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:        if (this->nspin_ == 4)
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:            dynamic_cast<hamilt::HamiltLCAO<std::complex<double>, std::complex<double>>*>(this->p_hamilt)->updateSk(ik, LM, 1);
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:            dynamic_cast<hamilt::HamiltLCAO<std::complex<double>, double>*>(this->p_hamilt)->updateSk(ik, LM, 1);
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:        ModuleBase::ComplexMatrix mud(this->ParaV->ncol, this->ParaV->nrow, true);
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:                this->ParaV->desc,
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:                this->ParaV->desc,
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:                this->ParaV->desc);
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:        this->collect_MW(MecMulP, mud, nw, this->kv_.isk[ik]);
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:    MPI_Allreduce(MecMulP.c, orbMulP.c, this->nspin_*nlocal, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:        = dynamic_cast<const elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec)->get_DM()->get_DMK_vector();
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:    this->calculate_MW(this->convert(this->cal_MW_k(LM, dm)));
module_hamilt_lcao/module_deltaspin/cal_mw.cpp:    this->print_Mi(print);
module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp:    this->phsol->solve(this->p_hamilt, this->psi[0], this->pelec, this->KS_SOLVER, true);
module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp:        = dynamic_cast<elecstate::ElecStateLCAO<std::complex<double>>*>(this->pelec);
module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp:    this->pelec->calculate_weights();
module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp:    this->pelec->calEBand();
module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp:    if (this->KS_SOLVER == "genelpa" || this->KS_SOLVER == "scalapack_gvx" || this->KS_SOLVER == "lapack" || this->KS_SOLVER == "cg_in_lcao")
module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp:        elecstate::cal_dm_psi(this->ParaV, pelec_lcao->wg, *(this->psi), *(pelec_lcao->get_DM()));
module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp:    this->cal_MW(i_step, this->LM);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    AorbMulP.resize(this->nspin_);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    for (int is = 0; is < this->nspin_; ++is)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:        for (const auto& sc_elem: this->get_atomCounts())
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:            int nw_it = this->get_orbitalCounts().at(it);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                int iat = this->get_iat(it, ia);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    size_t nw = this->get_nw();
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    this->zero_Mi();
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    const int nlocal = (this->nspin_ == 4) ? nw / 2 : nw;
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    for (const auto& sc_elem: this->get_atomCounts())
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:            int iat = this->get_iat(it, ia);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:            std::vector<double> total_charge_soc(this->nspin_, 0.0);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:            for (const auto& lnchi: this->get_lnchiCounts().at(it))
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                std::vector<double> sum_l(this->nspin_, 0.0);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    std::vector<double> sum_m(this->nspin_, 0.0);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                        for (int j = 0; j < this->nspin_; j++)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    for (int j = 0; j < this->nspin_; j++)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                else if (this->nspin_ == 4)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    for (int j = 0; j < this->nspin_; j++)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:            if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                this->Mi_[iat].x = 0.0;
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                this->Mi_[iat].y = 0.0;
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                this->Mi_[iat].z = atom_mag;
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:            else if (this->nspin_ == 4)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                this->Mi_[iat].x = (std::abs(total_charge_soc[1]) < this->sc_thr_)? 0.0 : total_charge_soc[1];
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                this->Mi_[iat].y = (std::abs(total_charge_soc[2]) < this->sc_thr_)? 0.0 : total_charge_soc[2];
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                this->Mi_[iat].z = (std::abs(total_charge_soc[3]) < this->sc_thr_)? 0.0 : total_charge_soc[3];
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:            if (this->ParaV->in_this_processor(i, i))
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                const int ir = this->ParaV->global2local_row(i);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                const int ic = this->ParaV->global2local_col(i);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:    else if (this->nspin_ == 4)
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                if (this->ParaV->in_this_processor(k1, k1))
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ir = this->ParaV->global2local_row(k1);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ic = this->ParaV->global2local_col(k1);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                if (this->ParaV->in_this_processor(k1, k2))
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ir = this->ParaV->global2local_row(k1);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ic = this->ParaV->global2local_col(k2);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                if (this->ParaV->in_this_processor(k2, k1))
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ir = this->ParaV->global2local_row(k2);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ic = this->ParaV->global2local_col(k1);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                if (this->ParaV->in_this_processor(k2, k2))
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ir = this->ParaV->global2local_row(k2);
module_hamilt_lcao/module_deltaspin/cal_mw_helper.cpp:                    const int ic = this->ParaV->global2local_col(k2);
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_input_parameters(sc_thr_in, nsc_in, nsc_min_in, alpha_trial_in, sccut_in, decay_grad_switch_in);
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_atomCounts(ucell.get_atomCounts());
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_orbitalCounts(ucell.get_orbitalCounts());
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_lnchiCounts(ucell.get_lnchiCounts());
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_nspin(nspin_in);
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->bcast_ScData(sc_file, this->get_nat(), this->get_ntype());
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_npol(NPOL);
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_ParaV(ParaV_in);
module_hamilt_lcao/module_deltaspin/init_sc.cpp:    this->set_solver_parameters(kv_in, phsol_in, p_hamilt_in, psi_in, pelec_in, KS_SOLVER_in, LM_in);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:    int ntype = this->get_ntype();
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:    double alpha_trial = this->alpha_trial_;
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:    this->print_header();
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:    for (int i_step = 0; i_step < this->nsc_; i_step++)
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            spin = this->Mi_;
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            where_fill_scalar_else_2d(this->constrain_, 0, zero, this->lambda_, initial_lambda);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            print_2d("initial lambda: ", initial_lambda, this->nspin_);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            print_2d("initial spin: ", spin, this->nspin_);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            print_2d("target spin: ", this->target_mag_, this->nspin_);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            where_fill_scalar_else_2d(this->constrain_, 0, zero, delta_lambda, delta_lambda);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            add_scalar_multiply_2d(initial_lambda, delta_lambda, one, this->lambda_);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            this->cal_mw_from_lambda(i_step);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            new_spin = this->Mi_;
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            bool GradLessThanBound = this->check_gradient_decay(new_spin, spin, delta_lambda, dnu_last_step);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            if (i_step >= this->nsc_min_ && GradLessThanBound)
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:                add_scalar_multiply_2d(initial_lambda, dnu_last_step, one, this->lambda_);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:                this->print_termination();
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        subtract_2d(spin, this->target_mag_, delta_spin);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        where_fill_scalar_2d(this->constrain_, 0, zero, delta_spin);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        if (this->check_rms_stop(outer_step, i_step, rms_error, duration, inner_loop_duration))
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:            add_scalar_multiply_2d(initial_lambda, dnu_last_step, 1.0, this->lambda_);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        this->check_restriction(search, alpha_trial);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        where_fill_scalar_else_2d(this->constrain_, 0, zero, delta_lambda, delta_lambda);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        add_scalar_multiply_2d(initial_lambda, delta_lambda, one, this->lambda_);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        this->cal_mw_from_lambda(i_step);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        spin_plus = this->Mi_;
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        alpha_opt = this->cal_alpha_opt(spin, spin_plus, alpha_trial);
module_hamilt_lcao/module_deltaspin/lambda_loop.cpp:        this->check_restriction(search, alpha_opt);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    print_2d("after-optimization spin (uB): (print in the inner loop): ", this->Mi_, this->nspin_);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    print_2d("after-optimization lambda (Ry/uB): (print in the inner loop): ", this->lambda_, this->nspin_);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    if (rms_error < this->sc_thr_ || i_step == this->nsc_ - 1)
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:        if (rms_error < this->sc_thr_)
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:            std::cout << "Meet convergence criterion ( < " << this->sc_thr_ << " ), exit.";
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:        else if (i_step == this->nsc_ - 1)
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:            std::cout << "Reach maximum number of steps ( " << this->nsc_ << " ), exit.";
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:        this->print_termination();
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    std::cout << "Covergence criterion for the iteration: " << this->sc_thr_ << std::endl;
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    if (this->restrict_current_ > 0 && boundary > this->restrict_current_)
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:        alpha_trial = copysign(1.0, alpha_trial) * this->restrict_current_ / maxval_abs_2d(search);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    where_fill_scalar_else_2d(this->constrain_, 0, zero, this->target_mag_, target_spin_mask);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    where_fill_scalar_else_2d(this->constrain_, 0, zero, spin, spin_mask);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    where_fill_scalar_else_2d(this->constrain_, 0, zero, spin_plus, spin_plus_mask);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    int ntype = this->get_ntype();
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    where_fill_scalar_2d(this->constrain_, 0, zero, spin_change);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    where_fill_scalar_2d(this->constrain_, 0, one, nu_change);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:    for (const auto& sc_elem: this->get_atomCounts())
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:        print_2d("diagonal gradient: ", spin_nu_gradient_diag, this->nspin_);
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:        if (this->decay_grad_[it] > 0 && std::abs(max_gradient[it]) < this->decay_grad_[it])
module_hamilt_lcao/module_deltaspin/lambda_loop_helper.cpp:            std::cout << "Reach limitation of current step ( maximum gradient < " << this->decay_grad_[it]/ModuleBase::Ry_to_eV // uB^2/Ry to uB^2/eV
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:    return this->ScData;
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:    this->ScData.clear();
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:            this->ScData[current_itype].push_back(element_data);
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:            this->ScDecayGrad[current_itype] = current_decay_grad;
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->Set_ScData_From_Json(sc_file);
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_sc_lambda();
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_target_mag();
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_constrain();
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_decay_grad();
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        sc_lambda = const_cast<ModuleBase::Vector3<double>*>(this->get_sc_lambda().data());
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        target_mag = const_cast<ModuleBase::Vector3<double>*>(this->get_target_mag().data());
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        constrain = const_cast<ModuleBase::Vector3<int>*>(this->get_constrain().data());
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        decay_grad = const_cast<double*>(this->get_decay_grad().data());
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_sc_lambda(sc_lambda, nat);
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_target_mag(target_mag, nat);
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_constrain(constrain, nat);
module_hamilt_lcao/module_deltaspin/sc_parse_json.cpp:        this->set_decay_grad(decay_grad, ntype);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->escon_ = 0.0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->escon_ += this->lambda_[iat].x * this->Mi_[iat].x;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->escon_ += this->lambda_[iat].y * this->Mi_[iat].y;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->escon_ += this->lambda_[iat].z * this->Mi_[iat].z;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->escon_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->escon_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->atomCounts.clear();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->atomCounts = atomCounts_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->atomCounts;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->npol_ = npol;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->npol_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->nspin_ = nspin_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->nspin_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (std::map<int, int>::iterator it = this->atomCounts.begin(); it != this->atomCounts.end(); ++it) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->atomCounts.size();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (!this->atomCounts.size())
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (this->get_nat() <= 0)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (std::map<int, int>::iterator it = this->atomCounts.begin(); it != this->atomCounts.end(); ++it) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        if (itype < 0 || itype >= this->get_ntype())
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (itype < 0 || itype >= this->get_ntype())
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (atom_index < 0 || atom_index >= this->atomCounts[itype])
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (std::map<int, int>::iterator it = this->atomCounts.begin(); it != this->atomCounts.end(); ++it) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->orbitalCounts.clear();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->orbitalCounts = orbitalCounts_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->orbitalCounts;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->lnchiCounts.clear();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->lnchiCounts = lnchiCounts_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->lnchiCounts;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (std::map<int, int>::iterator it = this->orbitalCounts.begin(); it != this->orbitalCounts.end(); ++it) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        nw += (it->second)*this->atomCounts[it->first]*this->npol_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (itype < 0 || itype >= this->get_ntype())
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (iat < 0 || iat >= this->get_nat())
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (orbital_index < 0 || orbital_index >= this->orbitalCounts[itype]*this->npol_)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (std::map<int, int>::iterator it = this->orbitalCounts.begin(); it != this->orbitalCounts.end(); ++it) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        iwt += (it->second)*this->atomCounts[it->first]*this->npol_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        iwt += this->orbitalCounts[itype]*this->npol_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->lambda_.resize(nat);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (auto& itype_data : this->ScData) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            int iat = this->get_iat(itype, index);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            this->lambda_[iat] = lambda*this->meV_to_Ry;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->target_mag_.resize(nat, 0.0);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (auto& itype_data : this->ScData) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            int iat = this->get_iat(itype, index);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            this->target_mag_[iat] = mag;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->constrain_.resize(nat);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            this->constrain_[iat].x = 0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            this->constrain_[iat].y = 0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            this->constrain_[iat].z = 0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    for (auto& itype_data : this->ScData) {
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            int iat = this->get_iat(itype, index);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            this->constrain_[iat] = constr;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->lambda_.resize(nat);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->lambda_[iat] = lambda_in[iat];
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->target_mag_.resize(nat);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->target_mag_[iat] = target_mag_in[iat];
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->constrain_.resize(nat);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->constrain_[iat] = constrain_in[iat];
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->lambda_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->target_mag_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->constrain_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->Mi_.resize(nat);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->Mi_[iat].x = 0.0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->Mi_[iat].y = 0.0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->Mi_[iat].z = 0.0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->ScDecayGrad[itype];
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int ntype = this->get_ntype();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->decay_grad_.resize(ntype);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->decay_grad_[itype] = 0.0;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    if (this->decay_grad_switch_)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        for (auto& itype_data: this->ScDecayGrad)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            this->decay_grad_[itype] = itype_data.second * ModuleBase::Ry_to_eV;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->decay_grad_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int ntype = this->get_ntype();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->decay_grad_.resize(ntype);
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        this->decay_grad_[itype] = decay_grad_in[itype];
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->sc_thr_ = sc_thr_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->nsc_ = nsc_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->nsc_min_ = nsc_min_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->alpha_trial_ = alpha_trial_in / ModuleBase::Ry_to_eV;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->restrict_current_ = sccut_in / ModuleBase::Ry_to_eV;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->decay_grad_switch_ = decay_grad_switch_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->sc_thr_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->nsc_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->nsc_min_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->alpha_trial_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->restrict_current_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->decay_grad_switch_ = decay_grad_switch_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    return this->decay_grad_switch_;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->kv_ = kv_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->phsol = phsol_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->p_hamilt = p_hamilt_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->psi = psi_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->pelec = pelec_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->KS_SOLVER = KS_SOLVER_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->LM = LM_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->ParaV = ParaV_in;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nloc = this->ParaV->nloc;
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:            else if (this->nspin_ ==4)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    this->check_atomCounts();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:    int nat = this->get_nat();
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        else if (this->nspin_ ==4)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        if (this->nspin_ == 2)
module_hamilt_lcao/module_deltaspin/spin_constrain.cpp:        else if (this->nspin_ ==4)
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:    this->sc.set_orbitalCounts(orbitalCounts);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:    this->sc.set_decay_grad_switch(true);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:    this->sc.bcast_ScData(sc_file, this->sc.get_nat(), this->sc.get_ntype());
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:    for (int iat = 0; iat < this->sc.get_nat(); iat++)
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:            EXPECT_NEAR(this->sc.get_sc_lambda().data()[iat].x, 0.1 * 7.349864435130999e-05, 1e-12);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:            EXPECT_NEAR(this->sc.get_sc_lambda().data()[iat].y, 0.1 * 7.349864435130999e-05, 1e-12);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:            EXPECT_NEAR(this->sc.get_sc_lambda().data()[iat].z, 0.2 * 7.349864435130999e-05, 1e-12);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:            EXPECT_DOUBLE_EQ(this->sc.get_target_mag().data()[iat].x, 0.0);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:            EXPECT_DOUBLE_EQ(this->sc.get_target_mag().data()[iat].y, 1.5);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:            EXPECT_DOUBLE_EQ(this->sc.get_target_mag().data()[iat].z, 0.0);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_decay_grad().data()[0], 0.0);
module_hamilt_lcao/module_deltaspin/test/bcast_scdata_test.cpp:    EXPECT_NEAR(this->sc.get_decay_grad().data()[1], 0.9 * 13.605698, 1e-12);
module_hamilt_lcao/module_deltaspin/test/cal_h_lambda_test.cpp:    // h_lambda = -Sloc2[icc] * this->lambda_[iat2][2]
module_hamilt_lcao/module_deltaspin/test/cal_h_lambda_test.cpp:    // h_lambda = -Sloc2[icc] * (-this->lambda_[iat2][2])
module_hamilt_lcao/module_deltaspin/test/cal_h_lambda_test.cpp:    // h_lambda = -Sloc2[icc] * this->lambda_[iat2][2]
module_hamilt_lcao/module_deltaspin/test/cal_h_lambda_test.cpp:    // h_lambda = -Sloc2[icc] * (-this->lambda_[iat2][2])
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    this->tot_magnetization = 0.0;
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    this->abs_magnetization = 0.0;
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    this->start_magnetization = nullptr;
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    delete[] this->start_magnetization;
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    this->sc.init_sc(sc_thr,
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:                     *(this->ucell),
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    EXPECT_EQ(this->sc.get_nat(), 6);
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    EXPECT_EQ(this->sc.get_ntype(), 2);
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    EXPECT_EQ(this->sc.get_npol(), 2);
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    EXPECT_EQ(this->sc.get_nsc(), 100);
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    std::map<int, int> atomCounts = this->sc.get_atomCounts();
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    std::map<int, int> orbitalCounts = this->sc.get_orbitalCounts();
module_hamilt_lcao/module_deltaspin/test/init_sc_test.cpp:    std::map<int, std::map<int, int>> LnchiCounts = this->sc.get_lnchiCounts();
module_hamilt_lcao/module_deltaspin/test/lambda_loop_helper_test.cpp:    this->sc.set_input_parameters(sc_thr, nsc, nsc_min, alpha_trial, sccut, decay_grad_switch);
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    this->sc.Set_ScData_From_Json("./support/sc_f1.json");
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    EXPECT_EQ(this->sc.get_ScData().size(), 2);
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    for (const auto& sc_elem: this->sc.get_ScData())
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    this->sc.Set_ScData_From_Json("./support/sc_f2.json");
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    EXPECT_EQ(this->sc.get_ScData().size(), 1);
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    for (const auto& sc_elem: this->sc.get_ScData())
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_decay_grad(1), 0.9);
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    this->sc.Set_ScData_From_Json("./support/sc_f3.json");
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    EXPECT_EQ(this->sc.get_ScData().size(), 1);
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    for (const auto& sc_elem: this->sc.get_ScData())
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_decay_grad(1), 0.0);
module_hamilt_lcao/module_deltaspin/test/parse_json_test.cpp:    EXPECT_EXIT(this->sc.Set_ScData_From_Json("./support/sc_f4.json"), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:		this->ntype = this->elements.size();
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.setup(this->latname, this->ntype, this->lmaxmax, this->init_vel, this->fixed_axes);
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:            ucell.atom_label[it] = this->elements[it];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:            ucell.atom_mass[it] = this->atomic_mass[it];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:            ucell.pseudo_fn[it] = this->pp_files[it];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:            ucell.pseudo_type[it] = this->pp_types[it];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:            ucell.orbital_fn[it] = this->orb_files[it];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.lat0 = this->lat0;
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e11 = this->latvec[0];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e12 = this->latvec[1];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e13 = this->latvec[2];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e21 = this->latvec[3];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e22 = this->latvec[4];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e23 = this->latvec[5];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e31 = this->latvec[6];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e32 = this->latvec[7];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.latvec.e33 = this->latvec[8];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.Coordinate = this->coor_type;
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        this->atomic_index = 0;
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:            ucell.atoms[it].label = this->elements[it];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:            ucell.atoms[it].na = this->natom[it];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].x = this->coordinates[this->atomic_index * 3 + 0];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].y = this->coordinates[this->atomic_index * 3 + 1];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].z = this->coordinates[this->atomic_index * 3 + 2];
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:                ++(this->atomic_index);
module_hamilt_lcao/module_deltaspin/test/prepare_unitcell.h:        ucell.nat = this->natom.sum();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.check_atomCounts(), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.check_atomCounts(), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts1);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.check_atomCounts(), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts2);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.check_atomCounts(), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    std::map<int, int> atomCounts2 = this->sc.get_atomCounts();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    int nat = this->sc.get_nat();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_iat(1, 4), 9); // atom_index starts from 0
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.get_iat(3, 0);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.get_iat(0, 5);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_orbitalCounts(orbitalCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    std::map<int, int> orbitalCounts2 = this->sc.get_orbitalCounts();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_nw(), 25);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_npol(2);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_npol(), 2);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_nw(), 50); // npol = 2
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_npol(1);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_npol(), 1);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_iwt(1, 1, 2), 17);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_npol(2);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_iwt(1, 1, 2), 32); // npol = 2
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.get_iwt(3, 0, 0);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.get_iwt(0, 3, 0);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.get_iwt(0, 0, 10);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.Set_ScData_From_Json("./support/sc_f1.json");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    int nat = this->sc.get_nat();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_sc_lambda();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_target_mag();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_constrain();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    std::vector<ModuleBase::Vector3<double>> sc_lambda = this->sc.get_sc_lambda();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    std::vector<ModuleBase::Vector3<double>> target_mag = this->sc.get_target_mag();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    std::vector<ModuleBase::Vector3<int>> constrain = this->sc.get_constrain();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_sc_lambda(sc_lambda.data(), nat);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_target_mag(target_mag.data(), nat);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_constrain(constrain.data(), nat);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(sc_lambda.size(), this->sc.get_nat());
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    for (const auto& sc_elem: this->sc.get_ScData())
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:            int iat = this->sc.get_iat(itype, index);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:            EXPECT_DOUBLE_EQ(sc_data.lambda[0] * this->sc.meV_to_Ry, sc_lambda[iat].x);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:            EXPECT_DOUBLE_EQ(sc_data.lambda[1] * this->sc.meV_to_Ry, sc_lambda[iat].y);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:            EXPECT_DOUBLE_EQ(sc_data.lambda[2] * this->sc.meV_to_Ry, sc_lambda[iat].z);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    for (int iat = 0; iat < this->sc.get_nat(); iat++)
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.set_sc_lambda(sc_lambda.data(), 100);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.set_target_mag(target_mag.data(), 100);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.set_constrain(constrain.data(), 100);, ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.zero_Mi();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.Set_ScData_From_Json("./support/sc_f1.json");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    int nat = this->sc.get_nat();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_sc_lambda();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    double escon = this->sc.cal_escon();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    double escon1 = this->sc.get_escon();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_nspin(4);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    int nspin = this->sc.get_nspin();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.set_nspin(1), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_orbitalCounts(orbitalCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.Set_ScData_From_Json("./support/sc_f2.json");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_decay_grad(1), 0.9);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_decay_grad_switch(true);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_decay_grad();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_decay_grad().data()[1], 0.9 * 13.605698);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    int ntype = this->sc.get_ntype();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    std::vector<double> decay_grad = this->sc.get_decay_grad();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_decay_grad(decay_grad.data(), ntype);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_decay_grad().data()[0], 0.0);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_decay_grad().data()[1], 0.9 * 13.605698);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.set_decay_grad(decay_grad.data(), 100), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_atomCounts(atomCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_orbitalCounts(orbitalCounts);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.Set_ScData_From_Json("./support/sc_f2.json");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_target_mag();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    std::vector<ModuleBase::Vector3<double>> target_mag = this->sc.get_target_mag();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    for (const auto& sc_elem: this->sc.get_ScData())
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:            int iat = this->sc.get_iat(itype, index);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    for (int iat = 0; iat < this->sc.get_nat(); iat++)
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_input_parameters(sc_thr, nsc, nsc_min, alpha_trial, sccut, decay_grad_switch);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_sc_thr(), sc_thr);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_nsc(), nsc);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_nsc_min(), nsc_min);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_alpha_trial(), alpha_trial / 13.605698);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_DOUBLE_EQ(this->sc.get_sccut(), sccut / 13.605698);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_decay_grad_switch(), decay_grad_switch);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_nspin(4);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_solver_parameters(kv, nullptr, nullptr, nullptr, nullptr, "genelpa", nullptr);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.get_nspin(), 4);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.phsol, nullptr);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.p_hamilt, nullptr);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.psi, nullptr);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.pelec, nullptr);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.KS_SOLVER, "genelpa");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.LM, nullptr);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EXIT(this->sc.set_ParaV(&paraV), ::testing::ExitedWithCode(0), "");
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_ParaV(&paraV);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    EXPECT_EQ(this->sc.ParaV->nloc, nrow * ncol);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.zero_Mi();
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.print_Mi(true);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.set_nspin(2);
module_hamilt_lcao/module_deltaspin/test/spin_constrain_test.cpp:    this->sc.print_Mi(true);
module_hamilt_lcao/module_dftu/dftu.cpp:    this->LM = &lm;
module_hamilt_lcao/module_dftu/dftu.cpp:    this->EU = 0.0;
module_hamilt_lcao/module_dftu/dftu.cpp:    this->locale.resize(cell.nat);
module_hamilt_lcao/module_dftu/dftu.cpp:    this->locale_save.resize(cell.nat);
module_hamilt_lcao/module_dftu/dftu.cpp:    this->iatlnmipol2iwt.resize(cell.nat);
module_hamilt_lcao/module_dftu/dftu.cpp:            this->iatlnmipol2iwt[iat].resize(cell.atoms[it].nwl + 1);
module_hamilt_lcao/module_dftu/dftu.cpp:                this->iatlnmipol2iwt[iat][L].resize(cell.atoms[it].l_nchi[L]);
module_hamilt_lcao/module_dftu/dftu.cpp:                    this->iatlnmipol2iwt[iat][L][n].resize(2 * L + 1);
module_hamilt_lcao/module_dftu/dftu.cpp:                        this->iatlnmipol2iwt[iat][L][n][m].resize(npol);
module_hamilt_lcao/module_dftu/dftu.cpp:                this->iatlnmipol2iwt[iat][l][n][m][ipol] = iwt;
module_hamilt_lcao/module_dftu/dftu.cpp:        this->Fk.resize(cell.ntype);
module_hamilt_lcao/module_dftu/dftu.cpp:        this->U_Yukawa.resize(cell.ntype);
module_hamilt_lcao/module_dftu/dftu.cpp:        this->J_Yukawa.resize(cell.ntype);
module_hamilt_lcao/module_dftu/dftu.cpp:            this->Fk[it].resize(NL);
module_hamilt_lcao/module_dftu/dftu.cpp:            this->U_Yukawa[it].resize(NL);
module_hamilt_lcao/module_dftu/dftu.cpp:            this->J_Yukawa[it].resize(NL);
module_hamilt_lcao/module_dftu/dftu.cpp:                this->Fk[it][l].resize(N);
module_hamilt_lcao/module_dftu/dftu.cpp:                    this->Fk[it][l][n].resize(l + 1, 0.0);
module_hamilt_lcao/module_dftu/dftu.cpp:                this->U_Yukawa[it][l].resize(N, 0.0);
module_hamilt_lcao/module_dftu/dftu.cpp:                this->J_Yukawa[it][l].resize(N, 0.0);
module_hamilt_lcao/module_dftu/dftu.cpp:        this->read_occup_m(sst.str());
module_hamilt_lcao/module_dftu/dftu.cpp:        this->local_occup_bcast();
module_hamilt_lcao/module_dftu/dftu.cpp:        this->copy_locale();
module_hamilt_lcao/module_dftu/dftu.cpp:            this->read_occup_m(sst.str());
module_hamilt_lcao/module_dftu/dftu.cpp:            this->local_occup_bcast();
module_hamilt_lcao/module_dftu/dftu.cpp:            this->zero_locale();
module_hamilt_lcao/module_dftu/dftu.cpp:    this->EU = 0.0;
module_hamilt_lcao/module_dftu/dftu.cpp:                                nm_trace += this->locale[iat][l][n][spin](m0, m0);
module_hamilt_lcao/module_dftu/dftu.cpp:                                    nm2_trace += this->locale[iat][l][n][spin](m0, m1)
module_hamilt_lcao/module_dftu/dftu.cpp:                                                 * this->locale[iat][l][n][spin](m1, m0);
module_hamilt_lcao/module_dftu/dftu.cpp:                                this->EU += 0.5 * (this->U_Yukawa[T][l][n] - this->J_Yukawa[T][l][n])
module_hamilt_lcao/module_dftu/dftu.cpp:                                this->EU += 0.5 * this->U[T] * (nm_trace - nm2_trace);
module_hamilt_lcao/module_dftu/dftu.cpp:                                nm_trace += this->locale[iat][l][n][0](m0_all, m0_all);
module_hamilt_lcao/module_dftu/dftu.cpp:                                        nm2_trace += this->locale[iat][l][n][0](m0_all, m1_all)
module_hamilt_lcao/module_dftu/dftu.cpp:                                                     * this->locale[iat][l][n][0](m1_all, m0_all);
module_hamilt_lcao/module_dftu/dftu.cpp:                            this->EU
module_hamilt_lcao/module_dftu/dftu.cpp:                                += 0.5 * (this->U_Yukawa[T][l][n] - this->J_Yukawa[T][l][n]) * (nm_trace - nm2_trace);
module_hamilt_lcao/module_dftu/dftu.cpp:                            this->EU += 0.5 * this->U[T] * (nm_trace - nm2_trace);
module_hamilt_lcao/module_dftu/dftu.cpp:                                            EU_dc += VU * this->locale[iat][l][n][is](m1_all, m2_all);
module_hamilt_lcao/module_dftu/dftu.cpp:                                        EU_dc += VU * this->locale[iat][l][n][0](m1_all, m2_all);
module_hamilt_lcao/module_dftu/dftu.cpp:    this->EU -= EU_dc;
module_hamilt_lcao/module_dftu/dftu.cpp:    if(this->uramping < 0.01) return;
module_hamilt_lcao/module_dftu/dftu.cpp:    for(int i = 0; i < this->U0.size(); i++)
module_hamilt_lcao/module_dftu/dftu.cpp:        if (this->U[i] + this->uramping < this->U0[i] ) 
module_hamilt_lcao/module_dftu/dftu.cpp:            this->U[i] += this->uramping;
module_hamilt_lcao/module_dftu/dftu.cpp:            this->U[i] = this->U0[i];
module_hamilt_lcao/module_dftu/dftu.cpp:    for(int i = 0; i < this->U0.size(); i++)
module_hamilt_lcao/module_dftu/dftu.cpp:        if (this->U[i] != this->U0[i]) 
module_hamilt_lcao/module_dftu/dftu.cpp:    this->dm_in_dftu_cd = dmr;
module_hamilt_lcao/module_dftu/dftu.cpp:    this->dm_in_dftu_d = dmr;
module_hamilt_lcao/module_dftu/dftu.cpp:    if(this->dm_in_dftu_d != nullptr)
module_hamilt_lcao/module_dftu/dftu.cpp:        return this->dm_in_dftu_d->get_DMR_pointer(ispin+1);
module_hamilt_lcao/module_dftu/dftu.cpp:    else if(this->dm_in_dftu_cd != nullptr)
module_hamilt_lcao/module_dftu/dftu.cpp:        return this->dm_in_dftu_cd->get_DMR_pointer(ispin+1);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    ModuleBase::GlobalFunc::ZEROS(dSR_gamma, this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    if      (dim1 == 0) dS_ptr = this->LM->DSloc_x;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    else if (dim1 == 1) dS_ptr = this->LM->DSloc_y;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    else if (dim1 == 2) dS_ptr = this->LM->DSloc_z;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                        const int mu = this->LM->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                            const int nu = this->LM->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                            dSR_gamma[nu * this->LM->ParaV->nrow + mu] += dS_ptr[nnr] * this->LM->DH_r[nnr * 3 + dim2];
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    ModuleBase::GlobalFunc::ZEROS(mat_k, this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    if      (dim1 == 1 || dim1 == 4) mat_ptr = this->LM->DSloc_Rx;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    else if (dim1 == 2 || dim1 == 5) mat_ptr = this->LM->DSloc_Ry;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:    else if (dim1 == 3 || dim1 == 6) mat_ptr = this->LM->DSloc_Rz;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                        const int mu = this->LM->ParaV->global2local_row(iw1_all);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                            const int nu = this->LM->ParaV->global2local_col(iw2_all);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                                iic = mu + nu * this->LM->ParaV->nrow;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                                iic = mu * this->LM->ParaV->ncol + nu;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:                                mat_k[iic] += mat_ptr[nnr] * this->LM->DH_r[nnr * 3 + dim2] * kphase;
module_hamilt_lcao/module_dftu/dftu_folding.cpp:        dynamic_cast<hamilt::HamiltLCAO<double, double>*>(p_ham)->updateSk(ik, this->LM, hk_type);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:            dynamic_cast<hamilt::HamiltLCAO<std::complex<double>, double>*>(p_ham)->updateSk(ik, this->LM, hk_type);
module_hamilt_lcao/module_dftu/dftu_folding.cpp:            dynamic_cast<hamilt::HamiltLCAO<std::complex<double>, std::complex<double>>*>(p_ham)->updateSk(ik, this->LM, hk_type);
module_hamilt_lcao/module_dftu/dftu_force.cpp:    this->LM = &lm;
module_hamilt_lcao/module_dftu/dftu_force.cpp:        std::vector<double> rho_VU(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            double* VU = new double[this->LM->ParaV->nloc];
module_hamilt_lcao/module_dftu/dftu_force.cpp:            this->cal_VU_pot_mat_real(spin, false, VU);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    dmk[spin].data(), &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    VU, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    &rho_VU[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            if (GlobalV::CAL_FORCE)  this->cal_force_gamma(&rho_VU[0], force_dftu);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            if (GlobalV::CAL_STRESS) this->cal_stress_gamma(&rho_VU[0], stress_dftu);
module_hamilt_lcao/module_dftu/dftu_force.cpp:        std::vector<std::complex<double>> rho_VU(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            std::complex<double>* VU = new std::complex<double>[this->LM->ParaV->nloc];
module_hamilt_lcao/module_dftu/dftu_force.cpp:            this->cal_VU_pot_mat_complex(spin, false, VU);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    dmk[ik].data(), &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    VU, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    &rho_VU[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:    std::vector<std::complex<double>> dm_VU_dSm(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:    std::vector<std::complex<double>> dSm_k(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:        this->folding_matrix_k(ik, dim + 1, 0, &dSm_k[0], kvec_d);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                &dSm_k[0], &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:                rho_VU, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:                &dm_VU_dSm[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:        for (int ir = 0; ir < this->LM->ParaV->nrow; ir++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:            const int iwt1 = this->LM->ParaV->local2global_row(ir);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            for (int ic = 0; ic < this->LM->ParaV->ncol; ic++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:                const int iwt2 = this->LM->ParaV->local2global_col(ic);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                const int irc = ic * this->LM->ParaV->nrow + ir;
module_hamilt_lcao/module_dftu/dftu_force.cpp:                &dSm_k[0], &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:                rho_VU, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:                &dm_VU_dSm[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                const int iwt = this->iatlnmipol2iwt[iat][l][n][m][ipol];
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                const int mu = this->LM->ParaV->global2local_row(iwt);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                const int nu = this->LM->ParaV->global2local_col(iwt);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                force_dftu(iat, dim) += dm_VU_dSm[nu * this->LM->ParaV->nrow + mu].real();
module_hamilt_lcao/module_dftu/dftu_force.cpp:    std::vector<std::complex<double>> dm_VU_sover(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:    std::vector<std::complex<double>> dSR_k(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            this->folding_matrix_k(ik, dim1 + 4, dim2, &dSR_k[0], kvec_d);
module_hamilt_lcao/module_dftu/dftu_force.cpp:					rho_VU, &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:					&dSR_k[0], &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:					&dm_VU_sover[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            for (int ir = 0; ir < this->LM->ParaV->nrow; ir++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:                const int iwt1 = this->LM->ParaV->local2global_row(ir);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                for (int ic = 0; ic < this->LM->ParaV->ncol; ic++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    const int iwt2 = this->LM->ParaV->local2global_col(ic);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    const int irc = ic * this->LM->ParaV->nrow + ir;
module_hamilt_lcao/module_dftu/dftu_force.cpp:    std::vector<double> dm_VU_dSm(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:        if (dim == 0)      tmp_ptr = this->LM->DSloc_x;
module_hamilt_lcao/module_dftu/dftu_force.cpp:        else if (dim == 1) tmp_ptr = this->LM->DSloc_y;
module_hamilt_lcao/module_dftu/dftu_force.cpp:        else if (dim == 2) tmp_ptr = this->LM->DSloc_z;
module_hamilt_lcao/module_dftu/dftu_force.cpp:				tmp_ptr, &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:				rho_VU, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:				&dm_VU_dSm[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:        for (int ir = 0; ir < this->LM->ParaV->nrow; ir++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:            const int iwt1 = this->LM->ParaV->local2global_row(ir);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            for (int ic = 0; ic < this->LM->ParaV->ncol; ic++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:                const int iwt2 = this->LM->ParaV->local2global_col(ic);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                const int irc = ic * this->LM->ParaV->nrow + ir;
module_hamilt_lcao/module_dftu/dftu_force.cpp:				tmp_ptr, &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:				rho_VU, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:				&dm_VU_dSm[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                const int iwt = this->iatlnmipol2iwt[iat][l][n][m][ipol];
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                const int mu = this->LM->ParaV->global2local_row(iwt);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                const int nu = this->LM->ParaV->global2local_col(iwt);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                                force_dftu(iat, dim) += dm_VU_dSm[nu * this->LM->ParaV->nrow + mu];
module_hamilt_lcao/module_dftu/dftu_force.cpp:    std::vector<double> dSR_gamma(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:    std::vector<double> dm_VU_sover(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            this->fold_dSR_gamma(dim1, dim2, &dSR_gamma[0]);
module_hamilt_lcao/module_dftu/dftu_force.cpp:					rho_VU, &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_force.cpp:					&dSR_gamma[0], &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_force.cpp:					&dm_VU_sover[0], &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_force.cpp:            for (int ir = 0; ir < this->LM->ParaV->nrow; ir++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:                const int iwt1 = this->LM->ParaV->local2global_row(ir);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                for (int ic = 0; ic < this->LM->ParaV->ncol; ic++)
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    const int iwt2 = this->LM->ParaV->local2global_col(ic);
module_hamilt_lcao/module_dftu/dftu_force.cpp:                    const int irc = ic * this->LM->ParaV->nrow + ir;
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    if (!this->initialed_locale)
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    ModuleBase::GlobalFunc::ZEROS(eff_pot, this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    std::vector<std::complex<double>> VU(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    this->cal_VU_pot_mat_complex(spin, true, &VU[0]);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            ModuleBase::GlobalFunc::VECTOR_TO_PTR(VU), &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            this->LM->Sloc2.data(), &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            eff_pot, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    for (int irc = 0; irc < this->LM->ParaV->nloc; irc++)
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            &VU[0], &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            eff_pot, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    if (!this->initialed_locale)
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    ModuleBase::GlobalFunc::ZEROS(eff_pot, this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    std::vector<double> VU(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    this->cal_VU_pot_mat_real(spin, 1, &VU[0]);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            ModuleBase::GlobalFunc::VECTOR_TO_PTR(VU), &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            this->LM->Sloc.data(), &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            eff_pot, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    for (int irc = 0; irc < this->LM->ParaV->nloc; irc++)
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            &VU[0], &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            eff_pot, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    std::vector<double> VU(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    this->cal_VU_pot_mat_real(ispin, 1, &VU[0]);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            ModuleBase::GlobalFunc::VECTOR_TO_PTR(VU), &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            SR, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            HR, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            SR, &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            ModuleBase::GlobalFunc::VECTOR_TO_PTR(VU), &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            HR, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    std::vector<std::complex<double>> VU(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:    this->cal_VU_pot_mat_complex(ispin, 1, &VU[0]);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            ModuleBase::GlobalFunc::VECTOR_TO_PTR(VU), &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            SR, &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            HR, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            SR, &one_int, &one_int, this->LM->ParaV->desc, 
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            ModuleBase::GlobalFunc::VECTOR_TO_PTR(VU), &one_int, &one_int, this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_hamilt.cpp:            HR, &one_int, &one_int, this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_io.cpp:                                         << "    U=" << this->U[T] * ModuleBase::Ry_to_eV << "eV" << std::endl;
module_hamilt_lcao/module_dftu/dftu_io.cpp:                        double Ueff = (this->U_Yukawa[T][L][n] - this->J_Yukawa[T][L][n]) * ModuleBase::Ry_to_eV;
module_hamilt_lcao/module_dftu/dftu_io.cpp:                                             << "    U=" << this->U_Yukawa[T][L][n] * ModuleBase::Ry_to_eV << "eV    "
module_hamilt_lcao/module_dftu/dftu_io.cpp:                                             << "J=" << this->J_Yukawa[T][L][n] * ModuleBase::Ry_to_eV << "eV"
module_hamilt_lcao/module_dftu/dftu_io.cpp:    this->write_occup_m(GlobalV::ofs_running, 1);
module_hamilt_lcao/module_dftu/dftu_io.cpp:    this->write_occup_m(ofdftu);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    this->copy_locale();
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    this->zero_locale();
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    std::vector<std::complex<double>> srho(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:        this->folding_matrix_k_new(ik, p_ham);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:        std::complex<double>* s_k_pointer = this->LM->Sloc2.data();
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                const int iwt0 = this->iatlnmipol2iwt[iat][l][n][m0][ipol0];
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                const int mu = this->LM->ParaV->global2local_row(iwt0);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                const int mu_prime = this->LM->ParaV->global2local_col(iwt0);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int iwt1 = this->iatlnmipol2iwt[iat][l][n][m1][ipol1];
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int nu = this->LM->ParaV->global2local_col(iwt1);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int nu_prime = this->LM->ParaV->global2local_row(iwt1);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int irc = nu * this->LM->ParaV->nrow + mu;
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int irc_prime = mu_prime * this->LM->ParaV->nrow + nu_prime;
module_hamilt_lcao/module_dftu/dftu_occup.cpp:        this->mix_locale(mixing_beta);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    this->initialed_locale = true;
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    this->copy_locale();
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    this->zero_locale();
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    std::vector<double> srho(this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:        double* s_gamma_pointer = this->LM->Sloc.data();
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                this->LM->ParaV->desc,
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                this->LM->ParaV->desc);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                const int iwt0 = this->iatlnmipol2iwt[iat][l][n][m0][ipol0];
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                const int mu = this->LM->ParaV->global2local_row(iwt0);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                const int mu_prime = this->LM->ParaV->global2local_col(iwt0);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int iwt1 = this->iatlnmipol2iwt[iat][l][n][m1][ipol1];
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int nu = this->LM->ParaV->global2local_col(iwt1);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int nu_prime = this->LM->ParaV->global2local_row(iwt1);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int irc = nu * this->LM->ParaV->nrow + mu;
module_hamilt_lcao/module_dftu/dftu_occup.cpp:                                        const int irc_prime = mu_prime * this->LM->ParaV->nrow + nu_prime;
module_hamilt_lcao/module_dftu/dftu_occup.cpp:        this->mix_locale(mixing_beta);
module_hamilt_lcao/module_dftu/dftu_occup.cpp:    this->initialed_locale = true;
module_hamilt_lcao/module_dftu/dftu_tools.cpp:    ModuleBase::GlobalFunc::ZEROS(VU, this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                            const int mu = this->LM->ParaV->global2local_row(this->iatlnmipol2iwt[iat][L][n][m1][ipol1]);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                                        = this->LM->ParaV->global2local_col(this->iatlnmipol2iwt[iat][L][n][m2][ipol2]);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                                    VU[nu * this->LM->ParaV->nrow + mu] = std::complex<double>(val, 0.0);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:    ModuleBase::GlobalFunc::ZEROS(VU, this->LM->ParaV->nloc);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                            const int mu = this->LM->ParaV->global2local_row(this->iatlnmipol2iwt[iat][L][n][m1][ipol1]);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                                        = this->LM->ParaV->global2local_col(this->iatlnmipol2iwt[iat][L][n][m2][ipol2]);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                                    VU[nu * this->LM->ParaV->nrow + mu]
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                                        = this->get_onebody_eff_pot(it, iat, L, n, spin, m1_all, m2_all, newlocale);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = (this->U_Yukawa[T][L][N] - this->J_Yukawa[T][L][N])
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                         * (0.5 - this->locale[iat][L][N][spin](m0, m1));
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = -(this->U_Yukawa[T][L][N] - this->J_Yukawa[T][L][N]) * this->locale[iat][L][N][spin](m0, m1);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = (this->U[T]) * (0.5 - this->locale[iat][L][N][spin](m0, m1));
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = -(this->U[T]) * this->locale[iat][L][N][spin](m0, m1);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = (this->U_Yukawa[T][L][N] - this->J_Yukawa[T][L][N])
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                         * (0.5 - this->locale_save[iat][L][N][spin](m0, m1));
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = -(this->U_Yukawa[T][L][N] - this->J_Yukawa[T][L][N])
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                         * this->locale_save[iat][L][N][spin](m0, m1);
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = (this->U[T]) * (0.5 - this->locale_save[iat][L][N][spin](m0, m1));
module_hamilt_lcao/module_dftu/dftu_tools.cpp:                    VU = -(this->U[T]) * this->locale_save[iat][L][N][spin](m0, m1);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:        this->lambda = INPUT.yukawa_lambda;
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:    this->lambda = val2 / val1;
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:    this->lambda /= 1.6;
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                            bslval = this->spherical_Bessel(l, r0, lambda);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                            hnkval = this->spherical_Hankel(l, r1, lambda);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                            bslval = this->spherical_Bessel(l, r1, lambda);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                            hnkval = this->spherical_Hankel(l, r0, lambda);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                        this->Fk[T][L][chi][k] -= (4 * k + 1) * lambda * pow(R_L0, 2) * bslval * hnkval * pow(R_L1, 2)
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:    this->cal_yukawa_lambda(rho, nrxx);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                ModuleBase::GlobalFunc::ZEROS(ModuleBase::GlobalFunc::VECTOR_TO_PTR(this->Fk[it][l][n]), l + 1);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                this->cal_slater_Fk(L, T);
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                        this->U_Yukawa[T][L][n] = this->Fk[T][L][n][0];
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                        this->J_Yukawa[T][L][n] = this->Fk[T][L][n][1] / 5.0;
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                        this->U_Yukawa[T][L][n] = this->Fk[T][L][n][0];
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                        this->J_Yukawa[T][L][n] = (this->Fk[T][L][n][1] + this->Fk[T][L][n][2]) / 14.0;
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                            this->U_Yukawa[T][L][n] = this->Fk[T][L][n][0];
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                        this->J_Yukawa[T][L][n] = (286.0 * this->Fk[T][L][n][1] + 195.0 * this->Fk[T][L][n][2]
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                                                   + 250.0 * this->Fk[T][L][n][3])
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                    this->U_Yukawa[T][L][n] *= 2.0;
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                    this->J_Yukawa[T][L][n] *= 2.0;
module_hamilt_lcao/module_dftu/dftu_yukawa.cpp:                    this->U[T] = this->U_Yukawa[T][L][n] - this->J_Yukawa[T][L][n];
module_hamilt_lcao/module_gint/gint.cpp:    delete this->hRGint;
module_hamilt_lcao/module_gint/gint.cpp:    delete this->hRGintCd;
module_hamilt_lcao/module_gint/gint.cpp:    for (int is = 0; is < this->DMRGint.size(); is++)
module_hamilt_lcao/module_gint/gint.cpp:        delete this->DMRGint[is];
module_hamilt_lcao/module_gint/gint.cpp:    delete this->DMRGint_full;
module_hamilt_lcao/module_gint/gint.cpp:	const int max_size = this->gridt->max_atom;
module_hamilt_lcao/module_gint/gint.cpp:    const int lgd = this->gridt->lgd;
module_hamilt_lcao/module_gint/gint.cpp:    const int nnrg = this->gridt->nnrg;
module_hamilt_lcao/module_gint/gint.cpp:			const int ncyz = this->ny*this->nplane; // mohan add 2012-03-25
module_hamilt_lcao/module_gint/gint.cpp:			const double dv = GlobalC::ucell.omega/this->ncxyz;
module_hamilt_lcao/module_gint/gint.cpp:                    ModuleBase::GlobalFunc::ZEROS(this->pvpR_reduced[inout->ispin], nnrg);
module_hamilt_lcao/module_gint/gint.cpp:				ModuleBase::GlobalFunc::ZEROS(this->pvdpRx_reduced[inout->ispin], nnrg);
module_hamilt_lcao/module_gint/gint.cpp:				ModuleBase::GlobalFunc::ZEROS(this->pvdpRy_reduced[inout->ispin], nnrg);
module_hamilt_lcao/module_gint/gint.cpp:				ModuleBase::GlobalFunc::ZEROS(this->pvdpRz_reduced[inout->ispin], nnrg);
module_hamilt_lcao/module_gint/gint.cpp:					hRGint_thread = new hamilt::HContainer<double>(*this->hRGint);
module_hamilt_lcao/module_gint/gint.cpp:			for(int grid_index = 0; grid_index < this->nbxx; grid_index++)
module_hamilt_lcao/module_gint/gint.cpp:				const int na_grid = this->gridt->how_many_atoms[ grid_index ];
module_hamilt_lcao/module_gint/gint.cpp:                    int* vindex = Gint_Tools::get_vindex(this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:                        this->nplane, this->gridt->start_ind[grid_index], ncyz);
module_hamilt_lcao/module_gint/gint.cpp:                    this->gint_kernel_rho(na_grid, grid_index, delta_r, vindex, LD_pool, inout);
module_hamilt_lcao/module_gint/gint.cpp:                    int* vindex = Gint_Tools::get_vindex(this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:                        this->nplane, this->gridt->start_ind[grid_index], ncyz);
module_hamilt_lcao/module_gint/gint.cpp:                    this->gint_kernel_tau(na_grid, grid_index, delta_r, vindex, LD_pool, inout);
module_hamilt_lcao/module_gint/gint.cpp:                    double* vldr3 = Gint_Tools::get_vldr3(inout->vl, this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:                        this->nplane, this->gridt->start_ind[grid_index], ncyz, dv);
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_force(na_grid, grid_index, delta_r, vldr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_force(na_grid, grid_index, delta_r, vldr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:                    double* vldr3 = Gint_Tools::get_vldr3(inout->vl, this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:                        this->nplane, this->gridt->start_ind[grid_index], ncyz, dv);
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_vlocal(na_grid, grid_index, delta_r, vldr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_vlocal(na_grid, grid_index, delta_r, vldr3, LD_pool, nullptr);
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_vlocal(na_grid, grid_index, delta_r, vldr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:								this->pvpR_reduced[inout->ispin]);
module_hamilt_lcao/module_gint/gint.cpp:                    double* vldr3 = Gint_Tools::get_vldr3(inout->vl, this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:							this->nplane, this->gridt->start_ind[grid_index], ncyz, dv);
module_hamilt_lcao/module_gint/gint.cpp:					this->gint_kernel_dvlocal(na_grid, grid_index, delta_r, vldr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:					this->gint_kernel_dvlocal(na_grid, grid_index, delta_r, vldr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:							this->pvdpRx_reduced[inout->ispin],
module_hamilt_lcao/module_gint/gint.cpp:                            this->pvdpRy_reduced[inout->ispin],
module_hamilt_lcao/module_gint/gint.cpp:                            this->pvdpRz_reduced[inout->ispin]);
module_hamilt_lcao/module_gint/gint.cpp:                    double* vldr3 = Gint_Tools::get_vldr3(inout->vl, this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:                        this->nplane, this->gridt->start_ind[grid_index], ncyz, dv);
module_hamilt_lcao/module_gint/gint.cpp:                    double* vkdr3 = Gint_Tools::get_vldr3(inout->vofk,this->bxyz,  this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:							this->nplane, this->gridt->start_ind[grid_index], ncyz, dv);
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_vlocal_meta(na_grid, grid_index, delta_r, vldr3, vkdr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_vlocal_meta(na_grid, grid_index, delta_r, vldr3, vkdr3, LD_pool, nullptr);
module_hamilt_lcao/module_gint/gint.cpp:						this->gint_kernel_vlocal_meta(na_grid, grid_index, delta_r, vldr3, vkdr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:								this->pvpR_reduced[inout->ispin]);
module_hamilt_lcao/module_gint/gint.cpp:                    double* vldr3 = Gint_Tools::get_vldr3(inout->vl, this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:                        this->nplane, this->gridt->start_ind[grid_index], ncyz, dv);
module_hamilt_lcao/module_gint/gint.cpp:                    double* vkdr3 = Gint_Tools::get_vldr3(inout->vofk, this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint.cpp:                        this->nplane, this->gridt->start_ind[grid_index], ncyz, dv);
module_hamilt_lcao/module_gint/gint.cpp:					this->gint_kernel_force_meta(na_grid, grid_index, delta_r, vldr3, vkdr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:					this->gint_kernel_force_meta(na_grid, grid_index, delta_r, vldr3, vkdr3, LD_pool,
module_hamilt_lcao/module_gint/gint.cpp:                        BlasConnector::axpy(this->hRGint->get_nnr(), 1.0, hRGint_thread->get_wrapper(), 1, this->hRGint->get_wrapper(), 1);
module_hamilt_lcao/module_gint/gint.cpp:    this->gridt = &gt;
module_hamilt_lcao/module_gint/gint.cpp:    this->nbx = nbx_in;
module_hamilt_lcao/module_gint/gint.cpp:	this->nby = nby_in;
module_hamilt_lcao/module_gint/gint.cpp:	this->nbz = nbz_in;
module_hamilt_lcao/module_gint/gint.cpp:	this->ncxyz = ncxyz_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->nbz_start = nbz_start_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->bx = bx_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->by = by_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->bz = bz_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->bxyz = bxyz_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->nbxx = nbxx_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->ny = ny_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->nplane = nplane_in;
module_hamilt_lcao/module_gint/gint.cpp:    this->startz_current = startz_current_in;
module_hamilt_lcao/module_gint/gint.cpp:	if(this->DMRGint.size() == 0)
module_hamilt_lcao/module_gint/gint.cpp:		this->DMRGint.resize(GlobalV::NSPIN);
module_hamilt_lcao/module_gint/gint.cpp:		if(this->hRGint != nullptr)
module_hamilt_lcao/module_gint/gint.cpp:			delete this->hRGint;
module_hamilt_lcao/module_gint/gint.cpp:		this->hRGint = new hamilt::HContainer<double>(ucell_in.nat);
module_hamilt_lcao/module_gint/gint.cpp:		if(this->hRGintCd != nullptr)
module_hamilt_lcao/module_gint/gint.cpp:			delete this->hRGintCd;
module_hamilt_lcao/module_gint/gint.cpp:		this->hRGintCd = new hamilt::HContainer<std::complex<double>>(ucell_in.nat);
module_hamilt_lcao/module_gint/gint.cpp:			if (this->DMRGint[is] != nullptr)
module_hamilt_lcao/module_gint/gint.cpp:				delete this->DMRGint[is];
module_hamilt_lcao/module_gint/gint.cpp:			this->DMRGint[is] = new hamilt::HContainer<double>(ucell_in.nat);
module_hamilt_lcao/module_gint/gint.cpp:		if(this->DMRGint_full != nullptr)
module_hamilt_lcao/module_gint/gint.cpp:			delete this->DMRGint_full;
module_hamilt_lcao/module_gint/gint.cpp:		this->DMRGint_full = new hamilt::HContainer<double>(ucell_in.nat);
module_hamilt_lcao/module_gint/gint.cpp:		this->hRGint->fix_gamma();
module_hamilt_lcao/module_gint/gint.cpp:			if(this->gridt->in_this_processor[iat1])
module_hamilt_lcao/module_gint/gint.cpp:					if(this->gridt->in_this_processor[iat2])
module_hamilt_lcao/module_gint/gint.cpp:							// insert this atom-pair into this->hRGint
module_hamilt_lcao/module_gint/gint.cpp:								this->hRGint->insert_pair(tmp_atom_pair);
module_hamilt_lcao/module_gint/gint.cpp:								this->hRGintCd->insert_pair(tmp_atom_pair);
module_hamilt_lcao/module_gint/gint.cpp:								for (int is = 0; is < this->DMRGint.size(); is++)
module_hamilt_lcao/module_gint/gint.cpp:									this->DMRGint[is]->insert_pair(tmp_dmR);
module_hamilt_lcao/module_gint/gint.cpp:								this->DMRGint_full->insert_pair(tmp_dmR_full);
module_hamilt_lcao/module_gint/gint.cpp:		this->hRGint->allocate(nullptr, 0);
module_hamilt_lcao/module_gint/gint.cpp:		ModuleBase::Memory::record("Gint::hRGint",this->hRGint->get_memory_size());
module_hamilt_lcao/module_gint/gint.cpp:		for (int is = 0; is < this->DMRGint.size(); is++)
module_hamilt_lcao/module_gint/gint.cpp:			if (this->DMRGint[is] != nullptr)
module_hamilt_lcao/module_gint/gint.cpp:				delete this->DMRGint[is];
module_hamilt_lcao/module_gint/gint.cpp:			this->DMRGint[is] = new hamilt::HContainer<double>(*this->hRGint);
module_hamilt_lcao/module_gint/gint.cpp:		ModuleBase::Memory::record("Gint::DMRGint",this->DMRGint[0]->get_memory_size() * this->DMRGint.size());
module_hamilt_lcao/module_gint/gint.cpp:		this->hRGintCd->allocate(nullptr, 0);
module_hamilt_lcao/module_gint/gint.cpp:		ModuleBase::Memory::record("Gint::hRGintCd",this->hRGintCd->get_memory_size());
module_hamilt_lcao/module_gint/gint.cpp:		for (int is = 0; is < this->DMRGint.size(); is++)
module_hamilt_lcao/module_gint/gint.cpp:			this->DMRGint[is]->allocate(nullptr, 0);
module_hamilt_lcao/module_gint/gint.cpp:		ModuleBase::Memory::record("Gint::DMRGint",this->DMRGint[0]->get_memory_size() * this->DMRGint.size());
module_hamilt_lcao/module_gint/gint.cpp:		this->DMRGint_full->allocate(nullptr, 0);
module_hamilt_lcao/module_gint/gint.cpp:		ModuleBase::Memory::record("Gint::DMRGint_full",this->DMRGint_full->get_memory_size());
module_hamilt_lcao/module_gint/gint.cpp:		for (int is = 0; is < this->DMRGint.size(); is++)
module_hamilt_lcao/module_gint/gint.cpp:			this->DMRGint[is]->set_zero();
module_hamilt_lcao/module_gint/gint.cpp:			this->DMRGint[is]->add(*DM2D[is]);
module_hamilt_lcao/module_gint/gint.cpp:		hamilt::transferParallels2Serials(*DM2D[0], this->DMRGint_full);
module_hamilt_lcao/module_gint/gint.cpp:		this->DMRGint_full = DM2D[0];
module_hamilt_lcao/module_gint/gint.cpp:		for(int iap = 0;iap<this->DMRGint_full->size_atom_pairs();++iap)
module_hamilt_lcao/module_gint/gint.cpp:			auto& ap = this->DMRGint_full->get_atom_pair(iap);
module_hamilt_lcao/module_gint/gint.cpp:					tmp_pointer[is] = this->DMRGint[is]->find_matrix(iat1, iat2, r_index[0], r_index[1], r_index[2])->get_pointer();
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::get_block_info(*this->gridt, this->bxyz, na_grid, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_x(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_y(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_z(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::cal_dpsir_ylm(*this->gridt, this->bxyz, na_grid, grid_index, delta_r,	block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		= Gint_Tools::get_psir_vlbr3(this->bxyz, na_grid, LD_pool, block_index, cal_flag, vldr3, psir_ylm.ptr_2D);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> psir_vlbr3_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(psir_vlbr3_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		//Gint_Tools::mult_psi_DM(*this->gridt, this->bxyz, na_grid, LD_pool, block_iw, block_size, block_index, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:				*this->gridt, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:				this->bxyz, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:				this->DMRGint[is], 
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DMR(*this->gridt, this->bxyz, grid_index, na_grid, block_index, block_size, cal_flag, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:            psir_vlbr3.ptr_2D, psir_vlbr3_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_force(grid_index, na_grid, block_size, block_index,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> dpsir_ylm_xx(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> dpsir_ylm_xy(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> dpsir_ylm_xz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> dpsir_ylm_yy(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> dpsir_ylm_yz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> dpsir_ylm_zz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::cal_dpsirr_ylm(*this->gridt, this->bxyz, na_grid, grid_index, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_stress(na_grid, block_index, psir_vlbr3_DM.ptr_2D, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::get_block_info(*this->gridt, this->bxyz, na_grid, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_x(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_y(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_z(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> ddpsir_ylm_xx(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> ddpsir_ylm_xy(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> ddpsir_ylm_xz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> ddpsir_ylm_yy(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> ddpsir_ylm_yz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> ddpsir_ylm_zz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsir_ylm_x.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsir_ylm_y.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsir_ylm_z.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(ddpsir_ylm_xx.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(ddpsir_ylm_xy.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(ddpsir_ylm_xz.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(ddpsir_ylm_yy.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(ddpsir_ylm_yz.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(ddpsir_ylm_zz.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> psir_ylm1(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_x1(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_y1(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_z1(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(psir_ylm1.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsir_ylm_x1.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsir_ylm_y1.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsir_ylm_z1.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::cal_dpsir_ylm(*this->gridt, this->bxyz, na_grid, grid_index, delta_r,	block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::cal_ddpsir_ylm(*this->gridt, this->bxyz, na_grid, grid_index, delta_r, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		= Gint_Tools::get_psir_vlbr3(this->bxyz, na_grid, LD_pool, block_index, cal_flag, vldr3, psir_ylm.ptr_2D);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		= Gint_Tools::get_psir_vlbr3(this->bxyz, na_grid, LD_pool, block_index, cal_flag, vkdr3, dpsir_ylm_x.ptr_2D);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		= Gint_Tools::get_psir_vlbr3(this->bxyz, na_grid, LD_pool, block_index, cal_flag, vkdr3, dpsir_ylm_y.ptr_2D);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		= Gint_Tools::get_psir_vlbr3(this->bxyz, na_grid, LD_pool, block_index, cal_flag, vkdr3, dpsir_ylm_z.ptr_2D);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> psir_vlbr3_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsirx_v_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsiry_v_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	Gint_Tools::Array_Pool<double> dpsirz_v_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(psir_vlbr3_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsirx_v_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsiry_v_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:	ModuleBase::GlobalFunc::ZEROS(dpsirz_v_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DM_new(*this->gridt, this->bxyz, grid_index, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:            psir_vlbr3.ptr_2D, psir_vlbr3_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DM_new(*this->gridt, this->bxyz, grid_index, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:            dpsir_x_vlbr3.ptr_2D, dpsirx_v_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DM_new(*this->gridt, this->bxyz, grid_index, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:            dpsir_y_vlbr3.ptr_2D, dpsiry_v_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DM_new(*this->gridt, this->bxyz, grid_index, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:            dpsir_z_vlbr3.ptr_2D, dpsirz_v_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DMR(*this->gridt, this->bxyz, grid_index, na_grid, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:            psir_vlbr3.ptr_2D, psir_vlbr3_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DMR(*this->gridt, this->bxyz, grid_index, na_grid, block_index, block_size, cal_flag, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:            dpsir_x_vlbr3.ptr_2D, dpsirx_v_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DMR(*this->gridt, this->bxyz, grid_index, na_grid, block_index, block_size, cal_flag, 
module_hamilt_lcao/module_gint/gint_fvl.cpp:            dpsir_y_vlbr3.ptr_2D, dpsiry_v_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::mult_psi_DMR(*this->gridt, this->bxyz, grid_index, na_grid, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:            dpsir_z_vlbr3.ptr_2D, dpsirz_v_DM.ptr_2D, this->DMRGint[is], false);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_force(grid_index, na_grid, block_size, block_index,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_force(grid_index, na_grid, block_size, block_index,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_force(grid_index, na_grid, block_size, block_index,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_force(grid_index, na_grid, block_size, block_index,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> array_xx(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> array_xy(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> array_xz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> array_yy(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> array_yz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::Array_Pool<double> array_zz(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::cal_dpsirr_ylm(*this->gridt, this->bxyz, na_grid, grid_index, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_stress(na_grid, block_index, psir_vlbr3_DM.ptr_2D,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::cal_dpsirr_ylm(*this->gridt, this->bxyz, na_grid, grid_index, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_stress(na_grid, block_index, dpsirx_v_DM.ptr_2D,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::cal_dpsirr_ylm(*this->gridt, this->bxyz, na_grid, grid_index, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_stress(na_grid, block_index, dpsiry_v_DM.ptr_2D,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		Gint_Tools::cal_dpsirr_ylm(*this->gridt, this->bxyz, na_grid, grid_index, block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_fvl.cpp:		this-> cal_meshball_stress(na_grid, block_index, dpsirz_v_DM.ptr_2D,
module_hamilt_lcao/module_gint/gint_fvl.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_fvl.cpp:	const double*const*const psir_vlbr3_DMR,	    // psir_vlbr3[this->bxyz][LD_pool]
module_hamilt_lcao/module_gint/gint_fvl.cpp:    const double*const*const dpsir_x,	    // psir_vlbr3[this->bxyz][LD_pool]
module_hamilt_lcao/module_gint/gint_fvl.cpp:    const double*const*const dpsir_y,	    // psir_vlbr3[this->bxyz][LD_pool]
module_hamilt_lcao/module_gint/gint_fvl.cpp:    const double*const*const dpsir_z,	    // psir_vlbr3[this->bxyz][LD_pool]
module_hamilt_lcao/module_gint/gint_fvl.cpp:        const int mcell_index=this->gridt->bcell_start[grid_index] + ia1;
module_hamilt_lcao/module_gint/gint_fvl.cpp:        const int iat=this->gridt->which_atom[mcell_index]; // index of atom
module_hamilt_lcao/module_gint/gint_fvl.cpp:        for(int ib=0;ib<this->bxyz;ib++)
module_hamilt_lcao/module_gint/gint_fvl.cpp:    for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_gamma.h:    /// transfer this->hRGint to Veff::hR
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:	const int max_size = this->gridt->max_atom;
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:		const int nbx = this->gridt->nbx;
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:		const int nby = this->gridt->nby;
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:		const int nbz_start = this->gridt->nbzp_start;
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:		const int nbz = this->gridt->nbzp;
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:		const int ncyz = this->ny*this->nplane; // mohan add 2012-03-25
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:        for(int grid_index = 0; grid_index < this->nbxx; grid_index++)
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:			const int size = this->gridt->how_many_atoms[ grid_index ];
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:			Gint_Tools::get_block_info(*this->gridt, this->bxyz, size, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:			Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:            Gint_Tools::cal_psir_ylm(*this->gridt, 
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:                this->bxyz,
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:            int* vindex = Gint_Tools::get_vindex(this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:                this->nplane, this->gridt->start_ind[grid_index], ncyz);
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:				const int mcell_index1 = this->gridt->bcell_start[grid_index] + ia1;
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:				const int iat = this->gridt->which_atom[mcell_index1];
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:				for (int ib=0; ib<this->bxyz; ib++)
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:						int iw1_lo = this->gridt->trace_lo[start1];
module_hamilt_lcao/module_gint/gint_gamma_env.cpp:			for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:	const int max_size = this->gridt->max_atom;
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:	const int lgd = this->gridt->lgd;
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:            this->hRGint->set_zero();           
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        this->cal_gint(inout);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:		setBufferParameter(*this->gridt, p2d.comm_2D, p2d.blacs_ctxt, p2d.nb,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:				this->sender_index_size, this->sender_local_index,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:				this->sender_size_process, this->sender_displacement_process,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:				this->sender_size, this->sender_buffer,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:				this->receiver_index_size, this->receiver_global_index,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:				this->receiver_size_process, this->receiver_displacement_process,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:				this->receiver_size, this->receiver_buffer);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        (this->sender_size+this->receiver_size)*sizeof(double)/1024/1024);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        (this->sender_index_size+this->receiver_index_size)*sizeof(int)/1024/1024);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:    for(int i=0; i<this->sender_index_size; i+=2)
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        const int irow=this->sender_local_index[i];
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        const int icol=this->sender_local_index[i+1];
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:            this->sender_buffer[i / 2] = vl_grid[irow * loc_grid_dim + icol];
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:            this->sender_buffer[i / 2] = vl_grid[icol * loc_grid_dim + irow];
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:    this->sender_size*8/1024/1024);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:	MPI_Alltoallv(this->sender_buffer, this->sender_size_process, this->sender_displacement_process, MPI_DOUBLE,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:			this->receiver_buffer, this->receiver_size_process,
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:			this->receiver_displacement_process, MPI_DOUBLE, p2d.comm_2D);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:    this->receiver_size*8/1024/1024);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:    for(int i=0; i<this->receiver_index_size; i+=2)
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        const int g_row = this->receiver_global_index[i];
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        const int g_col = this->receiver_global_index[i + 1];
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        setfunc(g_row, g_col, this->receiver_buffer[i / 2], vl_2d);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:    for(int iap=0;iap<this->hRGint->size_atom_pairs();iap++)
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        auto& ap = this->hRGint->get_atom_pair(iap);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:            const hamilt::AtomPair<double>* upper_ap = this->hRGint->find_pair(iat2, iat1);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        hR->add(*this->hRGint);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:        hamilt::transferSerials2Parallels(*this->hRGint, hR);
module_hamilt_lcao/module_gint/gint_gamma_vl.cpp:    hR->add(*this->hRGint);
module_hamilt_lcao/module_gint/gint_k.h:    void reset_spin(const int &spin_now_in){this->spin_now = spin_now_in;};
module_hamilt_lcao/module_gint/gint_k.h:        if(soft && this->spin_now == 0) 
module_hamilt_lcao/module_gint/gint_k.h:        else if (this->spin_now != -1)
module_hamilt_lcao/module_gint/gint_k.h:            this->reset_spin(start_spin);
module_hamilt_lcao/module_gint/gint_k.h:            this->destroy_pvpR();
module_hamilt_lcao/module_gint/gint_k.h:            this->allocate_pvpR();
module_hamilt_lcao/module_gint/gint_k.h:     * @brief transfer pvpR to this->hRGint
module_hamilt_lcao/module_gint/gint_k.h:     * then pass this->hRGint to Veff<OperatorLCAO>::hR
module_hamilt_lcao/module_gint/gint_k_env.cpp:	const int max_size = this->gridt->max_atom;
module_hamilt_lcao/module_gint/gint_k_env.cpp:		const int nbx = this->gridt->nbx;
module_hamilt_lcao/module_gint/gint_k_env.cpp:		const int nby = this->gridt->nby;
module_hamilt_lcao/module_gint/gint_k_env.cpp:		const int nbz_start = this->gridt->nbzp_start;
module_hamilt_lcao/module_gint/gint_k_env.cpp:		const int nbz = this->gridt->nbzp;
module_hamilt_lcao/module_gint/gint_k_env.cpp:		const int ncyz = this->ny*this->nplane; // mohan add 2012-03-25
module_hamilt_lcao/module_gint/gint_k_env.cpp:        for(int grid_index = 0; grid_index < this->nbxx; grid_index++)
module_hamilt_lcao/module_gint/gint_k_env.cpp:            const int size = this->gridt->how_many_atoms[ grid_index ];
module_hamilt_lcao/module_gint/gint_k_env.cpp:            Gint_Tools::get_block_info(*this->gridt, this->bxyz, size, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_k_env.cpp:            Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_k_env.cpp:            Gint_Tools::cal_psir_ylm(*this->gridt, 
module_hamilt_lcao/module_gint/gint_k_env.cpp:                this->bxyz, size, grid_index, delta_r,
module_hamilt_lcao/module_gint/gint_k_env.cpp:            int* vindex = Gint_Tools::get_vindex(this->bxyz, this->bx, this->by, this->bz,
module_hamilt_lcao/module_gint/gint_k_env.cpp:                this->nplane, this->gridt->start_ind[grid_index], ncyz);
module_hamilt_lcao/module_gint/gint_k_env.cpp:                const int mcell_index1 = this->gridt->bcell_start[grid_index] + ia1;
module_hamilt_lcao/module_gint/gint_k_env.cpp:                const int iat = this->gridt->which_atom[mcell_index1];
module_hamilt_lcao/module_gint/gint_k_env.cpp:                const int id_ucell = this->gridt->which_unitcell[mcell_index1];
module_hamilt_lcao/module_gint/gint_k_env.cpp:                const int Rx = this->gridt->ucell_index2x[id_ucell] + this->gridt->minu1;
module_hamilt_lcao/module_gint/gint_k_env.cpp:                const int Ry = this->gridt->ucell_index2y[id_ucell] + this->gridt->minu2;
module_hamilt_lcao/module_gint/gint_k_env.cpp:                const int Rz = this->gridt->ucell_index2z[id_ucell] + this->gridt->minu3;
module_hamilt_lcao/module_gint/gint_k_env.cpp:                for (int ib = 0; ib < this->bxyz; ib++)
module_hamilt_lcao/module_gint/gint_k_env.cpp:                                iw1_lo = this->gridt->trace_lo[start1] / GlobalV::NPOL 
module_hamilt_lcao/module_gint/gint_k_env.cpp:                                + this->gridt->lgd / GlobalV::NPOL * is;
module_hamilt_lcao/module_gint/gint_k_env.cpp:                            iw1_lo = this->gridt->trace_lo[start1];
module_hamilt_lcao/module_gint/gint_k_env.cpp:            for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:    // the number of matrix element <phi_0 | V | dphi_R> is this->gridt->nnrg.
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:    this->pvdpRx_reduced = new double*[nspin];
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:    this->pvdpRy_reduced = new double*[nspin];
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:    this->pvdpRz_reduced = new double*[nspin];
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:        this->pvdpRx_reduced[is] = new double[this->gridt->nnrg];	
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:        ModuleBase::GlobalFunc::ZEROS( pvdpRx_reduced[is], this->gridt->nnrg);
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:        this->pvdpRy_reduced[is] = new double[this->gridt->nnrg];	
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:        ModuleBase::GlobalFunc::ZEROS( pvdpRy_reduced[is], this->gridt->nnrg);
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:        this->pvdpRz_reduced[is] = new double[this->gridt->nnrg];	
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:        ModuleBase::GlobalFunc::ZEROS( pvdpRz_reduced[is], this->gridt->nnrg);
module_hamilt_lcao/module_gint/gint_k_pvdpr.cpp:    ModuleBase::Memory::record("pvdpR_reduced", 3 * sizeof(double) * this->gridt->nnrg * nspin);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    if(this->pvpR_alloc_flag)
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    this->pvpR_reduced = new double*[GlobalV::NSPIN];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:        this->pvpR_reduced[is] = new double[this->gridt->nnrg];	
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:        ModuleBase::GlobalFunc::ZEROS( pvpR_reduced[is], this->gridt->nnrg);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    ModuleBase::Memory::record("pvpR_reduced", sizeof(double) * this->gridt->nnrg * GlobalV::NSPIN);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    this->pvpR_alloc_flag = true;
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    this->pvpR_alloc_flag = false;
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    const int lgd = this->gridt->lgd;
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:            if(this->gridt->in_this_processor[iat])
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                const int DM_start = this->gridt->nlocstartg[iat];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                    if(this->gridt->in_this_processor[iat2])
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                            int ixxx = DM_start + this->gridt->find_R2st[iat][nad];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                                    std::complex<double> *vij = pvp[this->gridt->trace_lo[start1+iw]];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                                    const int* iw2_lo = &this->gridt->trace_lo[start2];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                                    int iw2_lo = this->gridt->trace_lo[start2]/GlobalV::NPOL;
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                                        auto vij = pvp_nc[spin][this->gridt->trace_lo[start1]/GlobalV::NPOL + iw];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:        const int mug = this->gridt->trace_lo[i];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                    const int nug = this->gridt->trace_lo[j];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                        const int nug = this->gridt->trace_lo[j];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                        const int nug = this->gridt->trace_lo[j];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    if(!pvpR_alloc_flag || this->hRGint == nullptr)
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    this->hRGint->set_zero();
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:            if(this->gridt->in_this_processor[iat])
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                const int DM_start = this->gridt->nlocstartg[iat];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                    if(this->gridt->in_this_processor[iat2])
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                            int ixxx = DM_start + this->gridt->find_R2st[iat][nad];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                            hamilt::BaseMatrix<double>* tmp_matrix = this->hRGint->find_matrix(iat, iat2, dR.x, dR.y, dR.z);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                                hamilt::BaseMatrix<double>* conj_matrix = this->hRGint->find_matrix(iat2, iat, -dR.x, -dR.y, -dR.z);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:        hR->add(*this->hRGint);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:        hamilt::transferSerials2Parallels(*this->hRGint, hR);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    hR->add(*this->hRGint);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    if(!pvpR_alloc_flag || this->hRGintCd == nullptr)
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    this->hRGintCd->set_zero();
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:            if(this->gridt->in_this_processor[iat])
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                const int DM_start = this->gridt->nlocstartg[iat];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                    if(this->gridt->in_this_processor[iat2])
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                            int ixxx = DM_start + this->gridt->find_R2st[iat][nad];
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                            hamilt::BaseMatrix<std::complex<double>>* tmp_matrix = this->hRGintCd->find_matrix(iat, iat2, dR.x, dR.y, dR.z);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:                                hamilt::BaseMatrix<std::complex<double>>* conj_matrix = this->hRGintCd->find_matrix(iat2, iat, -dR.x, -dR.y, -dR.z);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:        hR->add(*this->hRGintCd);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:        hamilt::transferSerials2Parallels<std::complex<double>>(*this->hRGintCd, hR);
module_hamilt_lcao/module_gint/gint_k_pvpr.cpp:    hR->add(*this->hRGintCd);
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:                    if(this->gridt->trace_lo[row] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:                        if(this->gridt->trace_lo[col] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:                    if(this->gridt->trace_lo[row] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:                        if(this->gridt->trace_lo[col] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:            if(this->gridt->in_this_processor[iat])
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:                const int DM_start = this->gridt->nlocstartg[iat];
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:                    if(this->gridt->in_this_processor[iat2])
module_hamilt_lcao/module_gint/gint_k_sparse.cpp:                            int ixxx = DM_start + this->gridt->find_R2st[iat][nad2];
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:                    if(this->gridt->trace_lo[row] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:                        if(this->gridt->trace_lo[col] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:                    if(this->gridt->trace_lo[row] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:                        if(this->gridt->trace_lo[col] >= 0)
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:            if(this->gridt->in_this_processor[iat])
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:                const int DM_start = this->gridt->nlocstartg[iat];
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:                    if(this->gridt->in_this_processor[iat2])
module_hamilt_lcao/module_gint/gint_k_sparse1.cpp:                            int ixxx = DM_start + this->gridt->find_R2st[iat][nad2];
module_hamilt_lcao/module_gint/gint_rho.cpp:	Gint_Tools::get_block_info(*this->gridt, this->bxyz, na_grid, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_rho.cpp:	Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_rho.cpp:	Gint_Tools::cal_psir_ylm(*this->gridt, 
module_hamilt_lcao/module_gint/gint_rho.cpp:		this->bxyz, na_grid, grid_index, delta_r,
module_hamilt_lcao/module_gint/gint_rho.cpp:		Gint_Tools::Array_Pool<double> psir_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_rho.cpp:		ModuleBase::GlobalFunc::ZEROS(psir_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_rho.cpp:					*this->gridt, this->bxyz, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_rho.cpp:					*this->gridt, this->bxyz, grid_index, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_rho.cpp:                    this->DMRGint[is], inout->if_symm);
module_hamilt_lcao/module_gint/gint_rho.cpp:				*this->gridt, this->bxyz, grid_index, na_grid,
module_hamilt_lcao/module_gint/gint_rho.cpp:				this->DMRGint[is],
module_hamilt_lcao/module_gint/gint_rho.cpp:		this->cal_meshball_rho(
module_hamilt_lcao/module_gint/gint_rho.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_rho.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_tau.cpp:	Gint_Tools::get_block_info(*this->gridt, this->bxyz, na_grid, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_tau.cpp:	Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_x(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_y(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_z(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:	Gint_Tools::cal_dpsir_ylm(*this->gridt, 
module_hamilt_lcao/module_gint/gint_tau.cpp:		this->bxyz, na_grid, grid_index, delta_r,
module_hamilt_lcao/module_gint/gint_tau.cpp:		Gint_Tools::Array_Pool<double> dpsix_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:		Gint_Tools::Array_Pool<double> dpsiy_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:		Gint_Tools::Array_Pool<double> dpsiz_DM(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:		ModuleBase::GlobalFunc::ZEROS(dpsix_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:		ModuleBase::GlobalFunc::ZEROS(dpsiy_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:		ModuleBase::GlobalFunc::ZEROS(dpsiz_DM.ptr_1D, this->bxyz*LD_pool);
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt,this->bxyz, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt, this->bxyz, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt, this->bxyz, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt,this->bxyz, grid_index, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_tau.cpp:				this->DMRGint[is], 1);
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt, this->bxyz, grid_index, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_tau.cpp:				this->DMRGint[is], 1);	
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt, this->bxyz, grid_index, na_grid, LD_pool,
module_hamilt_lcao/module_gint/gint_tau.cpp:				this->DMRGint[is], 1);
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt, this->bxyz, grid_index, na_grid,
module_hamilt_lcao/module_gint/gint_tau.cpp:				this->DMRGint[is],
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt, this->bxyz, grid_index, na_grid,
module_hamilt_lcao/module_gint/gint_tau.cpp:				this->DMRGint[is],
module_hamilt_lcao/module_gint/gint_tau.cpp:				*this->gridt, this->bxyz, grid_index, na_grid,
module_hamilt_lcao/module_gint/gint_tau.cpp:				this->DMRGint[is],
module_hamilt_lcao/module_gint/gint_tau.cpp:			this->cal_meshball_tau(
module_hamilt_lcao/module_gint/gint_tau.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_tau.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_tools.cpp:					//	Ylm::get_ylm_real(this->nnn[it], this->dr[id], ylma);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::get_block_info(*this->gridt, this->bxyz, na_grid, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::cal_psir_ylm(*this->gridt, 
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->bxyz, na_grid, grid_index, delta_r,
module_hamilt_lcao/module_gint/gint_vl.cpp:			this->bxyz, na_grid, LD_pool, block_index, cal_flag, vldr3, psir_ylm.ptr_2D);
module_hamilt_lcao/module_gint/gint_vl.cpp:		if(hR == nullptr) hR = this->hRGint;
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_gamma(
module_hamilt_lcao/module_gint/gint_vl.cpp:        this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::get_block_info(*this->gridt, this->bxyz, na_grid, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_x(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_y(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_z(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::cal_dpsir_ylm(*this->gridt, this->bxyz, na_grid, grid_index, delta_r,	block_index, block_size, cal_flag,
module_hamilt_lcao/module_gint/gint_vl.cpp:			this->bxyz, na_grid, LD_pool, block_index, cal_flag, vldr3, psir_ylm.ptr_2D);
module_hamilt_lcao/module_gint/gint_vl.cpp:	this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:	this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:	this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::get_block_info(*this->gridt, this->bxyz, na_grid, grid_index, block_iw, block_index, block_size, cal_flag);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> psir_ylm(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_x(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_y(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::Array_Pool<double> dpsir_ylm_z(this->bxyz, LD_pool);
module_hamilt_lcao/module_gint/gint_vl.cpp:	Gint_Tools::cal_dpsir_ylm(*this->gridt,
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->bxyz, na_grid, grid_index, delta_r,
module_hamilt_lcao/module_gint/gint_vl.cpp:			this->bxyz, na_grid, LD_pool, block_index, cal_flag, vldr3, psir_ylm.ptr_2D);
module_hamilt_lcao/module_gint/gint_vl.cpp:			this->bxyz, na_grid, LD_pool, block_index, cal_flag, vkdr3, dpsir_ylm_x.ptr_2D);
module_hamilt_lcao/module_gint/gint_vl.cpp:			this->bxyz, na_grid, LD_pool, block_index, cal_flag, vkdr3, dpsir_ylm_y.ptr_2D);	
module_hamilt_lcao/module_gint/gint_vl.cpp:			this->bxyz, na_grid, LD_pool, block_index, cal_flag, vkdr3, dpsir_ylm_z.ptr_2D);
module_hamilt_lcao/module_gint/gint_vl.cpp:		if(hR == nullptr) hR = this->hRGint;
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_gamma(
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_gamma(
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_gamma(
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_gamma(
module_hamilt_lcao/module_gint/gint_vl.cpp:        this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:		this->cal_meshball_vlocal_k(
module_hamilt_lcao/module_gint/gint_vl.cpp:	for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_vl.cpp:	const bool*const*const cal_flag,	    	// cal_flag[this->bxyz][na_grid],	whether the atom-grid distance is larger than cutoff
module_hamilt_lcao/module_gint/gint_vl.cpp:	const double*const*const psir_ylm,		    // psir_ylm[this->bxyz][LD_pool]
module_hamilt_lcao/module_gint/gint_vl.cpp:	const double*const*const psir_vlbr3,	    // psir_vlbr3[this->bxyz][LD_pool]
module_hamilt_lcao/module_gint/gint_vl.cpp:	hamilt::HContainer<double>* hR)	    // this->hRGint is the container of <phi_0 | V | phi_R> matrix element.
module_hamilt_lcao/module_gint/gint_vl.cpp:    const int lgd_now = this->gridt->lgd;
module_hamilt_lcao/module_gint/gint_vl.cpp:	const int mcell_index = this->gridt->bcell_start[grid_index];
module_hamilt_lcao/module_gint/gint_vl.cpp:		const int iat1= this->gridt->which_atom[mcell_index + ia1];
module_hamilt_lcao/module_gint/gint_vl.cpp:			const int iat2= this->gridt->which_atom[mcell_index + ia2];
module_hamilt_lcao/module_gint/gint_vl.cpp:                for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_vl.cpp:                for(int ib=this->bxyz-1; ib>=0; --ib)
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int R1x=this->gridt->ucell_index2x[id1];
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int R2x=this->gridt->ucell_index2x[id2];
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int R1y=this->gridt->ucell_index2y[id1];
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int R2y=this->gridt->ucell_index2y[id2];
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int R1z=this->gridt->ucell_index2z[id1];
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int R2z=this->gridt->ucell_index2z[id2];
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int index=this->gridt->cal_RindexAtom(dRx, dRy, dRz, iat2);
module_hamilt_lcao/module_gint/gint_vl.cpp:        const int offset = this->gridt->binary_search_find_R2_offset(index, iat1);
module_hamilt_lcao/module_gint/gint_vl.cpp:        assert(offset < this->gridt->nad[iat1]);
module_hamilt_lcao/module_gint/gint_vl.cpp:	int k=this->bxyz;
module_hamilt_lcao/module_gint/gint_vl.cpp:		const int mcell_index1 = this->gridt->bcell_start[grid_index] + ia1;
module_hamilt_lcao/module_gint/gint_vl.cpp:		const int iat1= this->gridt->which_atom[mcell_index1];
module_hamilt_lcao/module_gint/gint_vl.cpp:		const int id1 = this->gridt->which_unitcell[mcell_index1];
module_hamilt_lcao/module_gint/gint_vl.cpp:		const int DM_start = this->gridt->nlocstartg[iat1];
module_hamilt_lcao/module_gint/gint_vl.cpp:			const int mcell_index2 = this->gridt->bcell_start[grid_index] + ia2;
module_hamilt_lcao/module_gint/gint_vl.cpp:			const int iat2 = this->gridt->which_atom[mcell_index2];
module_hamilt_lcao/module_gint/gint_vl.cpp:    			for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/gint_vl.cpp:				const int mcell_index2 = this->gridt->bcell_start[grid_index] + ia2;
module_hamilt_lcao/module_gint/gint_vl.cpp:				const int id2 = this->gridt->which_unitcell[mcell_index2];
module_hamilt_lcao/module_gint/gint_vl.cpp:				const int iatw = DM_start + this->gridt->find_R2st[iat1][offset];	
module_hamilt_lcao/module_gint/gint_vl.cpp:			    if(cal_num>this->bxyz/4)
module_hamilt_lcao/module_gint/gint_vl.cpp:					k=this->bxyz;
module_hamilt_lcao/module_gint/gint_vl.cpp:					for(int ib=0; ib<this->bxyz; ++ib)
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->flag_tib = false;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->index_atom = nullptr;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->orbital_rmax = 0.0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nxe = this->nye = this->nze = 0;	
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_dx = 0.0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_dy = 0.0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_dz = 0.0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->dxe = 0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->dye = 0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->dze = 0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nxe = 0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nye = 0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nze = 0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nxyze = 0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	if(this->flag_tib)
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec1[0]= GlobalC::ucell.a1.x / (double)nbx * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec1[1]= GlobalC::ucell.a1.y / (double)nbx * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec1[2]= GlobalC::ucell.a1.z / (double)nbx * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec2[0]= GlobalC::ucell.a2.x / (double)nby * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec2[1]= GlobalC::ucell.a2.y / (double)nby * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec2[2]= GlobalC::ucell.a2.z / (double)nby * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec3[0]= GlobalC::ucell.a3.x / (double)nbz * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec3[1]= GlobalC::ucell.a3.y / (double)nbz * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_vec3[2]= GlobalC::ucell.a3.z / (double)nbz * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e11 = this->bigcell_vec1[0];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e12 = this->bigcell_vec1[1];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e13 = this->bigcell_vec1[2];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e21 = this->bigcell_vec2[0];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e22 = this->bigcell_vec2[1];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e23 = this->bigcell_vec2[2];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e31 = this->bigcell_vec3[0];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e32 = this->bigcell_vec3[1];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_latvec0.e33 = this->bigcell_vec3[2];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->bigcell_GT = this->bigcell_latvec0.Inverse();
module_hamilt_lcao/module_gint/grid_bigcell.cpp:		this->orbital_rmax = std::max( GlobalC::ORB.Phi[T].getRcut(), this->orbital_rmax);
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->dxe = static_cast<int>( this->orbital_rmax * g1) +1;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->dye = static_cast<int>( this->orbital_rmax * g2) +1;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->dze = static_cast<int>( this->orbital_rmax * g3) +1;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nxe = nbx + 2*dxe +1;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nye = nby + 2*dye +1;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nze = nbz + 2*dze +1;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	this->nxyze = this->nxe * this->nye * this->nze;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:		this->tau_in_bigcell = new double* [GlobalC::ucell.nat];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:			this->tau_in_bigcell[i] = new double[3];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:		this->flag_tib = true;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:		this->index_atom = new int[GlobalC::ucell.nat];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:			//fraction = ( GlobalC::ucell.atoms[it].tau[ia] * GlobalC::ucell.lat0 )* this->bigcell_GT;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:			this->index_atom[iat] = (kk+dze) + (jj+dye) * this->nze + (ii+dxe) * this->nye * this->nze;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:				this->tau_in_bigcell[iat][ic] = 
module_hamilt_lcao/module_gint/grid_bigcell.cpp:					delta[0] * this->bigcell_vec1[ic] + 
module_hamilt_lcao/module_gint/grid_bigcell.cpp:					delta[1] * this->bigcell_vec2[ic] + 
module_hamilt_lcao/module_gint/grid_bigcell.cpp:					delta[2] * this->bigcell_vec3[ic];
module_hamilt_lcao/module_gint/grid_bigcell.cpp:	for(int i=0; i<this->nxe; i++)
module_hamilt_lcao/module_gint/grid_bigcell.cpp:		for(int j=0; j<this->nye; j++)
module_hamilt_lcao/module_gint/grid_bigcell.cpp:			for(int k=0; k<this->nze; k++)
module_hamilt_lcao/module_gint/grid_bigcell.cpp:				in_ext = k + j * this->nze + i * this->nye * this->nze;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:				ii = i - this->dxe;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:				jj = j - this->dye;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:				kk = k - this->dze;
module_hamilt_lcao/module_gint/grid_bigcell.cpp:					target[in_ext] = this->cal_Rindex(cel1, cel2, cel3);
module_hamilt_lcao/module_gint/grid_meshball.cpp:	this->meshball_radius = 0.0;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	this->meshball_ncells = 0;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	this->flag_mp = false;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	this->index_ball = nullptr;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	this->meshball_radius = this->orbital_rmax;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	// const double rcut2 = this->meshball_radius * this->meshball_radius;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	// However, r2 is either 35.99.. or 36.0..001 which makes  count != this->meshball_ncells
module_hamilt_lcao/module_gint/grid_meshball.cpp:	const double rcut2 = this->meshball_radius * this->meshball_radius + 0.001;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	this->meshball_ncells = 0;
module_hamilt_lcao/module_gint/grid_meshball.cpp:				r2 = this->deal_with_atom_spillage( pos );
module_hamilt_lcao/module_gint/grid_meshball.cpp:	if(GlobalV::test_gridt)ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, "how many cells in meshball",this->meshball_ncells);
module_hamilt_lcao/module_gint/grid_meshball.cpp:		this->meshball_positions = new double*[meshball_ncells];
module_hamilt_lcao/module_gint/grid_meshball.cpp:			this->meshball_positions[i] = new double[3];
module_hamilt_lcao/module_gint/grid_meshball.cpp:		this->flag_mp = true;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	this->index_ball = new int[meshball_ncells];
module_hamilt_lcao/module_gint/grid_meshball.cpp:	for(int i=-dxe; i<this->dxe+1; i++)
module_hamilt_lcao/module_gint/grid_meshball.cpp:		for(int j=-dye; j<this->dye+1; j++)
module_hamilt_lcao/module_gint/grid_meshball.cpp:			for(int k=-dze; k<this->dze+1; k++)
module_hamilt_lcao/module_gint/grid_meshball.cpp:				r2 = this->deal_with_atom_spillage( pos );
module_hamilt_lcao/module_gint/grid_meshball.cpp:						this->meshball_positions[count][ip] = pos[ip];
module_hamilt_lcao/module_gint/grid_meshball.cpp:					this->index_ball[count] = k + j * this->nze + i * this->nye * this->nze;
module_hamilt_lcao/module_gint/grid_meshball.cpp:	assert(count == this->meshball_ncells);
module_hamilt_lcao/module_gint/grid_meshball.cpp:					cell[ip] = i*this->bigcell_vec1[ip] +
module_hamilt_lcao/module_gint/grid_meshball.cpp:						j*this->bigcell_vec2[ip] +
module_hamilt_lcao/module_gint/grid_meshball.cpp:						k*this->bigcell_vec3[ip];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->ncx = ncx_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->ncy = ncy_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->ncz = ncz_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->ncxyz = ncx * ncy * ncz;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->bx = bx_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->by = by_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->bz = bz_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->bxyz = bx*by*bz;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->nbx = nbx_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->nby = nby_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->nbz = nbz_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->nbxyz = nbx*nby*nbz;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->nbxx = nbxx_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->nbzp_start = nbzp_start_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:    this->nbzp = nbzp_in;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec1[0]= GlobalC::ucell.a1.x / (double)ncx * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec1[1]= GlobalC::ucell.a1.y / (double)ncx * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec1[2]= GlobalC::ucell.a1.z / (double)ncx * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec2[0]= GlobalC::ucell.a2.x / (double)ncy * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec2[1]= GlobalC::ucell.a2.y / (double)ncy * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec2[2]= GlobalC::ucell.a2.z / (double)ncy * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec3[0]= GlobalC::ucell.a3.x / (double)ncz * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec3[1]= GlobalC::ucell.a3.y / (double)ncz * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_vec3[2]= GlobalC::ucell.a3.z / (double)ncz * GlobalC::ucell.lat0;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e11 = this->meshcell_vec1[0];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e12 = this->meshcell_vec1[1];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e13 = this->meshcell_vec1[2];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e21 = this->meshcell_vec2[0];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e22 = this->meshcell_vec2[1];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e23 = this->meshcell_vec2[2];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e31 = this->meshcell_vec3[0];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e32 = this->meshcell_vec3[1];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_latvec0.e33 = this->meshcell_vec3[2];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->meshcell_GT = this->meshcell_latvec0.Inverse();
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->maxu1 = dxe / this->nbx + 1;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->maxu2 = dye / this->nby + 1;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->maxu3 = dze / this->nbz + 1;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->minu1 = (-dxe+1) / this->nbx - 1; 
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->minu2 = (-dye+1) / this->nby - 1; 
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->minu3 = (-dze+1) / this->nbz - 1; 
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->nu1 = maxu1 - minu1 + 1;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->nu2 = maxu2 - minu2 + 1;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->nu3 = maxu3 - minu3 + 1;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->nutot = nu1 * nu2 * nu3;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->ucell_index2x = new int[nutot];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->ucell_index2y = new int[nutot];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->ucell_index2z = new int[nutot];
module_hamilt_lcao/module_gint/grid_meshcell.cpp:	this->nutot = nu1 * nu2 * nu3;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:				this->ucell_index2x[cell] = i-minu1;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:				this->ucell_index2y[cell] = j-minu2;
module_hamilt_lcao/module_gint/grid_meshcell.cpp:				this->ucell_index2z[cell] = k-minu3;
module_hamilt_lcao/module_gint/grid_meshk.cpp:	const int x1 = u1 - this->minu1;
module_hamilt_lcao/module_gint/grid_meshk.cpp:	const int x2 = u2 - this->minu2;
module_hamilt_lcao/module_gint/grid_meshk.cpp:	const int x3 = u3 - this->minu3;
module_hamilt_lcao/module_gint/grid_meshk.cpp:	return (x3 + x2 * this->nu3 + x1 * this->nu2 * this->nu3);
module_hamilt_lcao/module_gint/grid_technique.cpp:    this->nlocdimg = nullptr;	
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->nlocstartg = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->nad = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:    this->how_many_atoms = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->start_ind = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->which_atom = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->which_bigcell = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->which_unitcell = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->bcell_start = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->in_this_processor = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->trace_lo = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->total_atoms_on_grid = 0;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->set_grid_dim(
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_latvec();
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_big_latvec();
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_meshcell_pos();
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_grid_expansion();
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->cal_extended_cell(this->dxe, this->dye, this->dze);
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_tau_in_bigcell();
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->delete_meshball_positions(); //LiuXh add 2018-12-14
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_meshball();
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_atoms_on_grid(ny, nplane, startz_current);	
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->cal_trace_lo();
module_hamilt_lcao/module_gint/grid_technique.cpp:	delete[] this->start_ind;
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->start_ind = new int[nbxx];
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->start_ind = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:		ix = ibx * this->bx;
module_hamilt_lcao/module_gint/grid_technique.cpp:		iy = iby * this->by;
module_hamilt_lcao/module_gint/grid_technique.cpp:		iz = (ibz + nbzp_start) * this->bz - startz_current;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->get_startind(ny, nplane, startz_current);
module_hamilt_lcao/module_gint/grid_technique.cpp:	delete[] this->how_many_atoms;
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->how_many_atoms = new int[nbxx];
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->how_many_atoms = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->check_bigcell(ind_bigcell, bigcell_on_processor);
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->in_this_processor = new bool[GlobalC::ucell.nat];
module_hamilt_lcao/module_gint/grid_technique.cpp:	assert( this->nxyze > 0);
module_hamilt_lcao/module_gint/grid_technique.cpp:	int* index2normal = new int[this->nxyze];
module_hamilt_lcao/module_gint/grid_technique.cpp:	ModuleBase::Memory::record("GT::index2normal", sizeof(int) * this->nxyze);
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->grid_expansion_index(1,index2normal); 
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->total_atoms_on_grid = 0;
module_hamilt_lcao/module_gint/grid_technique.cpp:			for(int im=0; im< this->meshball_ncells; im++)
module_hamilt_lcao/module_gint/grid_technique.cpp:				normal = index2normal[ this->index_atom[iat] + this->index_ball[im] ];
module_hamilt_lcao/module_gint/grid_technique.cpp:				this->in_this_processor[iat] = true;
module_hamilt_lcao/module_gint/grid_technique.cpp:			if(this->in_this_processor[iat]) ++nat_local;
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->trace_iat.resize(nat_local);
module_hamilt_lcao/module_gint/grid_technique.cpp:			if(this->in_this_processor[iat])
module_hamilt_lcao/module_gint/grid_technique.cpp:				this->trace_iat[--nat_local] = iat;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->cal_grid_integration_index();
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->init_atoms_on_grid2(index2normal);
module_hamilt_lcao/module_gint/grid_technique.cpp:	int* index2ucell = new int[this->nxyze];
module_hamilt_lcao/module_gint/grid_technique.cpp:	ModuleBase::Memory::record("GT::index2ucell", sizeof(int) * this->nxyze);	
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->grid_expansion_index(0,index2ucell);
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->check_bigcell(ind_bigcell, bigcell_on_processor);
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->which_atom = new int[total_atoms_on_grid];
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->which_bigcell = new int[total_atoms_on_grid];
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->which_unitcell = new int[total_atoms_on_grid];
module_hamilt_lcao/module_gint/grid_technique.cpp:	ModuleBase::GlobalFunc::ZEROS(this->how_many_atoms, nbxx);
module_hamilt_lcao/module_gint/grid_technique.cpp:			for(int im=0; im< this->meshball_ncells; im++)
module_hamilt_lcao/module_gint/grid_technique.cpp:				const int extgrid = this->index_atom[iat] + this->index_ball[im];
module_hamilt_lcao/module_gint/grid_technique.cpp:				int index = this->bcell_start[f] + this->how_many_atoms[f];
module_hamilt_lcao/module_gint/grid_technique.cpp:				this->which_atom[ index ] = iat;
module_hamilt_lcao/module_gint/grid_technique.cpp:				this->which_bigcell[ index ] = im;
module_hamilt_lcao/module_gint/grid_technique.cpp:				this->which_unitcell[ index ] = index2ucell[extgrid];
module_hamilt_lcao/module_gint/grid_technique.cpp:	delete[] this->bcell_start;
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->bcell_start = new int[nbxx];
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->bcell_start[0] = 0;
module_hamilt_lcao/module_gint/grid_technique.cpp:			this->bcell_start[i] = this->bcell_start[i-1] + this->how_many_atoms[i-1];
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->bcell_start = nullptr;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->max_atom = 0;
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->max_atom = std::max( this->max_atom, this->how_many_atoms[i]);
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->trace_lo = new int[GlobalV::NLOCAL];
module_hamilt_lcao/module_gint/grid_technique.cpp:		this->trace_lo[i] = -1;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->lnat = 0;
module_hamilt_lcao/module_gint/grid_technique.cpp:	this->lgd = 0;
module_hamilt_lcao/module_gint/grid_technique.cpp:			if(this->in_this_processor[iat])
module_hamilt_lcao/module_gint/grid_technique.cpp:					this->lgd += nw0;
module_hamilt_lcao/module_gint/grid_technique.cpp:					this->lgd += GlobalC::ucell.atoms[it].nw;
module_hamilt_lcao/module_gint/grid_technique.cpp:					this->trace_lo[iw_all] = iw_local;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->values.clear();
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(this->paraV != nullptr);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_ap = this->paraV->atom_begin_row[atom_i];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_ap = this->paraV->atom_begin_col[atom_j];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    if (this->row_ap == -1 || this->col_ap == -1)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_size = this->paraV->get_row_size(atom_i);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_size = this->paraV->get_col_size(atom_j);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index.resize(3, 0);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->current_R = 0;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(this->paraV != nullptr);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_ap = this->paraV->atom_begin_row[atom_i];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_ap = this->paraV->atom_begin_col[atom_j];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    if (this->row_ap == -1 || this->col_ap == -1)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_size = this->paraV->get_row_size(atom_i);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_size = this->paraV->get_col_size(atom_j);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index.resize(3, 0);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->current_R = 0;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index[0] = rx;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index[1] = ry;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index[2] = rz;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_ap = row_atom_begin[atom_i];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_ap = col_atom_begin[atom_j];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_size = row_atom_begin[atom_i + 1] - row_atom_begin[atom_i];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_size = col_atom_begin[atom_j + 1] - col_atom_begin[atom_j];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index.resize(3, 0);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->current_R = 0;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_ap = row_atom_begin[atom_i];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_ap = col_atom_begin[atom_j];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_size = row_atom_begin[atom_i + 1] - row_atom_begin[atom_i];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_size = col_atom_begin[atom_j + 1] - col_atom_begin[atom_j];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index.resize(3, 0);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->current_R = 0;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index[0] = rx;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index[1] = ry;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index[2] = rz;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values = other.values;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        this->values.reserve(other.values.size());
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            data_pointer += this->get_size();
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for(int value=0;value<this->values.size();++value)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->values[value].allocate(nullptr, is_zero);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for(int value=0;value<this->values.size();++value)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->values[value].allocate(data_array, is_zero);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            data_array += this->get_size();
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->row_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->atom_i;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->atom_j;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->col_size = col_size_in;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->row_size = row_size_in;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->paraV;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    if (this->atom_i == other.atom_i && this->atom_j == other.atom_j)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    if (this->atom_i == atom_i_ && this->atom_j == atom_j_)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    const int r_index = this->find_R(rx_in, ry_in, rz_in);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        // if found, return this->values[current_R]
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        return this->values[r_index];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    values.push_back(BaseMatrix<T>(this->row_size, this->col_size));
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->values.back();
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    const int r_index = this->find_R(rx_in, ry_in, rz_in);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        // if found, return this->values[current_R]
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        return this->values[r_index];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    if (index >= this->values.size())
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return const_cast<BaseMatrix<T>&>(this->values[index]);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    for (int i = 0; i < this->R_index.size(); i += 3)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->current_R = i / 3;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    const int r_index = this->find_R(rx_in, ry_in, rz_in);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        return &(this->values[r_index]);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    const int r_index = this->find_R(rx_in, ry_in, rz_in);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        return &(this->values[r_index]);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    BaseMatrix<T>& matrix = this->get_HR_values(rx_in, ry_in, rz_in);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        //if not found, push_back this BaseMatrix to this->values
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        if (this->find_R(rx, ry, rz) == -1)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->R_index.push_back(rx);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->R_index.push_back(ry);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->R_index.push_back(rz);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->values.push_back(matrix_tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        else if (this->values[current_R].get_pointer() == nullptr || matrix_tmp.get_pointer() == nullptr)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            this->values[current_R].add_array(matrix_tmp.get_pointer());
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index.clear();
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->R_index.resize(3, 0);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    BaseMatrix<T> tmp(this->row_size, this->col_size);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    for (int i = 0; i < this->values.size(); i++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        if(this->values[i].get_pointer() != nullptr)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            tmp.add_array(this->values[i].get_pointer());
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->values.clear();
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->values.push_back(tmp);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    this->current_R = 0;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->row_ap * ld_hk + this->col_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.real(), hr_tmp, 1, hk_real_pointer, 2);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.imag(), hr_tmp, 1, hk_imag_pointer, 2);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->col_ap * ld_hk + this->row_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.real(), hr_tmp, 1, hk_real_pointer, ld_hk_2);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.imag(), hr_tmp, 1, hk_imag_pointer, ld_hk_2);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->row_ap * ld_hk + this->col_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase, hr_tmp, 1, hk_tmp, 1);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            /*for (int nu = 0; nu < this->col_size; nu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->col_ap * ld_hk + this->row_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase, hr_tmp, 1, hk_tmp, ld_hk);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            /*for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->row_ap * ld_hk + this->col_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.real(), hk_real_pointer, 2, hr_tmp, 1);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.imag(), hk_imag_pointer, 2, hr_tmp, 1);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->col_ap * ld_hk + this->row_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.real(), hk_real_pointer, ld_hk_2, hr_tmp, 1);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase.imag(), hk_imag_pointer, ld_hk_2, hr_tmp, 1);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->row_ap * ld_hk + this->col_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase, hk_tmp, 1, hr_tmp, 1);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            /*for (int nu = 0; nu < this->col_size; nu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        hk_tmp += this->col_ap * ld_hk + this->row_ap;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            BlasConnector::axpy(this->col_size, kphase, hk_tmp, ld_hk, hr_tmp, 1);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            /*for (int mu = 0; mu < this->row_size; mu++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:            hr_tmp += this->col_size;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    for (int i = 0; i < this->row_size * this->col_size; i++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    for (int i = 0; i < this->row_size * this->col_size; i++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    if(ir<0) ir = this->current_R;
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return std::tuple<std::vector<int>, T*>({this->row_ap, this->row_size, this->col_ap, this->col_size}, this->values[ir].get_pointer());
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:// interface for get (rx, ry, rz) of index-th R-index in this->R_index, the return should be int[3]
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(i < this->row_size * this->col_size);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(current_R < this->values.size());
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->values[current_R].get_pointer()[i];
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(row < this->row_size && row >= 0);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(col < this->col_size && col >= 0);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(current_R < this->values.size());
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->values[current_R].get_value(row, col);
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    assert(current_R < this->values.size());
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    return this->values[ir].get_pointer();
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:    for (int i = 0; i < this->values.size(); i++)
module_hamilt_lcao/module_hcontainer/atom_pair.cpp:        memory_size += this->values[i].get_memory_size();
module_hamilt_lcao/module_hcontainer/atom_pair.h:    int get_size() const {return this->col_size * this->row_size;}
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @brief get target BaseMatrix of index of this->values
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @param index index of this->values
module_hamilt_lcao/module_hcontainer/atom_pair.h:    // interface for get (rx, ry, rz) of index-th R-index in this->R_index, the return should be int[3]
module_hamilt_lcao/module_hcontainer/atom_pair.h:    // interface for search (rx, ry, rz) in this->R_index, if found, current_R would be set to index
module_hamilt_lcao/module_hcontainer/atom_pair.h:    // interface for search (rx, ry, rz) in this->R_index, if found, current_R would be set to index
module_hamilt_lcao/module_hcontainer/atom_pair.h:    // and return BaseMatrix<T>* of this->values[index]
module_hamilt_lcao/module_hcontainer/atom_pair.h:    // this interface will call get_value in this->values
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @brief get values of this->values[ir] for a whole matrix
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @param ir index of this->values
module_hamilt_lcao/module_hcontainer/atom_pair.h:    // add another BaseMatrix<T> to this->values with specific R index.
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * in this case, H_gamma = sum_{R} H_R will be saved in this->values[0]
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @brief Add this->value[current_R] * kphase as a block matrix of hk.
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @brief Add this->value[current_R] * kphase as a block matrix of hk.
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @brief Add this->value[current_R] * kphase to an array.
module_hamilt_lcao/module_hcontainer/atom_pair.h:     * @brief Add this->value[current_R] * kphase to an array.
module_hamilt_lcao/module_hcontainer/atom_pair.h:    // interface for getting the size of this->R_index
module_hamilt_lcao/module_hcontainer/atom_pair.h:        assert(this->R_index.size() / 3 == this->values.size());
module_hamilt_lcao/module_hcontainer/atom_pair.h:        assert(this->R_index.size() % 3 == 0);
module_hamilt_lcao/module_hcontainer/atom_pair.h:        return this->R_index.size() / 3;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    this->allocated = false;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    this->nrow_local = matrix.nrow_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    this->ncol_local = matrix.ncol_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    this->value_begin = matrix.value_begin;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    this->allocated = matrix.allocated;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    this->nrow_local = matrix.nrow_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    this->ncol_local = matrix.ncol_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->value_begin = new T[nrow_local * ncol_local];
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        ModuleBase::GlobalFunc::ZEROS(this->value_begin, nrow_local * ncol_local);
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->allocated = true;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:            this->value_begin[i] = matrix.value_begin[i];
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->value_begin = matrix.value_begin;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->allocated = false;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    if (this->allocated)
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    if(data_array != nullptr && !this->allocated)
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->value_begin = data_array;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    else if(data_array != nullptr && this->allocated)
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        delete[] this->value_begin;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->value_begin = data_array;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->allocated = false;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    else if(data_array == nullptr && !this->allocated)
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->value_begin = new T[nrow_local * ncol_local];
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->allocated = true;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->set_zero();
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:assert(this->value_begin != nullptr);
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    ModuleBase::GlobalFunc::ZEROS(this->value_begin, nrow_local * ncol_local);
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    int index = mu * this->ncol_local + nu;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    int index = i_row * this->ncol_local + j_col;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->nrow_local = other.nrow_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->ncol_local = other.ncol_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:            this->value_begin = new T[nrow_local * ncol_local];
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:            ModuleBase::GlobalFunc::ZEROS(this->value_begin, nrow_local * ncol_local);
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:            this->allocated = true;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:                this->value_begin[i] = other.value_begin[i];
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:            this->value_begin = other.value_begin;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:            this->allocated = false;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->nrow_local = other.nrow_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->ncol_local = other.ncol_local;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->value_begin = other.value_begin;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:        this->allocated = other.allocated;
module_hamilt_lcao/module_hcontainer/base_matrix.cpp:    if(this->allocated)
module_hamilt_lcao/module_hcontainer/base_matrix.h:     * if this->value_begin is not nullptr, it will be neglected
module_hamilt_lcao/module_hcontainer/base_matrix.h:     * if this->value_begin is nullptr, it will allocate memory with size nrow_local * ncol_local
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if(this->allocated)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        delete[] this->wrapper_pointer;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap = HR_in.sparse_ap;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap_index = HR_in.sparse_ap_index;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->gamma_only = HR_in.gamma_only;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->paraV = HR_in.paraV;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->wrapper_pointer = data_array;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->allocated = false;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->atom_pairs = HR_in.atom_pairs;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->allocate(this->wrapper_pointer, true);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->atom_pairs = std::move(HR_in.atom_pairs);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap = std::move(HR_in.sparse_ap);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap_index = std::move(HR_in.sparse_ap_index);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->gamma_only = HR_in.gamma_only;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->paraV = HR_in.paraV;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->gamma_only = false;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap.resize(natom);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap_index.resize(natom);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->gamma_only = false;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->atom_pairs.resize(ucell_.nat * ucell_.nat, AtomPair<T>(0, 0));
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->sparse_ap.resize(ucell_.nat);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->sparse_ap_index.resize(ucell_.nat);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            this->sparse_ap[i].resize(ucell_.nat);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            this->sparse_ap_index[i].resize(ucell_.nat);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->atom_pairs[i * ucell_.nat + j] = AtomPair<T>(i, j, atom_begin_row.data(), atom_begin_col.data(), ucell_.nat);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->sparse_ap[i][j] = j;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->sparse_ap_index[i][j] = i * ucell_.nat + j;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->paraV = paraV;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->sparse_ap.resize(ucell_.nat);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->sparse_ap_index.resize(ucell_.nat);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->insert_pair(atom_ij);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->allocate(nullptr, true);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->wrapper_pointer = data_pointer;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->paraV = paraV_in;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap.resize(natom);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->sparse_ap_index.resize(natom);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->insert_ijrs(ijr_info);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->allocate(data_pointer, false);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    size_t nnr = this->get_nnr();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if(this->allocated)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    {// delete existed memory of this->wrapper_pointer
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        delete[] this->wrapper_pointer;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->allocated = false;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        // use this->wrapper_pointer as data_array
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->allocated = true;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->wrapper_pointer = new T[nnr];
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        ModuleBase::GlobalFunc::ZEROS(this->wrapper_pointer, nnr);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        data_array = this->wrapper_pointer;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        // use data_array to replace this->wrapper_pointer
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->wrapper_pointer = data_array;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            ModuleBase::GlobalFunc::ZEROS(this->wrapper_pointer, nnr);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for(int it=0;it<this->atom_pairs.size();it++)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->atom_pairs[it].allocate(data_array, false);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        data_array += this->atom_pairs[it].get_R_size() * this->atom_pairs[it].get_size();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for(auto& it : this->atom_pairs)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if(atom_i >= this->sparse_ap.size())
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    auto it = std::lower_bound(this->sparse_ap[atom_i].begin(), this->sparse_ap[atom_i].end(), atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (it != this->sparse_ap[atom_i].end() && *it == atom_j)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        AtomPair<T>* tmp_pointer = const_cast<AtomPair<T>*>(&this->atom_pairs[this->sparse_ap_index[atom_i][it-this->sparse_ap[atom_i].begin()]]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    AtomPair<T>* tmp = this->find_pair(atom_i, atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        if(this->gamma_only)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    AtomPair<T>* tmp = this->find_pair(atom_i, atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        if(this->gamma_only)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if(atom_i >= this->sparse_ap.size())
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    auto it = std::lower_bound(this->sparse_ap[atom_i].begin(), this->sparse_ap[atom_i].end(), atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (it != this->sparse_ap[atom_i].end() && *it == atom_j)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        AtomPair<T>* tmp = const_cast<AtomPair<T>*>(&this->atom_pairs[this->sparse_ap_index[atom_i][it-this->sparse_ap[atom_i].begin()]]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        return const_cast<AtomPair<T>&>(this->atom_pairs[0]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->current_R > -1)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        if (index >= this->tmp_atom_pairs.size() || index < 0)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        if (index >= this->atom_pairs.size() || index < 0)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->current_R > -1)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        return const_cast<AtomPair<T>&>(*this->tmp_atom_pairs[index]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        return const_cast<AtomPair<T>&>(this->atom_pairs[index]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->insert_pair(tmp);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    // clear and reallocate the memory of this->tmp_atom_pairs
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    //this->tmp_atom_pairs.clear();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    //this->tmp_atom_pairs.shrink_to_fit();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    //this->tmp_atom_pairs.reserve(this->atom_pairs.size());
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->tmp_atom_pairs.resize(this->atom_pairs.size());
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    // find (rx, ry, rz) in this->atom_pairs[i].R_values
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for (auto it = this->atom_pairs.begin(); it != this->atom_pairs.end(); ++it)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            // push bach the pointer of AtomPair to this->tmp_atom_pairs
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            this->tmp_atom_pairs[iter++] = tmp_pointer;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            //this->tmp_atom_pairs.push_back(tmp_pointer);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->current_R = this->find_R(rx_in, ry_in, rz_in);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->tmp_atom_pairs.resize(iter);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->tmp_atom_pairs.clear();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->tmp_atom_pairs.shrink_to_fit();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    // every AtomPair in this->atom_pairs has the (0, 0, 0) cell index
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    // fix every AtomPair in this->atom_pairs to only center cell
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->gamma_only = true;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for (int it =0; it< this->atom_pairs.size(); ++it)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->atom_pairs[it].merge_to_gamma();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->current_R != -1)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->current_R = -1;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->tmp_R_index.clear();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->tmp_R_index.shrink_to_fit();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    // search (rx, ry, rz) in this->tmp_R_index
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->tmp_R_index.empty())
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for (int i = 0; i < this->tmp_R_index.size() / 3; i++)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        if (this->tmp_R_index[i * 3] == rx_in && this->tmp_R_index[i * 3 + 1] == ry_in
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            && this->tmp_R_index[i * 3 + 2] == rz_in)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:// size_R_loop, return the number of different cells in this->atom_pairs
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->current_R > -1 && this->tmp_R_index.size() > 2)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        return this->tmp_R_index.size()/3;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:     * there is different R-index in this->atom_pairs[i].R_values
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:     * search them one by one and store them in this->tmp_R_index
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    this->tmp_R_index.clear();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for (auto it = this->atom_pairs.begin(); it != this->atom_pairs.end(); ++it)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:         * if (rx, ry, rz) not found in this->tmp_R_index,
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:         * insert the (rx, ry, rz) into end of this->tmp_R_index
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:         * no need to sort this->tmp_R_index, using find_R() to find the (rx, ry, rz) -> int in tmp_R_index
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            int it_tmp = this->find_R(R_pointer[0], R_pointer[1], R_pointer[2]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->tmp_R_index.push_back(R_pointer[0]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->tmp_R_index.push_back(R_pointer[1]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->tmp_R_index.push_back(R_pointer[2]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    return this->tmp_R_index.size() / 3;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (index >= this->tmp_R_index.size() / 3)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    rx = this->tmp_R_index[index * 3];
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    ry = this->tmp_R_index[index * 3 + 1];
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    rz = this->tmp_R_index[index * 3 + 2];
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->current_R > -1)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        return this->tmp_atom_pairs.size();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        return this->atom_pairs.size();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    AtomPair<T>* atom_ij = this->find_pair(atom_i, atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    AtomPair<T>* atom_ij = this->find_pair(atom_i, atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if(atom_i >= this->sparse_ap.size())
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    // find atom_ij in this->atom_pairs
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    auto it = std::lower_bound(this->sparse_ap[atom_i].begin(),
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                               this->sparse_ap[atom_i].end(), atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (it != this->sparse_ap[atom_i].end() && *it == atom_j)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        this->atom_pairs[this->sparse_ap_index[atom_i][it-this->sparse_ap[atom_i].begin()]].merge(atom_ij, this->gamma_only);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        if (this->paraV != atom_ij.get_paraV())
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            this->atom_pairs.push_back(atom_ij);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            if(this->gamma_only)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->atom_pairs.back().merge_to_gamma();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            int index = it - this->sparse_ap[atom_i].begin();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            if(it != this->sparse_ap[atom_i].end())
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->sparse_ap[atom_i].insert(this->sparse_ap[atom_i].begin() + index, atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->sparse_ap_index[atom_i].insert(this->sparse_ap_index[atom_i].begin() + index, this->atom_pairs.size() - 1);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->sparse_ap[atom_i].push_back(atom_j);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:                this->sparse_ap_index[atom_i].push_back(this->atom_pairs.size() - 1);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        return this->get_atom_pair(atom_i, atom_j).get_HR_values(rx_in, ry_in, rz_in).get_value(mu, nu);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    return this->current_R;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    return this->gamma_only;
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    memory += this->atom_pairs.capacity() * sizeof(AtomPair<T>);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    memory += this->sparse_ap.capacity() * sizeof(std::vector<int>);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    memory += this->sparse_ap_index.capacity() * sizeof(std::vector<int>);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for(int i=0;i<this->atom_pairs.size();++i)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        memory += this->atom_pairs[i].get_memory_size();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for(int i=0;i<this->sparse_ap.size();++i)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        memory += this->sparse_ap[i].capacity() * sizeof(int);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        memory += this->sparse_ap_index[i].capacity() * sizeof(int);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    memory += this->tmp_atom_pairs.capacity() * sizeof(AtomPair<T>*);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    memory += this->tmp_R_index.capacity() * sizeof(int);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if(this->allocated)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        memory += this->get_nnr() * sizeof(T);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->paraV != other.paraV)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        AtomPair<T>* tmp_pointer = this->find_pair(iat1, iat2);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            this->insert_pair(other.atom_pairs[i]);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            this->atom_pairs.back().set_zero();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    ijr_info.push_back(this->atom_pairs.size());
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    for (int i = 0; i < this->atom_pairs.size(); ++i)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        const int atom_i = this->atom_pairs[i].get_atom_i();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        const int atom_j = this->atom_pairs[i].get_atom_j();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:        const int number_R = this->atom_pairs[i].get_R_size();
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            int* R_pointer = this->atom_pairs[i].get_R_index(ir);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:    if (this->paraV == nullptr)
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            AtomPair<T> tmp_ap(atom_i, atom_j, r_index[0], r_index[1], r_index[2], this->paraV);
module_hamilt_lcao/module_hcontainer/hcontainer.cpp:            this->insert_pair(tmp_ap);
module_hamilt_lcao/module_hcontainer/hcontainer.h:    // save atom-pair pointers into this->tmp_atom_pairs for selected R index
module_hamilt_lcao/module_hcontainer/hcontainer.h:     * @brief save atom-pair pointers into this->tmp_atom_pairs for selected R index
module_hamilt_lcao/module_hcontainer/hcontainer.h:     * clear this->tmp_atom_pairs
module_hamilt_lcao/module_hcontainer/hcontainer.h:     * add BaseMatrix<T> with non-zero R index to this->atom_pairs[i].values[0]
module_hamilt_lcao/module_hcontainer/hcontainer.h:      for(int iap=0;iap < this->atom_pairs.size();++iap)
module_hamilt_lcao/module_hcontainer/hcontainer.h:          sum += this->atom_pairs[iap].get_R_size() * this->atom_pairs[iap].get_size();
module_hamilt_lcao/module_hcontainer/hcontainer.h:    T* get_wrapper() const {return this->wrapper_pointer;}
module_hamilt_lcao/module_hcontainer/hcontainer.h:     * new <IJR> pair from read-in HContainer will be inserted into this->atom-pairs
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:    int size_for_loop_R = this->_hcontainer->size_R_loop();
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:        this->_hcontainer->loop_R(iR, rx, ry, rz);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:        this->write_single_R(rx, ry, rz);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:    int size_for_loop_R = this->_hcontainer->size_R_loop();
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:        this->_hcontainer->loop_R(iR, rx, ry, rz);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:            this->write_single_R(rx, ry, rz);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:    this->_hcontainer->fix_R(rx, ry, rz);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:    ModuleIO::SparseMatrix<T> sparse_matrix = ModuleIO::SparseMatrix<T>(this->_ParaV->nrow, this->_ParaV->ncol);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:    sparse_matrix.setSparseThreshold(this->_sparse_threshold);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:    for (int iap = 0; iap < this->_hcontainer->size_atom_pairs(); ++iap)
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:        auto atom_pair = this->_hcontainer->get_atom_pair(iap);
module_hamilt_lcao/module_hcontainer/output_hcontainer.cpp:    this->_hcontainer->unfix_R();
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:		this->ntype = this->elements.size();
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.setup(this->latname, this->ntype, this->lmaxmax, this->init_vel, this->fixed_axes);
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:            ucell.atom_label[it] = this->elements[it];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:            ucell.atom_mass[it] = this->atomic_mass[it];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:            ucell.pseudo_fn[it] = this->pp_files[it];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:            ucell.pseudo_type[it] = this->pp_types[it];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:            ucell.orbital_fn[it] = this->orb_files[it];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.lat0 = this->lat0;
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e11 = this->latvec[0];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e12 = this->latvec[1];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e13 = this->latvec[2];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e21 = this->latvec[3];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e22 = this->latvec[4];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e23 = this->latvec[5];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e31 = this->latvec[6];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e32 = this->latvec[7];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.latvec.e33 = this->latvec[8];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.Coordinate = this->coor_type;
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        this->atomic_index = 0;
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:            ucell.atoms[it].label = this->elements[it];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:            ucell.atoms[it].na = this->natom[it];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].taud[ia].x = this->coordinates[this->atomic_index * 3 + 0];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].taud[ia].y = this->coordinates[this->atomic_index * 3 + 1];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].taud[ia].z = this->coordinates[this->atomic_index * 3 + 2];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].x = this->coordinates[this->atomic_index * 3 + 0];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].y = this->coordinates[this->atomic_index * 3 + 1];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].tau[ia].z = this->coordinates[this->atomic_index * 3 + 2];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                if (this->init_vel)
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].vel[ia].x = this->velocity[this->atomic_index * 3 + 0];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].vel[ia].y = this->velocity[this->atomic_index * 3 + 1];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].vel[ia].z = this->velocity[this->atomic_index * 3 + 2];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                if (this->selective_dynamics)
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].mbl[ia].x = this->mbl[this->atomic_index * 3 + 0];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].mbl[ia].y = this->mbl[this->atomic_index * 3 + 1];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                    ucell.atoms[it].mbl[ia].z = this->mbl[this->atomic_index * 3 + 2];
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:                ++(this->atomic_index);
module_hamilt_lcao/module_hcontainer/test/prepare_unitcell.h:        ucell.nat = this->natom.sum();
module_hamilt_lcao/module_hcontainer/test/test_hcontainer_readCSR.cpp:    this->tot_magnetization = 0.0;
module_hamilt_lcao/module_hcontainer/test/test_hcontainer_readCSR.cpp:    this->abs_magnetization = 0.0;
module_hamilt_lcao/module_hcontainer/test/test_hcontainer_readCSR.cpp:    this->start_magnetization = nullptr;
module_hamilt_lcao/module_hcontainer/test/test_hcontainer_readCSR.cpp:    delete[] this->start_magnetization;
module_hamilt_lcao/module_hcontainer/test/tmp_mocks.cpp:	this->iat2iwt.resize(this->nat);
module_hamilt_lcao/module_hcontainer/test/tmp_mocks.cpp:	this->npol = npol_in;
module_hamilt_lcao/module_hcontainer/test/tmp_mocks.cpp:	for(int it = 0;it < this->ntype; it++)
module_hamilt_lcao/module_hcontainer/test/tmp_mocks.cpp:			this->iat2iwt[iat] = iwt;
module_hamilt_lcao/module_hcontainer/test/tmp_mocks.cpp:			iwt += atoms[it].nw * this->npol;
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->hr = hr_in;
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->ap_indexes.resize(n_processes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->size_values.resize(n_processes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->paraV = hr_in->get_atom_pair(0).get_paraV();
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->atom_i_index.resize(n_processes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(this->atom_i_index.size() > 0);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    for (int i = 0; i < this->atom_i_index[irank].size(); ++i)
module_hamilt_lcao/module_hcontainer/transfer.cpp:        int atom = this->atom_i_index[irank][i];
module_hamilt_lcao/module_hcontainer/transfer.cpp:        size_orb_indexes += this->paraV->get_row_size(atom);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        size_orb_indexes += this->paraV->get_col_size(atom);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    *data++ = this->atom_i_index[irank].size();
module_hamilt_lcao/module_hcontainer/transfer.cpp:    for (int i = 0; i < this->atom_i_index[irank].size(); ++i)
module_hamilt_lcao/module_hcontainer/transfer.cpp:        int atom = this->atom_i_index[irank][i];
module_hamilt_lcao/module_hcontainer/transfer.cpp:        *data = this->paraV->get_row_size(atom);
module_hamilt_lcao/module_hcontainer/transfer.cpp:            auto row_indexes = this->paraV->get_indexes_row(atom);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        *data = this->paraV->get_col_size(atom);
module_hamilt_lcao/module_hcontainer/transfer.cpp:            auto col_indexes = this->paraV->get_indexes_col(atom);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->ap_indexes[irank].resize(size_ap_indexes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        MPI_Recv(this->ap_indexes[irank].data(), size_ap_indexes, MPI_INT, irank, 1, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->ap_indexes[irank].assign(ap_indexes_in, ap_indexes_in + size_ap_indexes_in);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->size_values[irank] = 0;
module_hamilt_lcao/module_hcontainer/transfer.cpp:    const int number_atom = this->ap_indexes[irank][0];
module_hamilt_lcao/module_hcontainer/transfer.cpp:    const int* ap_data = this->ap_indexes[irank].data() + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->paraV->get_row_size(atom_i);
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int size_col = this->paraV->get_col_size(atom_j);
module_hamilt_lcao/module_hcontainer/transfer.cpp:                this->size_values[irank] += size_row * size_col * number_R;
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->atom_i_index[irank].resize(atom_set.size());
module_hamilt_lcao/module_hcontainer/transfer.cpp:    std::copy(atom_set.begin(), atom_set.end(), this->atom_i_index[irank].begin());
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(ap_data - this->ap_indexes[irank].data() == this->ap_indexes[irank].size());
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->cal_orb_indexes(irank, &orb_indexes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    std::vector<T> values(this->size_values[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->pack_data(irank, values.data());
module_hamilt_lcao/module_hcontainer/transfer.cpp:        std::vector<T> values_tmp(this->size_values[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->unpack_data(irank, values_tmp.data());
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->unpack_data(irank, values);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(this->size_values[irank] != 0);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    const int number_atom = this->ap_indexes[irank][0];
module_hamilt_lcao/module_hcontainer/transfer.cpp:    const int* ap_data = this->ap_indexes[irank].data() + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->paraV->get_row_size(atom_i);
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int size_col = this->paraV->get_col_size(atom_j);
module_hamilt_lcao/module_hcontainer/transfer.cpp:                    const T* matrix_pointer = this->hr->data(atom_i, atom_j, r_index);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(value_data - values == this->size_values[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(this->size_values[irank] != 0);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    const int number_atom = this->ap_indexes[irank][0];
module_hamilt_lcao/module_hcontainer/transfer.cpp:    int* ap_data = this->ap_indexes[irank].data() + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->paraV->get_row_size(atom_i);
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int size_col = this->paraV->get_col_size(atom_j);
module_hamilt_lcao/module_hcontainer/transfer.cpp:                    T* matrix_pointer = this->hr->data(atom_i, atom_j, r_index);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    //assert(value_data - values == this->data_size[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(ap_data - this->ap_indexes[irank].data() == this->ap_indexes[irank].size());
module_hamilt_lcao/module_hcontainer/transfer.cpp:    return *std::max_element(this->size_values.begin(), this->size_values.end());
module_hamilt_lcao/module_hcontainer/transfer.cpp:    for (int i = 0; i < this->size_values.size(); ++i)
module_hamilt_lcao/module_hcontainer/transfer.cpp:        out[i] = this->size_values[i];
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->hr = hr_in;
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->orb_indexes.resize(n_processes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->size_values.resize(n_processes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->orb_col_indexes.resize(n_processes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->orb_row_indexes.resize(n_processes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    long size_ap_indexes = this->hr->size_atom_pairs() * 2; // count of atom_j and size_r
module_hamilt_lcao/module_hcontainer/transfer.cpp:    for (int i = 0; i < this->hr->size_atom_pairs(); i++)
module_hamilt_lcao/module_hcontainer/transfer.cpp:        size_ap_indexes += this->hr->get_atom_pair(i).get_R_size() * 3; // count of rx, ry, rz
module_hamilt_lcao/module_hcontainer/transfer.cpp:    auto& sparse_ap = this->hr->get_sparse_ap();
module_hamilt_lcao/module_hcontainer/transfer.cpp:    auto& sparse_ap_index = this->hr->get_sparse_ap_index();
module_hamilt_lcao/module_hcontainer/transfer.cpp:                hamilt::AtomPair<T>& atom_pair = this->hr->get_atom_pair(sparse_ap_index[atom][j]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->cal_ap_indexes(irank, &ap_indexes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->orb_indexes[irank].resize(size_orb_indexes);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        MPI_Recv(this->orb_indexes[irank].data(),
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->orb_indexes[irank].assign(orb_indexes_in, orb_indexes_in + size_orb_indexes_in);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->size_values[irank] = 0;
module_hamilt_lcao/module_hcontainer/transfer.cpp:    const int number_atom = this->orb_indexes[irank][0];
module_hamilt_lcao/module_hcontainer/transfer.cpp:    const int* orb_data = this->orb_indexes[irank].data() + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->orb_row_indexes[irank][atom_i] = orb_data - orb_indexes[irank].data();
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->orb_col_indexes[irank][atom_i] = orb_data - orb_indexes[irank].data();
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(orb_data - this->orb_indexes[irank].data() == this->orb_indexes[irank].size());
module_hamilt_lcao/module_hcontainer/transfer.cpp:    for (int iap = 0; iap < this->hr->size_atom_pairs(); ++iap)
module_hamilt_lcao/module_hcontainer/transfer.cpp:        hamilt::AtomPair<T>& atom_pair = this->hr->get_atom_pair(iap);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->orb_indexes[irank][this->orb_row_indexes[irank][atom_i]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_col = this->orb_indexes[irank][this->orb_col_indexes[irank][atom_j]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:            this->size_values[irank] += size_row * size_col * number_R;
module_hamilt_lcao/module_hcontainer/transfer.cpp:    std::vector<T> values(this->size_values[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    this->pack_data(irank, values.data());
module_hamilt_lcao/module_hcontainer/transfer.cpp:        std::vector<T> values_tmp(this->size_values[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->unpack_data(irank, values_tmp.data());
module_hamilt_lcao/module_hcontainer/transfer.cpp:        this->unpack_data(irank, values);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(this->size_values[irank] != 0);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    auto& sparse_ap = this->hr->get_sparse_ap();
module_hamilt_lcao/module_hcontainer/transfer.cpp:    auto& sparse_ap_index = this->hr->get_sparse_ap_index();
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->orb_indexes[irank][this->orb_row_indexes[irank][atom_i]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int size_col = this->orb_indexes[irank][this->orb_col_indexes[irank][atom_j]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int number_R = this->hr->get_atom_pair(sparse_ap_index[i][j]).get_R_size();
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->orb_indexes[irank][this->orb_row_indexes[irank][atom_i]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int* row_index = this->orb_indexes[irank].data() + this->orb_row_indexes[irank][atom_i] + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int size_col = this->orb_indexes[irank][this->orb_col_indexes[irank][atom_j]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int* col_index = this->orb_indexes[irank].data() + this->orb_col_indexes[irank][atom_j] + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const hamilt::AtomPair<T>& tmp_ap = this->hr->get_atom_pair(sparse_ap_index[i][j]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    //assert(value_data - values == this->size_values[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    assert(this->size_values[irank] != 0);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    auto& sparse_ap = this->hr->get_sparse_ap();
module_hamilt_lcao/module_hcontainer/transfer.cpp:    auto& sparse_ap_index = this->hr->get_sparse_ap_index();
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->orb_indexes[irank][this->orb_row_indexes[irank][atom_i]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int size_col = this->orb_indexes[irank][this->orb_col_indexes[irank][atom_j]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int number_R = this->hr->get_atom_pair(sparse_ap_index[i][j]).get_R_size();
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int size_row = this->orb_indexes[irank][this->orb_row_indexes[irank][atom_i]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:        const int* row_index = this->orb_indexes[irank].data() + this->orb_row_indexes[irank][atom_i] + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int size_col = this->orb_indexes[irank][this->orb_col_indexes[irank][atom_j]];
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const int* col_index = this->orb_indexes[irank].data() + this->orb_col_indexes[irank][atom_j] + 1;
module_hamilt_lcao/module_hcontainer/transfer.cpp:            const hamilt::AtomPair<T>& tmp_ap = this->hr->get_atom_pair(sparse_ap_index[i][j]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    //assert(value_data - values == this->size_values[irank]);
module_hamilt_lcao/module_hcontainer/transfer.cpp:    return *std::max_element(this->size_values.begin(), this->size_values.end());
module_hamilt_lcao/module_hcontainer/transfer.cpp:    for (int i = 0; i < this->size_values.size(); ++i)
module_hamilt_lcao/module_hcontainer/transfer.cpp:        out[i] = this->size_values[i];
module_hamilt_lcao/module_hcontainer/transfer.h:     * 7, atom_i, ... number_orb_col, ...] i refers to the ith atom in this->ap_indexes[irank] the function is called in
module_hamilt_lcao/module_hcontainer/transfer.h:     * save to this->ap_indexes[irank]
module_hamilt_lcao/module_hcontainer/transfer.h:     * @brief pack data in this->hr, and send to ith rank
module_hamilt_lcao/module_hcontainer/transfer.h:     * @brief pack data in this->hr, and send to ith rank
module_hamilt_lcao/module_hcontainer/transfer.h:     * @brief receive data from ith rank, save them to this->hr
module_hamilt_lcao/module_hcontainer/transfer.h:     * save to this->orb_indexes[irank]
module_hamilt_lcao/module_hcontainer/transfer.h:     * @brief pack data in this->hr, and send to ith rank
module_hamilt_lcao/module_hcontainer/transfer.h:     * @brief receive data from ith rank, save them to this->hr
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* Numerator = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(Numerator, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    BlasConnector::copy(this->ParaV->nloc, Htmp, 1, Numerator, 1);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* Denominator = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(Denominator, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    BlasConnector::copy(this->ParaV->nloc, Htmp, 1, Denominator, 1);
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << Stmp[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << Stmp[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << Numerator[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << Numerator[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << Denominator[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << Denominator[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:    int* ipiv = new int[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ScalapackConnector::getrf(nlocal, nlocal, Denominator, 1, 1, this->ParaV->desc, ipiv, &info);
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << Denominator[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << Denominator[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << Numerator[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << Numerator[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                aa = U_operator[i * this->ParaV->ncol + j].real();
module_hamilt_lcao/module_tddft/propagator.cpp:                bb = U_operator[i * this->ParaV->ncol + j].imag();
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(U_operator, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* A_matrix = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(A_matrix, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* rank0 = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(rank0, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* rank2 = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(rank2, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* rank3 = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(rank3, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* rank4 = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(rank4, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* tmp1 = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(tmp1, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* tmp2 = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(tmp2, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::complex<double>* Sinv = new std::complex<double>[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ModuleBase::GlobalFunc::ZEROS(Sinv, this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    BlasConnector::copy(this->ParaV->nloc, Stmp, 1, Sinv, 1);
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << Stmp[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << Stmp[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << Htmp[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << Htmp[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:    MPI_Comm_rank(this->ParaV->comm_2D, &myid);
module_hamilt_lcao/module_tddft/propagator.cpp:    for (int iprow = 0; iprow < this->ParaV->dim0; ++iprow)
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int ipcol = 0; ipcol < this->ParaV->dim1; ++ipcol)
module_hamilt_lcao/module_tddft/propagator.cpp:            info = MPI_Cart_rank(this->ParaV->comm_2D, coord, &src_rank);
module_hamilt_lcao/module_tddft/propagator.cpp:                naroc[0] = this->ParaV->nrow;
module_hamilt_lcao/module_tddft/propagator.cpp:                naroc[1] = this->ParaV->ncol;
module_hamilt_lcao/module_tddft/propagator.cpp:                    int igcol = globalIndex(j, this->ParaV->nb, this->ParaV->dim1, ipcol);
module_hamilt_lcao/module_tddft/propagator.cpp:                        int igrow = globalIndex(i, this->ParaV->nb, this->ParaV->dim0, iprow);
module_hamilt_lcao/module_tddft/propagator.cpp:    int* ipiv = new int[this->ParaV->nloc];
module_hamilt_lcao/module_tddft/propagator.cpp:    ScalapackConnector::getrf(nlocal, nlocal, Sinv, 1, 1, this->ParaV->desc, ipiv, &info);
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                              this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                GlobalV::ofs_running << A_matrix[i * this->ParaV->ncol + j].real() << "+"
module_hamilt_lcao/module_tddft/propagator.cpp:                                     << A_matrix[i * this->ParaV->ncol + j].imag() << "i ";
module_hamilt_lcao/module_tddft/propagator.cpp:        for (int i = 0; i < this->ParaV->nrow; i++)
module_hamilt_lcao/module_tddft/propagator.cpp:            for (int j = 0; j < this->ParaV->ncol; j++)
module_hamilt_lcao/module_tddft/propagator.cpp:                aa = U_operator[i * this->ParaV->ncol + j].real();
module_hamilt_lcao/module_tddft/propagator.cpp:                bb = U_operator[i * this->ParaV->ncol + j].imag();
module_hamilt_lcao/module_tddft/propagator.cpp:    std::vector<std::complex<double>> U1(this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:    std::vector<std::complex<double>> U2(this->ParaV->nloc);
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc,
module_hamilt_lcao/module_tddft/propagator.cpp:                             this->ParaV->desc);
module_hamilt_lcao/module_tddft/propagator.h:        this->ptype = ptype;
module_hamilt_lcao/module_tddft/propagator.h:        this->ParaV = pv;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    this->dV_ = dV;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    this->lkt_a_ = lkt_a;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->nabla(prho[0], pw_rho, nabla_rho);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->get_as(prho[0], nabla_rho, pw_rho->nrxx, as);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        energy *= this->dV_ * this->c_tf_;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    this->lkt_energy = energy;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    Parallel_Reduce::reduce_all(this->lkt_energy);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    this->nabla(prho[is], pw_rho, nabla_rho);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    this->get_as(prho[is], nabla_rho, pw_rho->nrxx, as);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    energy_den = this->c_tf_ * pow(prho[is][ir], 5. / 3.) / std::cosh(as[ir]);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp: * and the LKT energy will be calculated and stored in this->lkt_energy
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:    this->lkt_energy = 0.;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->nabla(prho[0], pw_rho, nabla_rho);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->get_as(prho[0], nabla_rho, pw_rho->nrxx, as);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:            this->lkt_energy += std::pow(prho[0][ir], 5. / 3.) / coshas;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:            rpotential(0, ir) += 5.0 / 3.0 * this->c_tf_ * std::pow(prho[0][ir], 2. / 3.) / coshas
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                    nabla_rho[i][ir] = nabla_rho[i][ir] * tanhas / coshas / as[ir] / prho[0][ir] * this->c_tf_
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                                       * std::pow(this->s_coef_ * this->lkt_a_, 2);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->divergence(nabla_rho, pw_rho, nabla_term);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->lkt_energy *= this->c_tf_ * this->dV_;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        Parallel_Reduce::reduce_all(this->lkt_energy);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp: * @brief Get the stress of LKT KEDF, and store it into this->stress
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->nabla(prho[0], pw_rho, nabla_rho);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:        this->get_as(prho[0], nabla_rho, pw_rho->nrxx, as);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                this->stress(alpha, beta) = 0;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                    this->stress(alpha, beta) = 2.0 / 3.0 / pw_rho->omega * this->lkt_energy;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                                         * std::pow(this->s_coef_ * this->lkt_a_, 2) * coef;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                integral_term *= this->c_tf_ * this->dV_ / pw_rho->omega;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                this->stress(alpha, beta) += integral_term;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                this->stress(alpha, beta) = this->stress(beta, alpha);
module_hamilt_pw/hamilt_ofdft/kedf_lkt.cpp:                 / std::pow(prho[ir], 4.0 / 3.0) * this->s_coef_ * this->lkt_a_;
module_hamilt_pw/hamilt_ofdft/kedf_lkt.h:        this->stress.create(3, 3);
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    this->nx_ = nx;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    this->dV_ = dV;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    this->tf_weight_ = tf_weight;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:        for (int ir = 0; ir < this->nx_; ++ir)
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:        energy *= this->dV_ * this->c_tf_;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:            for (int ir = 0; ir < this->nx_; ++ir)
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:        energy *= 0.5 * this->dV_ * this->c_tf_ * this->tf_weight_;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    this->tf_energy = energy;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    Parallel_Reduce::reduce_all(this->tf_energy);
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    energyDen = this->c_tf_ * std::pow(prho[is][ir], 5. / 3.) * this->tf_weight_;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp: * and the TF energy will be calculated and stored in this->tf_energy
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:        for (int ir = 0; ir < this->nx_; ++ir)
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:            rpotential(0, ir) += 5.0 / 3.0 * this->c_tf_ * std::pow(prho[0][ir], 2. / 3.) * this->tf_weight_;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:            for (int ir = 0; ir < this->nx_; ++ir)
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:                rpotential(is, ir) += 5.0 / 3.0 * this->c_tf_ * std::pow(2. * prho[is][ir], 2. / 3.) * this->tf_weight_;
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    this->get_energy(prho);
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp: * @brief Get the stress of TF KEDF, and store it into this->stress
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:    temp = 2. * this->tf_energy / (3. * cell_vol);
module_hamilt_pw/hamilt_ofdft/kedf_tf.cpp:        this->stress(i, i) = temp;
module_hamilt_pw/hamilt_ofdft/kedf_tf.h:        this->stress.create(3, 3);
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    this->dV_ = dV;
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    this->vw_weight_ = vw_weight;
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    this->laplacian_phi(tempPhi, LapPhi, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:        energy *= this->dV_ * 0.5 * this->vw_weight_ * 2.; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:        energy *= 0.5 * this->dV_ * 0.5 * this->vw_weight_ * 2.; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    this->vw_energy = energy;
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    Parallel_Reduce::reduce_all(this->vw_energy);
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    this->laplacian_phi(tempPhi, LapPhi, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:        = 0.5 * tempPhi[is][ir] * LapPhi[is][ir] * this->vw_weight_ * 2.; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp: * and the vW energy will be calculated and stored in this->vw_energy
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    this->laplacian_phi(tempPhi, LapPhi, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:                rpotential(is, ir) += LapPhi[is][ir] * this->vw_weight_ * 2.; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:                rpotential(is, ir) += -LapPhi[is][ir] * this->vw_weight_ * 2.; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:        energy *= this->dV_ * 0.5 * this->vw_weight_ * 2.; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:        energy *= 0.5 * this->dV_ * 0.5 * this->vw_weight_ * 2.; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    this->vw_energy = energy;
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:    Parallel_Reduce::reduce_all(this->vw_energy);
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp: * @brief Get the stress of vW KEDF, and store it into this->stress
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:            this->stress(alpha, beta) = 0;
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:                    this->stress(alpha, beta) += tempPhi[is][ir] * ggPhi[ir];
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:            Parallel_Reduce::reduce_all(this->stress(alpha, beta));
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:            this->stress(alpha, beta)
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:                *= -1. * this->vw_weight_ * 2. / pw_rho->nxyz; // vw_weight * 2 to convert Hartree to Ry
module_hamilt_pw/hamilt_ofdft/kedf_vw.cpp:            this->stress(alpha, beta) = this->stress(beta, alpha);
module_hamilt_pw/hamilt_ofdft/kedf_vw.h:        this->stress.create(3, 3);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->dV_ = dV;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    // this->weightWT = weightWT;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->alpha_ = alpha;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->beta_ = beta;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->hold_rho0_ = of_hold_rho0;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        this->rho0_ = of_wt_rho0;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        this->rho0_ = 1. / (pw_rho->nxyz * dV) * nelec;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->kf_ = std::pow(3. * std::pow(ModuleBase::PI, 2) * this->rho0_, 1. / 3.);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->tkf_ = 2. * this->kf_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->wt_coef_
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        = 5. / (9. * this->alpha_ * this->beta_ * std::pow(this->rho0_, this->alpha_ + this->beta_ - 5. / 3.));
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    delete[] this->kernel_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->kernel_ = new double[pw_rho->npw];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        this->read_kernel(kernel_file, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        this->fill_kernel(tf_weight, vw_weight, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->multi_kernel(prho, kernelRhoBeta, this->beta_, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            energy += std::pow(prho[0][ir], this->alpha_) * kernelRhoBeta[0][ir];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        energy *= this->dV_ * this->c_tf_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        // energy *= 0.5 * this->dV_ * 0.5;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->wt_energy = energy;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    Parallel_Reduce::reduce_all(this->wt_energy);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->multi_kernel(prho, kernelRhoBeta, this->beta_, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    double result = this->c_tf_ * std::pow(prho[is][ir], this->alpha_) * kernelRhoBeta[is][ir];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp: * and the WT energy will be calculated and stored in this->wt_energy
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->multi_kernel(prho, kernelRhoBeta, this->beta_, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->multi_kernel(prho, kernelRhoAlpha, this->alpha_, pw_rho);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            rpotential(is, ir) += this->c_tf_
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                                  * (this->alpha_ * std::pow(prho[is][ir], this->alpha_ - 1.) * kernelRhoBeta[is][ir]
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                                     + this->beta_ * std::pow(prho[is][ir], this->beta_ - 1.) * kernelRhoAlpha[is][ir]);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            energy += std::pow(prho[0][ir], this->alpha_) * kernelRhoBeta[0][ir];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        energy *= this->dV_ * this->c_tf_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        // energy *= 0.5 * this->dV_ * 0.5;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->wt_energy = energy;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    Parallel_Reduce::reduce_all(this->wt_energy);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp: * @brief Get the stress of WT KEDF, and store it into this->stress
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    if (this->hold_rho0_)
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        mult = -1. + this->alpha_ + this->beta_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            tempRho[ir] = std::pow(prho[is][ir], this->alpha_);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            tempRho[ir] = std::pow(prho[is][ir], this->beta_);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:    this->stress.zero_out();
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            eta = sqrt(pw_rho->gg[ip]) * pw_rho->tpiba / this->tkf_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            diff = this->diff_linhard(eta, vw_weight);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                        this->stress(a, b) += -diff * pw_rho->gcar[ip][a] * pw_rho->gcar[ip][b] / pw_rho->gg[ip];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                            this->stress(a, b) += diff * coef;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            Parallel_Reduce::reduce_all(this->stress(a, b));
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                this->stress(a, b) *= -std::pow(ModuleBase::PI, 2)
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                                      / (this->alpha_ * this->beta_ * this->kf_
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                                         * std::pow(this->rho0_, this->alpha_ + this->beta_ - 2.))
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                this->stress(a, b) *= -std::pow(ModuleBase::PI, 2)
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                                      / (2. * this->alpha_ * this->beta_ * this->kf_
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:                                         * std::pow(this->rho0_, this->alpha_ + this->beta_ - 2.))
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        this->stress(a, a) += mult * this->wt_energy / pw_rho->omega;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            this->stress(a, b) = this->stress(b, a);
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            recipkernelRho[is][ip] *= this->kernel_[ip];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp: * @brief Fill the kernel (this->kernel_)
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        eta = sqrt(pw_rho->gg[ig]) * pw_rho->tpiba / this->tkf_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        this->kernel_[ig] = this->wt_kernel(eta, tf_weight, vw_weight) * this->wt_coef_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:        eta = sqrt(pw_rho->gg[ig]) * pw_rho->tpiba / this->tkf_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            this->kernel_[ig] = w0_in[0];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            this->kernel_[ig] = w0_in[nq_in - 1];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            this->kernel_[ig] = fac1 * w0_in[ind1] + fac2 * w0_in[ind2];
module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp:            this->kernel_[ig] *= this->wt_coef_;
module_hamilt_pw/hamilt_ofdft/kedf_wt.h:        this->stress.create(3, 3);
module_hamilt_pw/hamilt_ofdft/kedf_wt.h:        delete[] this->kernel_;
module_hamilt_pw/hamilt_ofdft/of_stress_pw.cpp:    stress_har(sigmahar, this->rhopw, 1, pelec->charge);
module_hamilt_pw/hamilt_ofdft/of_stress_pw.cpp:    stress_ewa(sigmaewa, this->rhopw, 1);
module_hamilt_pw/hamilt_ofdft/of_stress_pw.cpp:    stress_gga(sigmaxc, this->rhopw, pelec->charge);
module_hamilt_pw/hamilt_ofdft/of_stress_pw.cpp:    stress_loc(sigmaloc, this->rhopw, p_sf, 1, pelec->charge);
module_hamilt_pw/hamilt_ofdft/of_stress_pw.cpp:    stress_cc(sigmaxcc, this->rhopw, p_sf, 1, pelec->charge);
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:	this->allocate(rho_basis->ngg);
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:		this->zp[it] = atom->ncpp.zv;
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:			this->vloc_coulomb(this->zp[it], vloc1d, rho_basis);
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:			this->vloc_of_g(
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:		          	this->zp[it],
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:	this->print_vloc(rho_basis);
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:	this->vloc.create(GlobalC::ucell.ntype, ngg);
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:	this->numeric = new bool[GlobalC::ucell.ntype];
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:		this->numeric[it] = true; 
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:	this->zp = new double[npsx];
module_hamilt_pw/hamilt_pwdft/VL_in_pw.cpp:				   	<< std::setw(15) << this->vloc(it, ig) << std::endl;
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:		this->tab_dq.create(ntype, nbrx, GlobalV::NQX);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:		this->tab_dq.create(ntype, nbrx_nc, GlobalV::NQX);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:    gradvkb.create(3, nkb, this->wfcpw->npwk_max);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:				this->tab_dq(it, ib, iq) = vqint * pref;
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:	const int npw = this->wfcpw->npwk[ik];
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:		gk[ig] = this->wfcpw->getgpluskcar(ik,ig);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:            int nb = this->indv(it, ih);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:			    			this->tab, it, nb, GlobalV::NQX, GlobalV::DQ, gnorm );
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:			    			this->tab_dq, it, nb, GlobalV::NQX, GlobalV::DQ, gnorm );
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:                                                 + dylm[id](lm, ig) / this->wfcpw->tpiba
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:            std::complex<double> *sk = this->psf->get_sk(ik, it, ia, this->wfcpw);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:				std::complex<double>* pvkb = &this->vkb(jkb, 0);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:					std::complex<double>* pgvkb = &this->gradvkb(id, jkb, 0);
module_hamilt_pw/hamilt_pwdft/VNL_grad_pw.cpp:						// std::complex<double> dskig = ModuleBase::NEG_IMAG_UNIT * (GlobalC::ucell.atoms[it].tau[ia][id] * this->wfcpw->lat0) * skig;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    if (this->nhm <= 0 || memory_released) return;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sd_op()(gpu_ctx, this->s_deeq);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sd_op()(gpu_ctx, this->s_nhtol);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sd_op()(gpu_ctx, this->s_nhtolm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sd_op()(gpu_ctx, this->s_indv);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sd_op()(gpu_ctx, this->s_tab);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sd_op()(gpu_ctx, this->s_qq_nt);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_cd_op()(gpu_ctx, this->c_deeq_nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_cd_op()(gpu_ctx, this->c_vkb);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_cd_op()(gpu_ctx, this->c_qq_so);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_zd_op()(gpu_ctx, this->z_deeq_nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_zd_op()(gpu_ctx, this->z_qq_so);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        delmem_dd_op()(gpu_ctx, this->d_deeq);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        delmem_zd_op()(gpu_ctx, this->z_vkb);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        delmem_dd_op()(gpu_ctx, this->d_tab);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        delmem_dd_op()(gpu_ctx, this->d_indv);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        delmem_dd_op()(gpu_ctx, this->d_nhtol);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        delmem_dd_op()(gpu_ctx, this->d_nhtolm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        delmem_dd_op()(gpu_ctx, this->d_qq_nt);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sh_op()(cpu_ctx, this->s_deeq);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sh_op()(cpu_ctx, this->s_nhtol);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sh_op()(cpu_ctx, this->s_nhtolm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sh_op()(cpu_ctx, this->s_indv);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sh_op()(cpu_ctx, this->s_tab);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_sh_op()(cpu_ctx, this->s_qq_nt);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_ch_op()(cpu_ctx, this->c_deeq_nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_ch_op()(cpu_ctx, this->c_vkb);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            delmem_ch_op()(cpu_ctx, this->c_qq_so);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->wfcpw = wfc_basis;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->psf = psf_in;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->lmaxkb = -1;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->lmaxkb = std::max(this->lmaxkb, GlobalC::ucell.atoms[it].ncpp.lll[ibeta]);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->nhm = 0;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->nbetam = 0;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->nhm = std::max(nhm, GlobalC::ucell.atoms[it].ncpp.nh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->nbetam = std::max(nbetam, GlobalC::ucell.atoms[it].ncpp.nbeta);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->nkb = 0;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->nkb += GlobalC::ucell.atoms[it].ncpp.nh * GlobalC::ucell.atoms[it].na;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    if (this->nhm > 0)
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->indv.create(ntype, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->nhtol.create(ntype, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->nhtolm.create(ntype, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->nhtoj.create(ntype, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->deeq.create(GlobalV::NSPIN, GlobalC::ucell.nat, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->deeq_nc.create(GlobalV::NSPIN, GlobalC::ucell.nat, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->qq_nt.create(ntype, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->qq_so.create(ntype, 4, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sd_op()(gpu_ctx, s_deeq, GlobalV::NSPIN * GlobalC::ucell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sd_op()(gpu_ctx, s_nhtol, ntype * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sd_op()(gpu_ctx, s_nhtolm, ntype * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sd_op()(gpu_ctx, s_indv, ntype * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sd_op()(gpu_ctx, s_qq_nt, ntype * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_cd_op()(gpu_ctx, c_deeq_nc, GlobalV::NSPIN * GlobalC::ucell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_cd_op()(gpu_ctx, c_qq_so, ntype * 4 * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_zd_op()(gpu_ctx, z_deeq_nc, GlobalV::NSPIN * GlobalC::ucell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_zd_op()(gpu_ctx, z_qq_so, ntype * 4 * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            resmem_dd_op()(gpu_ctx, d_deeq, GlobalV::NSPIN * GlobalC::ucell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            resmem_dd_op()(gpu_ctx, d_indv, ntype * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            resmem_dd_op()(gpu_ctx, d_nhtol, ntype * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            resmem_dd_op()(gpu_ctx, d_nhtolm, ntype * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            resmem_dd_op()(gpu_ctx, d_qq_nt, ntype * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                               GlobalV::NSPIN * GlobalC::ucell.nat * this->nhm * this->nhm,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sh_op()(cpu_ctx, s_nhtol, ntype * this->nhm, "VNL::s_nhtol");
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sh_op()(cpu_ctx, s_nhtolm, ntype * this->nhm, "VNL::s_nhtolm");
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sh_op()(cpu_ctx, s_indv, ntype * this->nhm, "VNL::s_indv");
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_sh_op()(cpu_ctx, s_qq_nt, ntype * this->nhm * this->nhm, "VNL::s_qq_nt");
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                               GlobalV::NSPIN * GlobalC::ucell.nat * this->nhm * this->nhm,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                resmem_ch_op()(cpu_ctx, c_qq_so, ntype * 4 * this->nhm * this->nhm, "VNL::c_qq_so");
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->z_deeq_nc = this->deeq_nc.ptr;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->z_qq_so = this->qq_so.ptr;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->d_deeq = this->deeq.ptr;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->d_indv = this->indv.c;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->d_nhtol = this->nhtol.c;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->d_nhtolm = this->nhtolm.c;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->d_qq_nt = this->qq_nt.ptr;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->dvan.create(ntype, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->dvan_so.create(GlobalV::NSPIN, ntype, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->ijtoh.create(ntype, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->qq_at.create(GlobalC::ucell.nat, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->lmaxq = 2 * this->lmaxkb + 1;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    int npwx = this->wfcpw->npwk_max;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    // this->nqx = 10000;		// calculted in allocate_nlpot.f90
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->tab.create(ntype, nbetam, GlobalV::NQX);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->tab.create(ntype, nbrx_nc, GlobalV::NQX);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->qrad.create(ntype, lmaxq, nbetam * (nbetam + 1) / 2, GlobalV::NQXQ);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->tab_at.create(ntype, nwfcm, GlobalV::NQX);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            this->tab_at.create(ntype, nchix_nc, GlobalV::NQX);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            resmem_sd_op()(gpu_ctx, s_tab, this->tab.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        resmem_dd_op()(gpu_ctx, d_tab, this->tab.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            resmem_sh_op()(cpu_ctx, s_tab, this->tab.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->z_vkb = this->vkb.c;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->d_tab = this->tab.ptr;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    const int npw = this->wfcpw->npwk[ik];
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        gk[ig] = this->wfcpw->getgpluskcar(ik, ig);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->psf->get_sk(ctx, ik, this->wfcpw, sk);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                vq[ig] = ModuleBase::PolyInt::Polynomial_Interpolation(this->tab,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                if (nb == this->indv(it, ih))
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    const int npw = this->wfcpw->npwk[ik];
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    FPTYPE *vkb1 = nullptr, *gk = nullptr, *ylm = nullptr, *_tab = this->get_tab_data<FPTYPE>(),
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:           *_indv = this->get_indv_data<FPTYPE>(), *_nhtol = this->get_nhtol_data<FPTYPE>(),
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:           *_nhtolm = this->get_nhtolm_data<FPTYPE>();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        _gk[ig] = this->wfcpw->getgpluskcar(ik, ig);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->psf->get_sk(ctx, ik, this->wfcpw, sk);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                 this->wfcpw->npwk_max,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                 this->nhm,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                 this->tab.getBound2(),
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                 this->tab.getBound3(),
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    soc.fcoef.create(cell.ntype, this->nhm, this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        soc.rot_ylm(this->lmaxkb);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->dvan.zero_out();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->dvan_so.zero_out(); // added by zhengdy-soc
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->indv_ijkb0 = new int[GlobalC::ucell.nat];
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->nhtol(it, BetaIndex) = l;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->nhtolm(it, BetaIndex) = l * l + m;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->nhtoj(it, BetaIndex) = j;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->indv(it, BetaIndex) = ib;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->ijtoh(it, ih1, ih2) = -1;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->ijtoh(it, ih2, ih1) = -1;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->ijtoh(it, ih1, ih2) = ijv;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->ijtoh(it, ih2, ih1) = ijv;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->indv_ijkb0[ia] = ijkb0;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                const int l1 = this->nhtol(it, ip);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                const double j1 = this->nhtoj(it, ip);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                const int m1 = this->nhtolm(it, ip) - l1 * l1;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                    const int l2 = this->nhtol(it, ip2);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                    const double j2 = this->nhtoj(it, ip2);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                    const int m2 = this->nhtolm(it, ip2) - l2 * l2;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:							this->dvan_so(ijs,it,ip,ip2) = cell.atoms[it].ncpp.dion(ir, is) * soc.fcoef(it,is1,is2,ip,ip2);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                    if (this->nhtol(it, ip) == nhtol(it, ip2) && this->nhtolm(it, ip) == nhtolm(it, ip2))
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->dvan_so(0, it, ip, ip2) = cell.atoms[it].ncpp.dion(ir, is);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->dvan_so(3, it, ip, ip2) = cell.atoms[it].ncpp.dion(ir, is);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->dvan(it, ip, ip2) = cell.atoms[it].ncpp.dion(ir, is);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        this->compute_qrad(cell);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->radial_fft_q(1, ih, jh, it, &qnorm, ylmk0, &qgm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->qq_nt(it, ih, jh) = cell.omega * qgm.real();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                                this->qq_so(it, ijs, kh, lh) += cell.omega * qgm.real()
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->radial_fft_q(1, ih, jh, it, &qnorm, ylmk0, &qgm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->qq_so(it, 0, ih, jh) = cell.omega * qgm.real();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->qq_so(it, 0, jh, ih) = this->qq_so(it, 0, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->qq_so(it, 3, ih, jh) = this->qq_so(it, 0, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->qq_so(it, 3, jh, ih) = this->qq_so(it, 0, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->qq_nt(it, ih, jh) = cell.omega * qgm.real();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->qq_nt(it, jh, ih) = cell.omega * qgm.real();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    MPI_Allreduce(MPI_IN_PLACE, this->qq_nt.ptr, this->qq_nt.getSize(), MPI_DOUBLE, MPI_SUM, POOL_WORLD);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    MPI_Allreduce(MPI_IN_PLACE, this->qq_so.ptr, this->qq_so.getSize(), MPI_DOUBLE_COMPLEX, MPI_SUM, POOL_WORLD);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->qq_at(ia, ih, jh) = qq_nt(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->qq_at(ia, jh, ih) = qq_nt(it, jh, ih);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    this->tab.zero_out();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                this->tab(it, ib, iq) = vqint * pref;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_indv, this->indv.c, this->indv.nr * this->indv.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_nhtol, this->nhtol.c, this->nhtol.nr * this->nhtol.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_nhtolm, this->nhtolm.c, this->nhtolm.nr * this->nhtolm.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_tab, this->tab.ptr, this->tab.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2d_op()(gpu_ctx, cpu_ctx, this->s_qq_nt, this->qq_nt.ptr, this->qq_nt.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_z2c_h2d_op()(gpu_ctx, cpu_ctx, this->c_qq_so, this->qq_so.ptr, this->qq_so.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            syncmem_z2z_h2d_op()(gpu_ctx, cpu_ctx, this->z_qq_so, this->qq_so.ptr, this->qq_so.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_indv, this->indv.c, this->indv.nr * this->indv.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_nhtol, this->nhtol.c, this->nhtol.nr * this->nhtol.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_nhtolm, this->nhtolm.c, this->nhtolm.nr * this->nhtolm.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_tab, this->tab.ptr, this->tab.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        syncmem_d2d_h2d_op()(gpu_ctx, cpu_ctx, this->d_qq_nt, this->qq_nt.ptr, this->qq_nt.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_indv, this->indv.c, this->indv.nr * this->indv.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_nhtol, this->nhtol.c, this->nhtol.nr * this->nhtol.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_nhtolm, this->nhtolm.c, this->nhtolm.nr * this->nhtolm.nc);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_tab, this->tab.ptr, this->tab.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_d2s_h2h_op()(cpu_ctx, cpu_ctx, this->s_qq_nt, this->qq_nt.ptr, this->qq_nt.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:            castmem_z2c_h2h_op()(cpu_ctx, cpu_ctx, this->c_qq_so, this->qq_so.ptr, this->qq_so.getSize());
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    for (int lm = 0; lm < this->lpx(ivl, jvl); lm++)
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        int lp = this->lpl(ivl, jvl, lm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        pref = pow(ModuleBase::NEG_IMAG_UNIT, l) * this->ap(lp, ivl, jvl);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                work = ModuleBase::PolyInt::Polynomial_Interpolation(this->qrad,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    for (int lm = 0; lm < this->lpx(ivl, jvl); lm++)
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        int lp = this->lpl(ivl, jvl, lm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:        pref = static_cast<std::complex<FPTYPE>>(pow(ModuleBase::NEG_IMAG_UNIT, l) * this->ap(lp, ivl, jvl));
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                work = ModuleBase::PolyInt::Polynomial_Interpolation(this->qrad,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:// 	const int npw = this->wfcpw->npwk[ik];
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:// 		gk[ig] = this->wfcpw->getgpluskcar(ik,ig);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:// 			vkb_alpha[i][j] = new std::complex<double>[this->wfcpw->npwk_max];
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:// 							this->tab_alpha, it, nb, L, GlobalV::NQX, GlobalV::DQ, gnorm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:// 			std::complex<double> *sk = this->psf->get_sk(ik, it, ia,this->wfcpw);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:				this->nhtol(it,BetaIndex) = l;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:				this->nhtolm(it,BetaIndex) = l*l + m;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:				this->indv(it,BetaIndex) = ib;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:	this->tab_alpha.create(GlobalC::ucell.ntype, nbrx, lmaxkb+2, GlobalV::NQX);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:	this->tab_alpha.zero_out();
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:					this->tab_alpha(it, ib, L, iq) = vqint * pref;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->deeq_nc(is, iat, ih, jh) = this->dvan_so(is, it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->deeq_nc(is, iat, jh, ih) = this->dvan_so(is, it, jh, ih);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, ih, jh) = this->dvan(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, jh, ih) = this->dvan(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, ih, jh) = std::complex<double>(0.0, 0.0);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, jh, ih) = std::complex<double>(0.0, 0.0);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, ih, jh) = std::complex<double>(0.0, 0.0);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, jh, ih) = std::complex<double>(0.0, 0.0);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, ih, jh) = this->dvan(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->deeq_nc(is, iat, jh, ih) = this->dvan(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->deeq(is, iat, ih, jh) = this->dvan(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            this->deeq(is, iat, jh, ih) = this->dvan(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            if (ih != jh && std::fabs(this->deeq(is, iat, ih, jh)) > 0.0)
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                this->multi_proj = true;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                    this->newd_so(iat, cell);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                    this->newd_nc(iat, cell);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                            deeq(is, iat, ih, jh) += this->dvan(it, ih, jh);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->s_deeq,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->deeq.ptr,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 GlobalV::NSPIN * cell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->c_deeq_nc,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->deeq_nc.ptr,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 GlobalV::NSPIN * cell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->z_deeq_nc,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->deeq_nc.ptr,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 GlobalV::NSPIN * cell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                             this->d_deeq,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                             this->deeq.ptr,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                             GlobalV::NSPIN * cell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->s_deeq,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->deeq.ptr,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 GlobalV::NSPIN * cell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->c_deeq_nc,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 this->deeq_nc.ptr,
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:                                 GlobalV::NSPIN * cell.nat * this->nhm * this->nhm);
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->s_nhtol;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->d_nhtol;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->s_nhtolm;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->d_nhtolm;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->s_indv;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->d_indv;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->s_tab;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->d_tab;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->s_deeq;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->d_deeq;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->s_qq_nt;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->d_qq_nt;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->c_vkb;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->z_vkb;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->c_deeq_nc;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->z_deeq_nc;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->c_qq_so;
module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp:    return this->z_qq_so;
module_hamilt_pw/hamilt_pwdft/forces.cpp:    this->device = psi::device::get_device_type<Device>(this->ctx);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        this->cal_force_loc(forcelc, rho_basis, chr);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    this->cal_force_ew(forceion, rho_basis, p_sf);
module_hamilt_pw/hamilt_pwdft/forces.cpp:            this->npwx = wfc_basis->npwk_max;
module_hamilt_pw/hamilt_pwdft/forces.cpp:            this->cal_force_nl(forcenl, wg, ekb, pkv, wfc_basis, psi_in);
module_hamilt_pw/hamilt_pwdft/forces.cpp:                this->cal_force_us(forcenl, rho_basis, &GlobalC::ppcell, elec, GlobalC::ucell);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        this->cal_force_cc(forcecc, rho_basis, chr);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        this->cal_force_scc(forcescc, rho_basis, elec.vnew, elec.vnew_exist);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        for (int iat = 0; iat < this->nat; ++iat)
module_hamilt_pw/hamilt_pwdft/forces.cpp:        force_e.create(this->nat, 3);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        force_gate.create(this->nat, 3);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        forcesol.create(this->nat, 3);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        force_paw = new double[3 * this->nat];
module_hamilt_pw/hamilt_pwdft/forces.cpp:        for(int iat = 0; iat < this->nat; iat++)
module_hamilt_pw/hamilt_pwdft/forces.cpp:            double compen = sum / this->nat;
module_hamilt_pw/hamilt_pwdft/forces.cpp:            for (int iat = 0; iat < this->nat; ++iat)
module_hamilt_pw/hamilt_pwdft/forces.cpp:        for (int iat = 0; iat < this->nat; iat++)
module_hamilt_pw/hamilt_pwdft/forces.cpp:        for (int iat = 0; iat < this->nat; iat++)
module_hamilt_pw/hamilt_pwdft/forces.cpp:            for(int iat=0; iat<this->nat; iat++)
module_hamilt_pw/hamilt_pwdft/forces.cpp:    for (int iat = 0; iat < this->nat; ++iat)
module_hamilt_pw/hamilt_pwdft/forces.cpp:    // this->print(GlobalV::ofs_running, "local forces", forcelc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        ModuleBase::TASK_DIST_1D(num_threads, thread_id, this->nat, iat_beg, iat_end);
module_hamilt_pw/hamilt_pwdft/forces.cpp:                while (iat2 < this->nat)
module_hamilt_pw/hamilt_pwdft/forces.cpp:    // this->print(GlobalV::ofs_running, "ewald forces", forceion);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    resmem_complex_op()(this->ctx, becp, GlobalV::NBANDS * nkb, "Force::becp");
module_hamilt_pw/hamilt_pwdft/forces.cpp:    resmem_complex_op()(this->ctx, dbecp, 3 * GlobalV::NBANDS * nkb, "Force::dbecp");
module_hamilt_pw/hamilt_pwdft/forces.cpp:    // ModuleBase::ComplexMatrix vkb1(nkb, this->npwx);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    resmem_complex_op()(this->ctx, vkb1, this->npwx * nkb, "Force::vkb1");
module_hamilt_pw/hamilt_pwdft/forces.cpp:    if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/forces.cpp:        resmem_var_op()(this->ctx, d_wg, wg.nr * wg.nc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        resmem_var_op()(this->ctx, d_ekb, ekb.nr * ekb.nc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        resmem_var_op()(this->ctx, force, forcenl.nr * forcenl.nc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        resmem_var_op()(this->ctx, gcar, 3 * wfc_basis->nks * wfc_basis->npwk_max);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, d_wg, wg.c, wg.nr * wg.nc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, d_ekb, ekb.c, ekb.nr * ekb.nc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, force, forcenl.c, forcenl.nr * forcenl.nc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        syncmem_var_h2d_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:                             this->cpu_ctx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:        resmem_int_op()(this->ctx, atom_nh, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        resmem_int_op()(this->ctx, atom_na, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        syncmem_int_h2d_op()(this->ctx, this->cpu_ctx, atom_nh, h_atom_nh, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        syncmem_int_h2d_op()(this->ctx, this->cpu_ctx, atom_na, h_atom_na, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        gemm_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:                  this->npwx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:                  this->npwx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:        if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/forces.cpp:            resmem_complex_h_op()(this->cpu_ctx, h_becp, GlobalV::NBANDS * nkb);
module_hamilt_pw/hamilt_pwdft/forces.cpp:            syncmem_complex_d2h_op()(this->cpu_ctx, this->ctx, h_becp, becp, GlobalV::NBANDS * nkb);
module_hamilt_pw/hamilt_pwdft/forces.cpp:            syncmem_complex_h2d_op()(this->ctx, this->cpu_ctx, becp, h_becp, GlobalV::NBANDS * nkb);
module_hamilt_pw/hamilt_pwdft/forces.cpp:            delmem_complex_h_op()(this->cpu_ctx, h_becp);
module_hamilt_pw/hamilt_pwdft/forces.cpp:            cal_vkb1_nl_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:                             this->npwx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:            gemm_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:                      this->npwx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:                      this->npwx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:        cal_force_nl_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/forces.cpp:    if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/forces.cpp:        syncmem_var_d2h_op()(this->cpu_ctx, this->ctx, forcenl.c, force, forcenl.nr * forcenl.nc);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    delmem_complex_op()(this->ctx, vkb1);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    delmem_complex_op()(this->ctx, becp);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    delmem_complex_op()(this->ctx, dbecp);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/forces.cpp:        delmem_var_op()(this->ctx, d_wg);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        delmem_var_op()(this->ctx, d_ekb);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        delmem_var_op()(this->ctx, gcar);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        delmem_var_op()(this->ctx, force);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        delmem_int_op()(this->ctx, atom_nh);
module_hamilt_pw/hamilt_pwdft/forces.cpp:        delmem_int_op()(this->ctx, atom_na);
module_hamilt_pw/hamilt_pwdft/forces.cpp:    //  this->print(GlobalV::ofs_running, "nonlocal forces", forcenl);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->classname = "HamiltPW";
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->ppcell = &GlobalC::ppcell;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->qq_nt = this->ppcell->template get_qq_nt_data<Real>();
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->qq_so = this->ppcell->template get_qq_so_data<Real>();
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->vkb = this->ppcell->template get_vkb_data<Real>();
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        if(this->ops == nullptr)
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            this->ops = ekinetic;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            this->ops->add(ekinetic);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            if(this->ops == nullptr)
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops = veff;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops->add(veff);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            this->ops->add(meta);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        if(this->ops == nullptr)
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            this->ops = nonlocal;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            this->ops->add(nonlocal);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    if(this->ops!= nullptr)
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        delete this->ops;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->ops->init(ik);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->classname = hamilt->classname;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->ppcell = hamilt->ppcell;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->qq_nt = hamilt->qq_nt;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->qq_so = hamilt->qq_so;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    this->vkb = hamilt->vkb;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            if(this->ops == nullptr) {
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops = ekinetic;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops->add(ekinetic);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            // this->ops = reinterpret_cast<Operator<T, Device>*>(node);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            if(this->ops == nullptr) {
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops = nonlocal;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops->add(nonlocal);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            if(this->ops == nullptr) {
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops = veff;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops->add(veff);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            if(this->ops == nullptr) {
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops = meta;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                this->ops->add(meta);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:    syncmem_op()(this->ctx, this->ctx, spsi, psi_in, static_cast<size_t>(nbands * nrow));
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        if (this->ppcell->nkb > 0)
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            resmem_complex_op()(this->ctx, becp, nbands * this->ppcell->nkb, "Hamilt<PW>::becp");
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                gemv_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->vkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                gemm_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->vkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->nkb);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:            Parallel_Reduce::reduce_pool(becp, this->ppcell->nkb * nbands);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        resmem_complex_op()(this->ctx, ps, this->ppcell->nkb * nbands, "Hamilt<PW>::ps");
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        setmem_complex_op()(this->ctx, ps, 0, this->ppcell->nkb * nbands);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                    resmem_complex_op()(this->ctx, qqc, nh * nh, "Hamilt<PW>::qqc");
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                    Real* qq_now = &qq_nt[it * this->ppcell->nhm * this->ppcell->nhm];
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                            int index = i * this->ppcell->nhm + j;
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                        gemm_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                                  &becp[this->ppcell->indv_ijkb0[iat]],
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                                  this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                                  &ps[this->ppcell->indv_ijkb0[iat]],
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                                  this->ppcell->nkb);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                gemv_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->vkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                gemm_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->vkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:                          this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        delmem_complex_op()(this->ctx, ps);
module_hamilt_pw/hamilt_pwdft/hamilt_pw.cpp:        delmem_complex_op()(this->ctx, becp);
module_hamilt_pw/hamilt_pwdft/kernels/meta_op.h:        /// out = hpsi * (wfcpw->gcar+wfcpw->kvec_c) * this->tpiba;
module_hamilt_pw/hamilt_pwdft/kernels/test/veff_op_test.cpp:    veff_cpu_op()(cpu_ctx, this->size, res.data(), in.data());
module_hamilt_pw/hamilt_pwdft/kernels/test/veff_op_test.cpp:        in_[ii] = in_spin.data() + ii * this->size;
module_hamilt_pw/hamilt_pwdft/kernels/test/veff_op_test.cpp:    veff_cpu_op()(cpu_ctx, this->size, res.data(), res1.data(), in_);
module_hamilt_pw/hamilt_pwdft/kernels/test/veff_op_test.cpp:    veff_gpu_op()(gpu_ctx, this->size, d_res, d_in);
module_hamilt_pw/hamilt_pwdft/kernels/test/veff_op_test.cpp:        in_[ii] = d_in + ii * this->size;
module_hamilt_pw/hamilt_pwdft/kernels/test/veff_op_test.cpp:    veff_gpu_op()(gpu_ctx, this->size, d_res, d_res1, in_);
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  this->classname = "Ekinetic";
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  this->cal_type = pw_ekinetic;
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  this->tpiba2 = tpiba2_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  this->gk2 = gk2_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  this->gk2_row = gk2_row;
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  this->gk2_col = gk2_col;
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  this->device = psi::device::get_device_type<Device>(this->ctx);
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  if( this->tpiba2 < 1e-10 || this->gk2 == nullptr) {
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  const Real *gk2_ik = &(this->gk2[this->ik * this->gk2_col]);
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:  ekinetic_op()(this->ctx, nbands, ngk_ik, max_npw, tpiba2, gk2_ik, tmhpsi, tmpsi_in);
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->classname = "Ekinetic";
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->cal_type = pw_ekinetic;
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->ik = ekinetic->get_ik();
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->tpiba2 = ekinetic->get_tpiba2();
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->gk2 = ekinetic->get_gk2();
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->gk2_row = ekinetic->get_gk2_row();
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->gk2_col = ekinetic->get_gk2_col();
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    this->device = psi::device::get_device_type<Device>(this->ctx);
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.cpp:    if( this->tpiba2 < 1e-10 || this->gk2 == nullptr) {
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.h:    int get_gk2_row() const {return this->gk2_row;}
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.h:    int get_gk2_col() const {return this->gk2_col;}
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.h:    Real get_tpiba2() const {return this->tpiba2;}
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.h:    const Real* get_gk2() const {return this->gk2;}
module_hamilt_pw/hamilt_pwdft/operator_pw/ekinetic_pw.h:    Device* get_ctx() const {return this->ctx;}
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->classname = "Meta";
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->cal_type = pw_meta;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->isk = isk_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->tpiba = tpiba_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->vk = vk_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->vk_row = vk_row;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->vk_col = vk_col;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->wfcpw = wfcpw_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    resmem_complex_op()(this->ctx, this->porter, this->wfcpw->nmaxgr, "Meta<PW>::porter");
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    if(this->isk == nullptr || this->tpiba < 1e-10 || this->wfcpw == nullptr)
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    delmem_complex_op()(this->ctx, this->porter);
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    const int current_spin = this->isk[this->ik];
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:            meta_op()(this->ctx, this->ik, j, ngk_ik, this->wfcpw->npwk_max, this->tpiba, wfcpw->get_gcar_data<Real>(), wfcpw->get_kvec_c_data<Real>(), tmpsi_in, this->porter);
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:            wfcpw->recip_to_real(this->ctx, this->porter, this->porter, this->ik);
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:            if(this->vk_col != 0) {
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:                vector_mul_vector_op()(this->ctx, this->vk_col, this->porter, this->porter, this->vk + current_spin * this->vk_col);
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:            wfcpw->real_to_recip(this->ctx, this->porter, this->porter, this->ik);
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:            meta_op()(this->ctx, this->ik, j, ngk_ik, this->wfcpw->npwk_max, this->tpiba, wfcpw->get_gcar_data<Real>(), wfcpw->get_kvec_c_data<Real>(), this->porter, tmhpsi, true);
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->classname = "Meta";
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->cal_type = pw_meta;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->ik = meta->get_ik();
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->isk = meta->get_isk();
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->tpiba = meta->get_tpiba();
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->vk = meta->get_vk();
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->vk_row = meta->get_vk_row();
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->vk_col = meta->get_vk_col();
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    this->wfcpw = meta->get_wfcpw();
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.cpp:    if(this->isk == nullptr || this->tpiba < 1e-10 || this->vk == nullptr || this->wfcpw == nullptr)
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.h:          return this->tpiba;
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.h:    const int * get_isk() const {return this->isk;}
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.h:    const Real* get_vk() const {return this->vk;}
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.h:    int get_vk_row() const {return this->vk_row;}
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.h:    int get_vk_col() const {return this->vk_col;}
module_hamilt_pw/hamilt_pwdft/operator_pw/meta_pw.h:          return this->wfcpw;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->classname = "Nonlocal";
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->cal_type = pw_nonlocal;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->wfcpw = wfc_basis;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->isk = isk_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->ppcell = ppcell_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->ucell = ucell_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->deeq = this->ppcell->template get_deeq_data<Real>();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->deeq_nc = this->ppcell->template get_deeq_nc_data<Real>();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->vkb = this->ppcell->template get_vkb_data<Real>();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    if( this->isk == nullptr || this->ppcell == nullptr || this->ucell == nullptr)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    delmem_complex_op()(this->ctx, this->ps);
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    delmem_complex_op()(this->ctx, this->becp);
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->ik = ik_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:	if(this->ppcell->nkb > 0) //xiaohui add 2013-09-02. Attention...
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:		this->ppcell->getvnl(this->ctx, this->ik, this->vkb);
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    if(this->next_op != nullptr)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->next_op->init(ik_in);
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    int nkb = this->ppcell->nkb;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    if (this->nkb_m < m * nkb) {
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        resmem_complex_op()(this->ctx, this->ps, nkb * m, "Nonlocal<PW>::ps");
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->nkb_m = m * nkb;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    setmem_complex_op()(this->ctx, this->ps, 0, nkb * m);
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    if (this->npol == 1)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        const int current_spin = this->isk[this->ik];
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        for (int it = 0; it < this->ucell->ntype; it++)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            const int nproj = this->ucell->atoms[it].ncpp.nh;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ctx,   // device context
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ucell->atoms[it].na, m, nproj, // four loop size
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ppcell->deeq.getBound2(), this->ppcell->deeq.getBound3(), this->ppcell->deeq.getBound4(), // realArray operator()
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->deeq, // array of data
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ps, this->becp); //  array of data
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            // for (int ia = 0; ia < this->ucell->atoms[it].na; ia++)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            //                 this->ps[(sum + ip2) * m + ib]
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            //                     += this->ppcell->deeq(current_spin, iat, ip, ip2) * this->becp[ib * nkb + sum + ip];
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        for (int it = 0; it < this->ucell->ntype; it++)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            const int nproj = this->ucell->atoms[it].ncpp.nh;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ctx,   // device context
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ucell->atoms[it].na, m, nproj, // four loop size
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ppcell->deeq_nc.getBound2(), this->ppcell->deeq_nc.getBound3(), this->ppcell->deeq_nc.getBound4(), // realArray operator()
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->deeq_nc, // array of data
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                this->ps, this->becp); //  array of data
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            // for (int ia = 0; ia < this->ucell->atoms[it].na; ia++)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            //                 ps[psind] += this->ppcell->deeq_nc(0, iat, ip2, ip) * becp1
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            //                              + this->ppcell->deeq_nc(1, iat, ip2, ip) * becp2;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            //                 ps[psind + 1] += this->ppcell->deeq_nc(2, iat, ip2, ip) * becp1
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            //                                  + this->ppcell->deeq_nc(3, iat, ip2, ip) * becp2;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ctx,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->npw,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            &this->one,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->vkb,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ps,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            &this->one,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ctx,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->npw,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ppcell->nkb,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            &this->one,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->vkb,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->ps,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            &this->one,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->max_npw
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->npw = ngk_ik;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->max_npw = nbasis / npol;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->npol = npol;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        if (this->ppcell->nkb > 0)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            int nkb = this->ppcell->nkb;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            if (this->nkb_m < nbands * nkb) {
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                resmem_complex_op()(this->ctx, this->becp, nbands * nkb, "Nonlocal<PW>::becp");
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->ctx,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->npw,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    &this->one,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->vkb,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    &this->zero,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->becp,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->ctx,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->npw,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    &this->one,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->vkb,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->ppcell->vkb.nc,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    &this->zero,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:                    this->becp,
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:            this->add_nonlocal_pp(tmhpsi, becp, nbands);
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->npw = ngk_ik;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->max_npw = nbasis / npol;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:        this->npol = npol;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->classname = "Nonlocal";
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->cal_type = pw_nonlocal;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->ik = nonlocal->get_ik();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->isk = nonlocal->get_isk();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->ppcell = nonlocal->get_ppcell();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->ucell = nonlocal->get_ucell();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->deeq = this->ppcell->d_deeq;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->deeq_nc = this->ppcell->template get_deeq_nc_data<Real>();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    this->vkb = this->ppcell->template get_vkb_data<Real>();
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.cpp:    if( this->isk == nullptr || this->ppcell == nullptr || this->ucell == nullptr)
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.h:    const int *get_isk() const {return this->isk;}
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.h:    const pseudopot_cell_vnl *get_ppcell() const {return this->ppcell;}
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.h:    const UnitCell *get_ucell() const {return this->ucell;}
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.h:        return this->vkb;
module_hamilt_pw/hamilt_pwdft/operator_pw/nonlocal_pw.h:        return this->becp;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->classname = "Veff";
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->cal_type = pw_veff;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->isk = isk_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->veff = veff_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->veff_row = veff_row;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->veff_col = veff_col;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->wfcpw = wfcpw_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    resmem_complex_op()(this->ctx, this->porter, this->wfcpw->nmaxgr, "Veff<PW>::porter");
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    resmem_complex_op()(this->ctx, this->porter1, this->wfcpw->nmaxgr, "Veff<PW>::porter1");
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    if (this->isk == nullptr || this->wfcpw == nullptr) {
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    delmem_complex_op()(this->ctx, this->porter);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    delmem_complex_op()(this->ctx, this->porter1);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    const int current_spin = this->isk[this->ik];
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            // wfcpw->recip2real(tmpsi_in, porter, this->ik);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            wfcpw->recip_to_real(this->ctx, tmpsi_in, this->porter, this->ik);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            if(this->veff_col != 0)
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                veff_op()(this->ctx, this->veff_col, this->porter, this->veff + current_spin * this->veff_col);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                // const Real* current_veff = &(this->veff[0](current_spin, 0));
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                // for (int ir = 0; ir < this->veff->nc; ++ir)
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            // wfcpw->real2recip(porter, tmhpsi, this->ik, true);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            wfcpw->real_to_recip(this->ctx, this->porter, tmhpsi, this->ik, true);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            wfcpw->recip_to_real(this->ctx, tmpsi_in, this->porter, this->ik);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            wfcpw->recip_to_real(this->ctx, tmpsi_in + max_npw, this->porter1, this->ik);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            if(this->veff_col != 0)
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                    current_veff[is] = this->veff + is * this->veff_col ; // for CPU device
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                veff_op()(this->ctx, this->veff_col, this->porter, this->porter1, current_veff);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                // for (int ir = 0; ir < this->veff_col; ir++) {
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                //     sup = this->porter[ir] * (current_veff[0][ir] + current_veff[3][ir])
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                //         + this->porter1[ir]
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                //     sdown = this->porter1[ir] * (current_veff[0][ir] - current_veff[3][ir])
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                //             + this->porter[ir]
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                //     this->porter[ir] = sup;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:                //     this->porter1[ir] = sdown;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            wfcpw->real_to_recip(this->ctx, this->porter, tmhpsi, this->ik, true);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:            wfcpw->real_to_recip(this->ctx, this->porter1, tmhpsi + max_npw, this->ik, true);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->classname = "Veff";
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->cal_type = pw_veff;
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->ik = veff->get_ik();
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->isk = veff->get_isk();
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->veff_col = veff->get_veff_col();
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->veff_row = veff->get_veff_row();
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->wfcpw = veff->get_wfcpw();
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    resmem_complex_op()(this->ctx, this->porter, this->wfcpw->nmaxgr);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    resmem_complex_op()(this->ctx, this->porter1, this->wfcpw->nmaxgr);
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    this->veff = veff->get_veff();
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.cpp:    if (this->isk == nullptr || this->veff == nullptr || this->wfcpw == nullptr) {
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.h:    const Real *get_veff() const {return this->veff;}
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.h:    int get_veff_col() const {return this->veff_col;}
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.h:    int get_veff_row() const { return this->veff_row; }
module_hamilt_pw/hamilt_pwdft/operator_pw/veff_pw.h:        return this->wfcpw;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    this->wfcpw = wfcpw_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    this->isk = isk_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    this->ppcell = ppcell_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    this->ucell = ucell_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    this->nonlocal = nonlocal_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    if( this->wfcpw == nullptr || this->isk == nullptr || this->ppcell == nullptr || this->ucell == nullptr)
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    this->tpiba = ucell_in -> tpiba;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    if(this->nonlocal)      this->ppcell->initgradq_vnl(*this->ucell);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    this->ik = ik_in;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:	if(this->ppcell->nkb > 0 && this->nonlocal) 
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:        this->ppcell->getgradq_vnl(ik_in);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    const int npw = psi_in->get_ngk(this->ik);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:            const ModuleBase::Vector3<double>& tmpg = wfcpw->getgpluskcar(this->ik, ig);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    if (this->ppcell->nkb <= 0 || !this->nonlocal) 
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:    const int nkb = this->ppcell->nkb;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:               &ModuleBase::ONE, this->ppcell->vkb.c, &max_npw, psi0, &inc, 
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:               &ModuleBase::ONE, this->ppcell->gradvkb.ptr, &max_npw, psi0, &inc, 
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:               &ModuleBase::ONE, this->ppcell->vkb.c, &max_npw, psi0, &max_npw,
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:               &ModuleBase::ONE, this->ppcell->gradvkb.ptr, &max_npw, psi0, &max_npw,
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:        const int current_spin = this->isk[ik];
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:        for (int it = 0; it < this->ucell->ntype; it++)
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:            const int nproj = this->ucell->atoms[it].ncpp.nh;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:            for (int ia = 0; ia < this->ucell->atoms[it].na; ia++)
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:                            double dij = this->ppcell->deeq(current_spin, iat, ip, ip2);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:        for (int it = 0; it < this->ucell->ntype; it++)
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:            const int nproj = this->ucell->atoms[it].ncpp.nh;
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:            for (int ia = 0; ia < this->ucell->atoms[it].na; ia++)
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:                            std::complex<double> dij0 = this->ppcell->deeq_nc(0, iat, ip2, ip);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:                            std::complex<double> dij1 = this->ppcell->deeq_nc(1, iat, ip2, ip);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:                            std::complex<double> dij2 = this->ppcell->deeq_nc(2, iat, ip2, ip);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:                            std::complex<double> dij3 = this->ppcell->deeq_nc(3, iat, ip2, ip);
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:                   &ModuleBase::ONE, this->ppcell->gradvkb.ptr + vkbshift, &max_npw, ps1.c, &inc,
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:                   &ModuleBase::ONE, this->ppcell->vkb.c, &max_npw, ps2.c + ps2shift, &inc,
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:               &ModuleBase::ONE, this->ppcell->gradvkb.ptr + vkbshift, &max_npw, ps1.c, &n_npwx,
module_hamilt_pw/hamilt_pwdft/operator_pw/velocity_pw.cpp:               &ModuleBase::ONE, this->ppcell->vkb.c, &max_npw, ps2.c + ps2shift, &n_npwx,
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:    this->allocate = false;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:    this->allocate_final_scf = false; //LiuXh add 20180619
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	if(this->allocate || this->allocate_final_scf) //LiuXh add 20180619
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncx = ncx_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncy = ncy_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncz = ncz_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nczp = nczp_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nrxx = nrxx_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nbz = nbz_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->bz = bz_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncxy = ncx * ncy;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncxyz = ncxy * ncz;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:    if(this->allocate)
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:        this->allocate = false;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nproc_in_pool = new int[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		if(i<remain_pro) this->nproc_in_pool[i]++;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->numz = new int*[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->startz = new int*[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->whichpro = new int*[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		this->numz[ip] = new int[nproc];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		this->startz[ip] = new int[nproc];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		this->whichpro[ip] = new int[this->ncz];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		ModuleBase::GlobalFunc::ZEROS(this->numz[ip], nproc);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		ModuleBase::GlobalFunc::ZEROS(this->startz[ip], nproc);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		ModuleBase::GlobalFunc::ZEROS(this->whichpro[ip], this->ncz);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->allocate = true;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->z_distribution();
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		this->zpiece_to_stogroup(zpiece,iz,rho);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	const int znow = iz - this->startz[GlobalV::MY_POOL][GlobalV::RANK_IN_POOL];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	const int proc = this->whichpro[GlobalV::MY_POOL][iz];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:				MPI_Send(zpiece, ncxy, MPI_DOUBLE, this->whichpro[ipool][iz], iz, MPI_COMM_WORLD);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:				MPI_Send(zpiece, ncxy, MPI_DOUBLE, this->whichpro[ipool][iz], iz, MPI_COMM_WORLD);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	const int znow = iz - this->startz[GlobalV::MY_POOL][GlobalV::RANK_IN_POOL];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	const int proc = this->whichpro[GlobalV::MY_POOL][iz];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:				MPI_Send(zpiece, ncxy, MPI_DOUBLE, this->whichpro[ipool][iz], iz, STO_WORLD);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:				MPI_Send(zpiece, ncxy, MPI_DOUBLE, this->whichpro[ipool][iz], iz, STO_WORLD);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	double* zpiece = new double[this->ncxy];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	for(int iz=0; iz<this->ncz; iz++)
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		const int znow = iz - this->startz[GlobalV::MY_POOL][GlobalV::RANK_IN_POOL];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		const int proc = this->whichpro[GlobalV::MY_POOL][iz];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		ModuleBase::GlobalFunc::ZEROS(zpiece, this->ncxy);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:				zpiece[ir] = rhoin[ir*this->nczp + znow];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:				zpiece[ir] = rhoin[ir*this->nczp + znow];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:			for(int ix=0; ix<this->ncx; ix++)
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:				for(int iy=0; iy<this->ncy; iy++)
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:					const int ir = ix * this->ncy + iy;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncx = ncx_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncy = ncy_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncz = ncz_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nczp = nczp_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nrxx = nrxx_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nbz = nbz_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->bz = bz_in;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncxy = ncx * ncy;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->ncxyz = ncxy * ncz;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->nproc_in_pool = new int[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		if(i<remain_pro) this->nproc_in_pool[i]++;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->numz = new int*[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->startz = new int*[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->whichpro = new int*[GlobalV::KPAR];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		this->numz[ip] = new int[nproc];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		this->startz[ip] = new int[nproc];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		this->whichpro[ip] = new int[this->ncz];
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		ModuleBase::GlobalFunc::ZEROS(this->numz[ip], nproc);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		ModuleBase::GlobalFunc::ZEROS(this->startz[ip], nproc);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:		ModuleBase::GlobalFunc::ZEROS(this->whichpro[ip], this->ncz);
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->allocate_final_scf = true;
module_hamilt_pw/hamilt_pwdft/parallel_grid.cpp:	this->z_distribution();
module_hamilt_pw/hamilt_pwdft/soc.cpp:    if (this->p != nullptr)
module_hamilt_pw/hamilt_pwdft/soc.cpp:        if (this->p != nullptr)
module_hamilt_pw/hamilt_pwdft/soc.cpp:            delete[] this->p;
module_hamilt_pw/hamilt_pwdft/soc.cpp:            this->p = nullptr;
module_hamilt_pw/hamilt_pwdft/soc.cpp:        this->p = new std::complex<double>[tot];
module_hamilt_pw/hamilt_pwdft/soc.cpp:            this->p[i] = std::complex<double>(0.0, 0.0);
module_hamilt_pw/hamilt_pwdft/soc.cpp:    if (this->p_rot != nullptr)
module_hamilt_pw/hamilt_pwdft/soc.cpp:    this->l_max_ = lmax;
module_hamilt_pw/hamilt_pwdft/soc.cpp:    this->l2plus1_ = 2 * l_max_ + 1;
module_hamilt_pw/hamilt_pwdft/soc.cpp:    if (this->p_rot != nullptr)
module_hamilt_pw/hamilt_pwdft/soc.cpp:        delete[] this->p_rot;
module_hamilt_pw/hamilt_pwdft/soc.cpp:        this->p_rot = nullptr;
module_hamilt_pw/hamilt_pwdft/soc.cpp:    this->p_rot = new std::complex<double>[l2plus1_ * l2plus1_];
module_hamilt_pw/hamilt_pwdft/soc.cpp:    this->p_rot[l_max_] = std::complex<double>(1.0, 0.0);
module_hamilt_pw/hamilt_pwdft/soc.cpp:        this->p_rot[l2plus1_ * i + n] = std::complex<double>(pow(-1.0, m) / sqrt(2), 0.0);
module_hamilt_pw/hamilt_pwdft/soc.cpp:        this->p_rot[l2plus1_ * (i + 1) + n] = std::complex<double>(0.0, -pow(-1.0, m) / sqrt(2));
module_hamilt_pw/hamilt_pwdft/soc.cpp:        this->p_rot[l2plus1_ * i + n] = std::complex<double>(1.0 / sqrt(2), 0.0);
module_hamilt_pw/hamilt_pwdft/soc.cpp:        this->p_rot[l2plus1_ * (i + 1) + n] = std::complex<double>(0.0, 1.0 / sqrt(2));
module_hamilt_pw/hamilt_pwdft/soc.cpp:        const int mi = sph_ind(l1, j1, m, is1) + this->l_max_;
module_hamilt_pw/hamilt_pwdft/soc.cpp:        const int mj = sph_ind(l2, j2, m, is2) + this->l_max_;
module_hamilt_pw/hamilt_pwdft/soc.cpp:    this->fcoef(it, is1, is2, ip1, ip2) = coeff;
module_hamilt_pw/hamilt_pwdft/stress_func_cc.cpp:			this->deriv_drhoc (
module_hamilt_pw/hamilt_pwdft/stress_func_ewa.cpp:	// this->print(GlobalV::ofs_running, "ewald stress", stression);
module_hamilt_pw/hamilt_pwdft/stress_func_loc.cpp:			this->dvloc_coulomb (atom->ncpp.zv, dvloc.data(), rho_basis);
module_hamilt_pw/hamilt_pwdft/stress_func_loc.cpp:			this->dvloc_of_g ( atom->ncpp.msh, atom->ncpp.rab, atom->ncpp.r,
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    this->device = psi::device::get_device_type<Device>(this->ctx);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    resmem_complex_op()(this->ctx, becp, GlobalV::NBANDS * nkb, "Stress::becp");
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    resmem_complex_op()(this->ctx, dbecp, GlobalV::NBANDS * nkb, "Stress::dbecp");
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    resmem_complex_op()(this->ctx, dbecp_noevc, nkb * npwx, "Stress::dbecp_noevc");
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    resmem_complex_op()(this->ctx, vkb1, nkb * npwx, "Stress::vkb1");
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    resmem_var_op()(this->ctx, qvec, 3);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    resmem_var_op()(this->ctx, stress, 9);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    setmem_var_op()(this->ctx, stress, 0, 9);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    resmem_var_h_op()(this->cpu_ctx, sigmanlc, 9);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        resmem_var_op()(this->ctx, d_wg, wg.nr * wg.nc);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        resmem_var_op()(this->ctx, d_ekb, ekb.nr * ekb.nc);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        resmem_var_op()(this->ctx, gcar, 3 * p_kv->nks * wfc_basis->npwk_max);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, d_wg, wg.c, wg.nr * wg.nc);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, d_ekb, ekb.c, ekb.nr * ekb.nc);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        syncmem_var_h2d_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:                             this->cpu_ctx,
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        resmem_complex_op()(this->ctx, pvkb2, nkb * npwx);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        resmem_complex_op()(this->ctx, pvkb0, 3 * nkb * npwx);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        resmem_int_op()(this->ctx, atom_nh, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        resmem_int_op()(this->ctx, atom_na, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        syncmem_int_h2d_op()(this->ctx, this->cpu_ctx, atom_nh, h_atom_nh, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        syncmem_int_h2d_op()(this->ctx, this->cpu_ctx, atom_na, h_atom_na, GlobalC::ucell.ntype);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        gemm_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:            resmem_complex_h_op()(this->cpu_ctx, h_becp, GlobalV::NBANDS * nkb);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:            syncmem_complex_d2h_op()(this->cpu_ctx, this->ctx, h_becp, becp, GlobalV::NBANDS * nkb);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:            syncmem_complex_h2d_op()(this->ctx, this->cpu_ctx, becp, h_becp, GlobalV::NBANDS * nkb);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:            delmem_complex_h_op()(this->cpu_ctx, h_becp);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:            if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:                syncmem_complex_h2d_op()(this->ctx, this->cpu_ctx, _vkb0[i], vkb0[i].c, nkb * npwx);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        if (this->device == psi::GpuDevice)
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:            syncmem_complex_h2d_op()(this->ctx, this->cpu_ctx, pvkb2, vkb2.c, nkb * npwx);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:                setmem_complex_op()(this->ctx, vkb1, 0, nkb * npwx);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:                setmem_complex_op()(this->ctx, dbecp_noevc, 0, nkb * npwx);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:                cal_dbecp_noevc_nl_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:                gemm_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:                cal_stress_nl_op()(this->ctx,
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    syncmem_var_d2h_op()(this->cpu_ctx, this->ctx, sigmanlc, stress, 9);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    delmem_var_op()(this->ctx, qvec);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    delmem_var_op()(this->ctx, stress);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    delmem_complex_op()(this->ctx, becp);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    delmem_complex_op()(this->ctx, vkb1);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    delmem_complex_op()(this->ctx, pvkb0);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    delmem_complex_op()(this->ctx, dbecp);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    delmem_complex_op()(this->ctx, dbecp_noevc);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:	delmem_var_h_op()(this->cpu_ctx, sigmanlc);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:    if (this->device == psi::GpuDevice) {
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        delmem_var_op()(this->ctx, d_wg);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        delmem_var_op()(this->ctx, d_ekb);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        delmem_var_op()(this->ctx, gcar);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        delmem_int_op()(this->ctx, atom_nh);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        delmem_int_op()(this->ctx, atom_na);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:        delmem_complex_op()(this->ctx, pvkb2);
module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp:	//  this->print(GlobalV::ofs_running, "nonlocal stress", stresnl);
module_hamilt_pw/hamilt_pwdft/stress_func_us.cpp:    double* becsum = static_cast<const elecstate::ElecStatePW<std::complex<FPTYPE>, Device>*>(this->pelec)->becsum;
module_hamilt_pw/hamilt_pwdft/stress_func_us.cpp:    ModuleBase::matrix veff = this->pelec->pot->get_effective_v();
module_hamilt_pw/hamilt_pwdft/stress_func_us.cpp:        this->dylmr2(ppcell_in->lmaxq * ppcell_in->lmaxq, npw, rho_basis->gcar, dylmk0, ipol);
module_hamilt_pw/hamilt_pwdft/stress_func_us.cpp:                        this->dqvan2(ppcell_in,
module_hamilt_pw/hamilt_pwdft/stress_func_us.cpp:                work1 = this->Polynomial_Interpolation_nl(ppcell_in->qrad, itype, l, ijv, GlobalV::DQ, qnorm[ig]);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:    this->stress_kin(sigmakin, this->pelec->wg, p_symm, p_kv, wfc_basis, psi_in);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:    this->stress_har(sigmahar, rho_basis, 1, pelec->charge);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:    this->stress_ewa(sigmaewa, rho_basis, 1);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:    this->stress_gga(sigmaxc, rho_basis, pelec->charge);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:        this->stress_mgga(sigmaxc,
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:                          this->pelec->wg,
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:                          this->pelec->pot->get_effective_vofk(),
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:    this->stress_loc(sigmaloc, rho_basis, p_sf, 1, pelec->charge);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:    this->stress_cc(sigmaxcc, rho_basis, p_sf, 1, pelec->charge);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:    this->stress_nl(sigmanl, this->pelec->wg, this->pelec->ekb, p_sf, p_kv, p_symm, wfc_basis, d_psi_in);
module_hamilt_pw/hamilt_pwdft/stress_pw.cpp:        this->stress_us(sigmanl, rho_basis, &GlobalC::ppcell, ucell);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            delmem_cd_op()(gpu_ctx, this->c_eigts1);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            delmem_cd_op()(gpu_ctx, this->c_eigts2);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            delmem_cd_op()(gpu_ctx, this->c_eigts3);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        delmem_zd_op()(gpu_ctx, this->z_eigts1);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        delmem_zd_op()(gpu_ctx, this->z_eigts2);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        delmem_zd_op()(gpu_ctx, this->z_eigts3);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            delmem_ch_op()(cpu_ctx, this->c_eigts1);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            delmem_ch_op()(cpu_ctx, this->c_eigts2);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            delmem_ch_op()(cpu_ctx, this->c_eigts3);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    this->rho_basis = rho_basis_in;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    this->nbspline = nbspline_in;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    this->strucFac.create(Ucell->ntype, rho_basis->npw);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        this->bspline_sf(nbspline,Ucell, rho_basis);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:                this->strucFac(it,ig) = sum_phase;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    this->eigts1.create(Ucell->nat, 2*rho_basis->nx + 1);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    this->eigts2.create(Ucell->nat, 2*rho_basis->ny + 1);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    this->eigts3.create(Ucell->nat, 2*rho_basis->nz + 1);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:                this->eigts1(inat, n1 + rho_basis->nx) = ModuleBase::libm::exp( ci_tpi*arg  );
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:                this->eigts2(inat, n2 + rho_basis->ny) = ModuleBase::libm::exp( ci_tpi*arg );
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:                this->eigts3(inat, n3 + rho_basis->nz) = ModuleBase::libm::exp( ci_tpi*arg );
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            resmem_cd_op()(gpu_ctx, this->c_eigts1, Ucell->nat * (2 * rho_basis->nx + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            resmem_cd_op()(gpu_ctx, this->c_eigts2, Ucell->nat * (2 * rho_basis->ny + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            resmem_cd_op()(gpu_ctx, this->c_eigts3, Ucell->nat * (2 * rho_basis->nz + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            castmem_z2c_h2d_op()(gpu_ctx, cpu_ctx, this->c_eigts1, this->eigts1.c, Ucell->nat * (2 * rho_basis->nx + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            castmem_z2c_h2d_op()(gpu_ctx, cpu_ctx, this->c_eigts2, this->eigts2.c, Ucell->nat * (2 * rho_basis->ny + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            castmem_z2c_h2d_op()(gpu_ctx, cpu_ctx, this->c_eigts3, this->eigts3.c, Ucell->nat * (2 * rho_basis->nz + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        resmem_zd_op()(gpu_ctx, this->z_eigts1, Ucell->nat * (2 * rho_basis->nx + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        resmem_zd_op()(gpu_ctx, this->z_eigts2, Ucell->nat * (2 * rho_basis->ny + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        resmem_zd_op()(gpu_ctx, this->z_eigts3, Ucell->nat * (2 * rho_basis->nz + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        syncmem_z2z_h2d_op()(gpu_ctx, cpu_ctx, this->z_eigts1, this->eigts1.c, Ucell->nat * (2 * rho_basis->nx + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        syncmem_z2z_h2d_op()(gpu_ctx, cpu_ctx, this->z_eigts2, this->eigts2.c, Ucell->nat * (2 * rho_basis->ny + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        syncmem_z2z_h2d_op()(gpu_ctx, cpu_ctx, this->z_eigts3, this->eigts3.c, Ucell->nat * (2 * rho_basis->nz + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            resmem_ch_op()(cpu_ctx, this->c_eigts1, Ucell->nat * (2 * rho_basis->nx + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            resmem_ch_op()(cpu_ctx, this->c_eigts2, Ucell->nat * (2 * rho_basis->ny + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            resmem_ch_op()(cpu_ctx, this->c_eigts3, Ucell->nat * (2 * rho_basis->nz + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            castmem_z2c_h2h_op()(cpu_ctx, cpu_ctx, this->c_eigts1, this->eigts1.c, Ucell->nat * (2 * rho_basis->nx + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            castmem_z2c_h2h_op()(cpu_ctx, cpu_ctx, this->c_eigts2, this->eigts2.c, Ucell->nat * (2 * rho_basis->ny + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:            castmem_z2c_h2h_op()(cpu_ctx, cpu_ctx, this->c_eigts3, this->eigts3.c, Ucell->nat * (2 * rho_basis->nz + 1));
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        this->z_eigts1 = this->eigts1.c;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        this->z_eigts2 = this->eigts2.c;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        this->z_eigts3 = this->eigts3.c;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:        this->bsplinecoef(b1,b2,b3,rho_basis->nx, rho_basis->ny, rho_basis->nz, norder);
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    return this->c_eigts1;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    return this->z_eigts1;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    return this->c_eigts2;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    return this->z_eigts2;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    return this->c_eigts3;
module_hamilt_pw/hamilt_pwdft/structure_factor.cpp:    return this->z_eigts3;
module_hamilt_pw/hamilt_pwdft/structure_factor.h:    ModuleBase::ComplexMatrix eigts1; // dimension: [Ucell->nat, 2*this->ncx + 1] 
module_hamilt_pw/hamilt_pwdft/structure_factor.h:    ModuleBase::ComplexMatrix eigts2; // dimension: [Ucell->nat, 2*this->ncy + 1] 
module_hamilt_pw/hamilt_pwdft/structure_factor.h:    ModuleBase::ComplexMatrix eigts3; // dimension: [Ucell->nat, 2*this->ncz + 1]
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:        ix += this->rho_basis->nx;
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:        iy += this->rho_basis->ny;
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:        iz += this->rho_basis->nz;
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:        sk[igl] = kphase * this->eigts1(iat, ix) * this->eigts2(iat, iy) * this->eigts3(iat, iz);
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:    int iat = 0, _npw = wfc_basis->npwk[ik], eigts1_nc = this->eigts1.nc, eigts2_nc = this->eigts2.nc,
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:            eigts3_nc = this->eigts3.nc;
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:    std::complex<FPTYPE> *eigts1 = this->get_eigts1_data<FPTYPE>(), *eigts2 = this->get_eigts2_data<FPTYPE>(),
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:            *eigts3 = this->get_eigts3_data<FPTYPE>();
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:                this->rho_basis->nx,
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:                this->rho_basis->ny,
module_hamilt_pw/hamilt_pwdft/structure_factor_k.cpp:                this->rho_basis->nz,
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:	if(this->irindex != nullptr) 
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:		delete[] this->irindex;		
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:		this->irindex=nullptr;
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:	this->npwx = npwx_in;
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:    this->nkstot = nkstot;
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:    if (GlobalV::CALCULATION == "nscf" && this->mem_saver == 1)
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:            if(this->wanf2 != nullptr) delete[] this->wanf2;
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:            this->wanf2 = new ModuleBase::ComplexMatrix [nks2];
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:				this->wanf2[ik].create(GlobalV::NLOCAL, npwx * GlobalV::NPOL);
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:        if (this->irindex != nullptr)
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:            delete[] this->irindex;
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:        this->irindex = new int[wfc_basis->fftnxy];
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:        wfc_basis->getfftixy2is(this->irindex);
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:    ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,"npwx",this->npwx);
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:    assert(this->npwx > 0);
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:	const int nbasis = this->npwx * GlobalV::NPOL;
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:		this->wanf2 = new ModuleBase::ComplexMatrix [nks2];
module_hamilt_pw/hamilt_pwdft/wavefunc.cpp:			this->wanf2[ik].create(GlobalV::NLOCAL, nbasis);
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    if(this->wanf2!= nullptr)
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    if(this->psi != nullptr)
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    this->psf = sf_in;
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    this->print_PAOs();
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:            std::complex<double> *sk = this->psf->get_sk(ik, it, ia, wfc_basis);
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:                                                 wfcatom(index, ig + this->npwx*is ) = lphase * fact[is] * sk[ig] * aux[ig] * flq[ig];
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:                                            for(int ig=0; ig<np;ig++) wfcatom(index,ig+ this->npwx*is) = std::complex<double>(0.0 , 0.0);
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:                                        wfcatom(index,ig+ this->npwx) = (cos(0.5 * gamma) - ModuleBase::IMAG_UNIT * sin(0.5*gamma)) * fdown;
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:                                        wfcatom(index+2*l+1,ig+ this->npwx) = (cos(0.5*gamma) - ModuleBase::IMAG_UNIT*sin(0.5*gamma))*fdown;
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:                                     wfcatom(index,ig+ this->npwx) = (cos(0.5 * gamman) - ModuleBase::IMAG_UNIT * sin(0.5*gamman)) * fdown;
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:                                     wfcatom(index+2*l+1,ig+ this->npwx) = (cos(0.5*gamman) - ModuleBase::IMAG_UNIT*sin(0.5*gamman))*fdown;
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    const int is = this->irindex[ir];
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    const int is = this->irindex[ir];
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    this->random_t(psi, iw_start, iw_end, ik, wfc_basis);
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:    this->random_t(psi, iw_start, iw_end, ik, wfc_basis);
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:            std::complex<FPTYPE>* ppsi = &(psi[iw * this->npwx * GlobalV::NPOL]);
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:            std::complex<FPTYPE>* ppsi = &(psi[iw * this->npwx * GlobalV::NPOL]);
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:            if(GlobalV::NPOL==2)for (int ig = this->npwx;ig < this->npwx + ng;ig++)
module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp:                const FPTYPE gk2 = wfc_basis->getgk2(ik,ig-this->npwx);
module_hamilt_pw/hamilt_stodft/sto_forces.cpp:	this->nat =  GlobalC::ucell.nat;
module_hamilt_pw/hamilt_stodft/sto_forces.cpp:    this->cal_force_loc(forcelc, rho_basis, chr);
module_hamilt_pw/hamilt_stodft/sto_forces.cpp:    this->cal_force_ew(forceion, rho_basis, p_sf);
module_hamilt_pw/hamilt_stodft/sto_forces.cpp:    this->cal_sto_force_nl(forcenl, wg, pkv, wfc_basis, psi_in, stowf);
module_hamilt_pw/hamilt_stodft/sto_forces.cpp:    this->cal_force_cc(forcecc, rho_basis, chr);
module_hamilt_pw/hamilt_stodft/sto_forces.cpp:    this->cal_force_scc(forcescc, rho_basis, elec.vnew, elec.vnew_exist);
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    this->tem = Occupy::gaussian_parameter;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL e_mu = (e - mu) / this->tem ;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL ne_mu = (e * DeltaE + Ebar - mu) / this->tem ;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL e_mu = (e - mu) / this->tem ;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL ne_mu = (e * DeltaE + Ebar - mu) / this->tem ;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL ne_mu = (e - mu) / this->tem ;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL e_mu = (e - mu) / this->tem;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL ne_mu = (rawe * DeltaE + Ebar - mu) / this->tem;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL ne_mu = (rawe * DeltaE + Ebar - mu) / this->tem ;
module_hamilt_pw/hamilt_stodft/sto_func.cpp:    REAL ne_mu = (rawe * DeltaE + Ebar - mu) / this->tem ;
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	const int ik = this->current_ik;
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	const int npwx = this->wfcpw->npwk_max;
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	const int npw = this->wfcpw->npwk[ik];
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	const int nrxx = this->wfcpw->nrxx;
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:				hchibg[ig] = this->wfcpw->getgk2(ik,ig) * tpiba2 * chibg[ig];
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:			this->wfcpw->recip2real(chibg, porter, ik);
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:			this->wfcpw->real2recip(porter, hchibg, ik, true);
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	this->hchi(chig,hchig,m);
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	const int ik = this->current_ik;
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	const int npwx = this->wfcpw->npwk_max;
module_hamilt_pw/hamilt_stodft/sto_hchi.cpp:	const int npw = this->wfcpw->npwk[ik];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    this->pkv = pkv_in;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    this->method = method_in;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method == 2)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        this->chiallorder = new ModuleBase::ComplexMatrix[stowf.nks];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method == 1)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    this->stofunc.mu = mu0 - dmu;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    double mu1 = this->stofunc.mu;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    this->stofunc.mu = mu0 + dmu;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    double mu2 = this->stofunc.mu;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        this->stofunc.mu = mu1;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        this->stofunc.mu = mu2;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        this->stofunc.mu = mu3;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    pes->eferm.ef = this->stofunc.mu = mu0 = mu3;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    this->check_precision(targetne,10*GlobalV::SCF_THR,"Ne");
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        for (int ikk = 0; ikk < this->pkv->nks; ++ikk)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:                pes->wg(ikk, iksb) = stofunc.fd(en[iksb]) * this->pkv->wk[ikk];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        if(this->method == 1)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method == 1)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:            spolyv[i] += p_che->polytrace[i] * this->pkv->wk[ik];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        p_che->calpolyvec_complex(&stohchi, &Stochastic_hchi::hchi_norm, pchi, this->chiallorder[ik].c, npw, npwx, nchip_ik);
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        double* vec_all= (double *) this->chiallorder[ik].c;
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        double kweight = this->pkv->wk[ik];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method == 1)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        for (int ikk = 0; ikk < this->pkv->nks; ++ikk)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:                KS_ne += stofunc.fd(en[iksb]) * this->pkv->wk[ikk];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    for(int ik = 0; ik < this->pkv->nks; ++ik)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        if(this->pkv->nks > 1)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:                GlobalV::CURRENT_SPIN = this->pkv->isk[ik];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        this->calTnchi_ik(ik, stowf);
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method == 1)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        for (int ikk = 0; ikk < this->pkv->nks; ++ikk)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:                pes->f_en.demet += stofunc.fdlnfd(enb[iksb]) * this->pkv->wk[ikk];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    this->check_precision(pes->f_en.demet, 1e-4, "TS");
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method == 1)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        for(int ik = 0; ik < this->pkv->nks; ++ik)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:            if(this->pkv->nks > 1) 
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:            const int npw = this->pkv->ngk[ik];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:            const double kweight = this->pkv->wk[ik];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    for (int ik = 0; ik < this->pkv->nks; ++ik)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:                pes->charge->rho[0][ir] += norm(porter[ir]) * this->pkv->wk[ik];
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method==2)
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:        zgemv_(&transa, &M, &N, &one, this->chiallorder[ik].c, &LDA, coef_real, &inc, &zero, out, &inc);
module_hamilt_pw/hamilt_stodft/sto_iter.cpp:    if(this->method == 2) 
module_hamilt_pw/hamilt_stodft/sto_stress_pw.cpp:    //  this->print(ofs_running, "nonlocal stress", stresnl);
module_hamilt_pw/hamilt_stodft/sto_wf.cpp:    this->nks = p_kv->nks;
module_hamilt_pw/hamilt_stodft/sto_wf.cpp:    this->ngk = p_kv->ngk.data();
module_hamilt_pw/hamilt_stodft/sto_wf.cpp:    this->npwx = npwx_in;
module_hsolver/diago_blas.cpp:    this->pdsygvx_diag(h_mat.desc, h_mat.col, h_mat.row, h_mat.p, s_mat.p, eigen.data(), psi);
module_hsolver/diago_blas.cpp:    this->pzhegvx_diag(h_mat.desc, h_mat.col, h_mat.row, h_mat.p, s_mat.p, eigen.data(), psi);
module_hsolver/diago_blas.cpp:    lrwork = rwork[0] + this->degeneracy_max * GlobalV::NLOCAL;
module_hsolver/diago_blas.cpp:            = "degeneracy_saved = " + ModuleBase::GlobalFunc::TO_STRING(this->degeneracy_max) + ".\n";
module_hsolver/diago_blas.cpp:        if (degeneracy_need <= this->degeneracy_max)
module_hsolver/diago_blas.cpp:            this->degeneracy_max = degeneracy_need;
module_hsolver/diago_bpcg.cpp:    this->r_type   = ct::DataTypeToEnum<Real>::value;
module_hsolver/diago_bpcg.cpp:    this->t_type   = ct::DataTypeToEnum<T>::value;
module_hsolver/diago_bpcg.cpp:    this->device_type    = ct::DeviceTypeToEnum<Device>::value;
module_hsolver/diago_bpcg.cpp:    this->h_prec  = std::move(ct::TensorMap((void *) precondition_in, r_type, device_type, {this->n_basis}));
module_hsolver/diago_bpcg.cpp:    delete this->grad_wrapper;
module_hsolver/diago_bpcg.cpp:    this->n_band        = psi_in.get_nbands();
module_hsolver/diago_bpcg.cpp:    this->n_basis       = psi_in.get_nbasis();
module_hsolver/diago_bpcg.cpp:    this->beta          = std::move(ct::Tensor(r_type, device_type, {this->n_band}));
module_hsolver/diago_bpcg.cpp:    this->eigen         = std::move(ct::Tensor(r_type, device_type, {this->n_band}));
module_hsolver/diago_bpcg.cpp:    this->err_st        = std::move(ct::Tensor(r_type, device_type, {this->n_band}));
module_hsolver/diago_bpcg.cpp:    this->hsub          = std::move(ct::Tensor(t_type, device_type, {this->n_band, this->n_band}));
module_hsolver/diago_bpcg.cpp:    this->hpsi          = std::move(ct::Tensor(t_type, device_type, {this->n_band, this->n_basis}));
module_hsolver/diago_bpcg.cpp:    this->work          = std::move(ct::Tensor(t_type, device_type, {this->n_band, this->n_basis}));
module_hsolver/diago_bpcg.cpp:    this->hgrad         = std::move(ct::Tensor(t_type, device_type, {this->n_band, this->n_basis}));
module_hsolver/diago_bpcg.cpp:    this->grad_old      = std::move(ct::Tensor(t_type, device_type, {this->n_band, this->n_basis}));
module_hsolver/diago_bpcg.cpp:    this->prec          = std::move(ct::Tensor(r_type, device_type, {this->n_basis}));
module_hsolver/diago_bpcg.cpp:    this->grad_wrapper  = new psi::Psi<T, Device>(1, this->n_band, this->n_basis, psi_in.get_ngk_pointer());
module_hsolver/diago_bpcg.cpp:    this->grad          = std::move(ct::TensorMap(grad_wrapper->get_pointer(), t_type, device_type, {this->n_band, this->n_basis}));
module_hsolver/diago_bpcg.cpp:    for (int ii = 0; ii < this->n_band; ii++) {
module_hsolver/diago_bpcg.cpp:    line_minimize_with_block_op()(grad_in.data<T>(), hgrad_in.data<T>(), psi_out.data<T>(), hpsi_out.data<T>(), this->n_basis, this->n_basis, this->n_band);
module_hsolver/diago_bpcg.cpp:        'L', hsub_out.data<T>(), this->n_band);
module_hsolver/diago_bpcg.cpp:        'U', this->n_band, hsub_out.data<T>(), this->n_band);
module_hsolver/diago_bpcg.cpp:        'U', 'N', this->n_band, hsub_out.data<T>(), this->n_band);
module_hsolver/diago_bpcg.cpp:    this->rotate_wf(hsub_out, psi_out, workspace_in);
module_hsolver/diago_bpcg.cpp:    this->rotate_wf(hsub_out, hpsi_out, workspace_in);
module_hsolver/diago_bpcg.cpp:			this->n_basis, 
module_hsolver/diago_bpcg.cpp:			this->n_basis, 
module_hsolver/diago_bpcg.cpp:			this->n_band);
module_hsolver/diago_bpcg.cpp:    syncmem_var_h2d_op()(this->prec.template data<Real>(), this->h_prec.template data<Real>(), this->n_basis);
module_hsolver/diago_bpcg.cpp:    // set_matrix_op()('L', hsub_in->data<T>(), this->n_band);
module_hsolver/diago_bpcg.cpp:    syncmem_complex_op()(psi_out.template data<T>(), workspace_in.template data<T>(), this->n_band * this->n_basis);
module_hsolver/diago_bpcg.cpp:    ct::kernels::lapack_dnevd<T, ct_Device>()('V', 'U', hsub_out.data<T>(), this->n_band, eigenvalue_out.data<Real>());
module_hsolver/diago_bpcg.cpp:    this->calc_hpsi_with_block(hamilt_in, psi_in, hpsi_out);
module_hsolver/diago_bpcg.cpp:    this->diag_hsub(psi_out,hpsi_out, hsub_out, eigenvalue_out);
module_hsolver/diago_bpcg.cpp:    this->rotate_wf(hsub_out, psi_out, workspace_in);
module_hsolver/diago_bpcg.cpp:    this->rotate_wf(hsub_out, hpsi_out, workspace_in);
module_hsolver/diago_bpcg.cpp:    this->diag_hsub(psi_out, hpsi_out, hsub_out, eigenvalue_out);
module_hsolver/diago_bpcg.cpp:    this->rotate_wf(hsub_out, psi_out, workspace_in);
module_hsolver/diago_bpcg.cpp:    this->psi = std::move(ct::TensorMap(psi_in.get_pointer(), t_type, device_type, {this->n_band, this->n_basis}));
module_hsolver/diago_bpcg.cpp:    this->calc_prec();
module_hsolver/diago_bpcg.cpp:    this->calc_hsub_with_block(hamilt_in, psi_in, this->psi, this->hpsi, this->hsub, this->work, this->eigen);
module_hsolver/diago_bpcg.cpp:    setmem_complex_op()(this->grad_old.template data<T>(), 0, this->n_basis * this->n_band);
module_hsolver/diago_bpcg.cpp:    setmem_var_op()(this->beta.template data<Real>(), 1E+40, this->n_band);
module_hsolver/diago_bpcg.cpp:                   this->nline :
module_hsolver/diago_bpcg.cpp:                   this->nline * 6;
module_hsolver/diago_bpcg.cpp:        this->calc_grad_with_block(this->prec, this->err_st, this->beta,
module_hsolver/diago_bpcg.cpp:                                 this->psi, this->hpsi, this->grad, this->grad_old);
module_hsolver/diago_bpcg.cpp:        this->orth_projection(this->psi, this->hsub, this->grad);
module_hsolver/diago_bpcg.cpp:        // this->grad_old = this->grad;
module_hsolver/diago_bpcg.cpp:        syncmem_complex_op()(this->grad_old.template data<T>(), this->grad.template data<T>(), n_basis * n_band);
module_hsolver/diago_bpcg.cpp:        this->calc_hpsi_with_block(hamilt_in, this->grad_wrapper[0], this->hgrad);
module_hsolver/diago_bpcg.cpp:        this->line_minimize(this->grad, this->hgrad, this->psi, this->hpsi);
module_hsolver/diago_bpcg.cpp:        this->orth_cholesky(this->work, this->psi, this->hpsi, this->hsub);
module_hsolver/diago_bpcg.cpp:        if (current_scf_iter == 1 && ntry % this->nline == 0) {
module_hsolver/diago_bpcg.cpp:            this->calc_hsub_with_block(hamilt_in, psi_in, this->psi, this->hpsi, this->hsub, this->work, this->eigen);
module_hsolver/diago_bpcg.cpp:    } while (ntry < max_iter && this->test_error(this->err_st, this->all_band_cg_thr));
module_hsolver/diago_bpcg.cpp:    this->calc_hsub_with_block_exit(this->psi, this->hpsi, this->hsub, this->work, this->eigen);
module_hsolver/diago_bpcg.cpp:    syncmem_var_d2h_op()(eigenvalue_in, this->eigen.template data<Real>(), this->n_band);
module_hsolver/diago_cg.cpp:    this->one_ = new T(static_cast<T>(1.0));
module_hsolver/diago_cg.cpp:    this->zero_ = new T(static_cast<T>(0.0));
module_hsolver/diago_cg.cpp:    this->neg_one_ = new T(static_cast<T>(-1.0));
module_hsolver/diago_cg.cpp:    this->one_ = new T(static_cast<T>(1.0));
module_hsolver/diago_cg.cpp:    this->zero_ = new T(static_cast<T>(0.0));
module_hsolver/diago_cg.cpp:    this->neg_one_ = new T(static_cast<T>(-1.0));
module_hsolver/diago_cg.cpp:    delete this->one_;
module_hsolver/diago_cg.cpp:    delete this->zero_;
module_hsolver/diago_cg.cpp:    delete this->neg_one_;
module_hsolver/diago_cg.cpp:    this->notconv_ = 0;
module_hsolver/diago_cg.cpp:    this->n_band_ = psi.shape().dim_size(0);
module_hsolver/diago_cg.cpp:    this->n_basis_ = psi.shape().dim_size(1);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:    // hphi.resize(this->n_basis_max_, ModuleBase::ZERO);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:    // sphi.resize(this->n_basis_max_, ModuleBase::ZERO);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:    // pphi.resize(this->n_basis_max_, ModuleBase::ZERO);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:    // scg.resize(this->n_basis_max_, ModuleBase::ZERO);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:    // grad.resize(this->n_basis_max_, ModuleBase::ZERO);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:    // g0.resize(this->n_basis_max_, ModuleBase::ZERO);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_}));
module_hsolver/diago_cg.cpp:    // lagrange.resize(this->n_band, ModuleBase::ZERO);
module_hsolver/diago_cg.cpp:        ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_band_}));
module_hsolver/diago_cg.cpp:            ct::DataTypeToEnum<T>::value, ct::DeviceTypeToEnum<ct_Device>::value, {this->n_basis_});
module_hsolver/diago_cg.cpp:    ModuleBase::Memory::record("DiagoCG", this->n_basis_ * 10);
module_hsolver/diago_cg.cpp:    for (int m = 0; m < this->n_band_; m++)
module_hsolver/diago_cg.cpp:        this->spsi_func_(phi_m, sphi); // sphi = S|psi(m)>
module_hsolver/diago_cg.cpp:        this->schmit_orth(m, psi, sphi, phi_m);
module_hsolver/diago_cg.cpp:        this->spsi_func_(phi_m, sphi); // sphi = S|psi(m)>
module_hsolver/diago_cg.cpp:        this->hpsi_func_(phi_m, hphi); // hphi = H|psi(m)>
module_hsolver/diago_cg.cpp:            dot_real_op()(ctx_, this->n_basis_, phi_m.data<T>(), hphi.data<T>());
module_hsolver/diago_cg.cpp:            this->calc_grad(prec, grad, hphi, sphi, pphi);
module_hsolver/diago_cg.cpp:            this->orth_grad(psi, m, grad, scg, lagrange);
module_hsolver/diago_cg.cpp:            this->calc_gamma_cg(
module_hsolver/diago_cg.cpp:            this->hpsi_func_(cg, pphi);
module_hsolver/diago_cg.cpp:            this->spsi_func_(cg, scg);
module_hsolver/diago_cg.cpp:            converged = this->update_psi(
module_hsolver/diago_cg.cpp:            ++this->notconv_;
module_hsolver/diago_cg.cpp:                // ModuleBase::GlobalFunc::COPYARRAY(psi_temp, pphi, this->n_basis_);
module_hsolver/diago_cg.cpp:    avg /= this->n_band_;
module_hsolver/diago_cg.cpp:    // for (int i = 0; i < this->n_basis_; i++)
module_hsolver/diago_cg.cpp:    //     grad.data<T>()[i] = this->hphi[i] / this->precondition[i];
module_hsolver/diago_cg.cpp:    //     this->pphi[i] = this->sphi[i] / this->precondition[i];
module_hsolver/diago_cg.cpp:    vector_div_vector_op<T, Device>()(ctx_, this->n_basis_, grad.data<T>(), hphi.data<T>(), prec.data<Real>());
module_hsolver/diago_cg.cpp:    vector_div_vector_op<T, Device>()(ctx_, this->n_basis_, pphi.data<T>(), sphi.data<T>(), prec.data<Real>());
module_hsolver/diago_cg.cpp:    const Real eh = hsolver::dot_real_op<T, Device>()(ctx_, this->n_basis_, sphi.data<T>(), grad.data<T>());
module_hsolver/diago_cg.cpp:    const Real es = hsolver::dot_real_op<T, Device>()(ctx_, this->n_basis_, sphi.data<T>(), pphi.data<T>());
module_hsolver/diago_cg.cpp:    // for (int i = 0; i < this->n_basis_; i++)
module_hsolver/diago_cg.cpp:    //     grad.data<T>()[i] -= lambda * this->pphi[i];
module_hsolver/diago_cg.cpp:    constantvector_addORsub_constantVector_op<T, Device>()(ctx_, this->n_basis_, grad.data<T>(), grad.data<T>(), 1.0, pphi.data<T>(), (-lambda));
module_hsolver/diago_cg.cpp:    this->spsi_func_(grad, scg); // scg = S|grad>
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->one_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->zero_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->neg_one_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->one_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->neg_one_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->one_,
module_hsolver/diago_cg.cpp:            = hsolver::dot_real_op<T, Device>()(ctx_, this->n_basis_, grad.data<T>(), g0.data<T>()); // b means before
module_hsolver/diago_cg.cpp:    // for (int i = 0; i < this->n_basis_; i++)
module_hsolver/diago_cg.cpp:    //     g0[i] = this->precondition[i] * this->scg[i];
module_hsolver/diago_cg.cpp:    vector_mul_vector_op<T, Device>()(ctx_, this->n_basis_, g0.data<T>(), scg.data<T>(), prec.data<Real>());
module_hsolver/diago_cg.cpp:    const Real gg_now = hsolver::dot_real_op<T, Device>()(ctx_, this->n_basis_, grad.data<T>(), g0.data<T>());
module_hsolver/diago_cg.cpp:        // for (int i = 0; i < this->n_basis_; i++)
module_hsolver/diago_cg.cpp:        constantvector_addORsub_constantVector_op<T, Device>()(ctx_, this->n_basis_, cg.data<T>(), cg.data<T>(), gamma, grad.data<T>(), 1.0);
module_hsolver/diago_cg.cpp:        // zaxpy_(&this->n_basis_, &znorma, pphi_m, &one, pcg, &one);
module_hsolver/diago_cg.cpp:        /*for (int i = 0; i < this->n_basis_; i++)
module_hsolver/diago_cg.cpp:        axpy_op<T, Device>()(ctx_, this->n_basis_, &znorma, phi_m.data<T>(), 1, cg.data<T>(), 1);
module_hsolver/diago_cg.cpp:    cg_norm = sqrt(hsolver::dot_real_op<T, Device>()(ctx_, this->n_basis_, cg.data<T>(), scg.data<T>()));
module_hsolver/diago_cg.cpp:        = hsolver::dot_real_op<T, Device>()(ctx_, this->n_basis_, phi_m.data<T>(), pphi.data<T>()) * 2.0 / cg_norm;
module_hsolver/diago_cg.cpp:        = hsolver::dot_real_op<T, Device>()(ctx_, this->n_basis_, cg.data<T>(), pphi.data<T>()) / (cg_norm * cg_norm);
module_hsolver/diago_cg.cpp:    // for (int i = 0; i < this->n_basis_; i++)
module_hsolver/diago_cg.cpp:    constantvector_addORsub_constantVector_op<T, Device>()(ctx_, this->n_basis_, phi_m.data<T>(), phi_m.data<T>(), cost, cg.data<T>(), sint_norm);
module_hsolver/diago_cg.cpp:        // for (int i = 0; i < this->n_basis_; i++)
module_hsolver/diago_cg.cpp:        //     this->sphi[i] = this->sphi[i] * cost + sint_norm * this->scg[i];
module_hsolver/diago_cg.cpp:        //     this->hphi[i] = this->hphi[i] * cost + sint_norm * this->pphi[i];
module_hsolver/diago_cg.cpp:        constantvector_addORsub_constantVector_op<T, Device>()(ctx_, this->n_basis_, sphi.data<T>(), sphi.data<T>(), cost, scg.data<T>(),  sint_norm);
module_hsolver/diago_cg.cpp:        constantvector_addORsub_constantVector_op<T, Device>()(ctx_, this->n_basis_, hphi.data<T>(), hphi.data<T>(), cost, pphi.data<T>(), sint_norm);
module_hsolver/diago_cg.cpp:    REQUIRES_OK(this->n_band_ >= m,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->one_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->zero_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->neg_one_,
module_hsolver/diago_cg.cpp:        this->n_basis_,
module_hsolver/diago_cg.cpp:        this->one_,
module_hsolver/diago_cg.cpp:    // scal_op<Real, Device>()(ctx_, this->n_basis_, &psi_norm, pphi_m, 1);
module_hsolver/diago_cg.cpp:    // for (int ig = 0; ig < this->n_basis_; ig++)
module_hsolver/diago_cg.cpp:    vector_div_constant_op<T, Device>()(ctx_, this->n_basis_, phi_m.data<T>(), phi_m.data<T>(), psi_norm);
module_hsolver/diago_cg.cpp:    this->notconv_ = 0;
module_hsolver/diago_cg.cpp:            this->subspace_func_(psi, psi);
module_hsolver/diago_cg.cpp:        this->diag_mock(prec, psi, eigen);
module_hsolver/diago_cg.cpp:    } while (this->test_exit_cond(ntry, this->notconv_));
module_hsolver/diago_cg.cpp:    if (this->notconv_ > std::max(5, this->n_band_ / 4)) {
module_hsolver/diago_cg.cpp:        std::cout << "\n notconv = " << this->notconv_;
module_hsolver/diago_cusolver.cpp:        this->dc.Dngvd_complex(h_mat.row, h_mat.col, h_mat.p, s_mat.p, eigen.data(), eigenvectors);
module_hsolver/diago_cusolver.cpp:        this->dc.Dngvd_double(h_mat.col, h_mat.row, h_mat.p, s_mat.p, eigen.data(), psi.get_pointer());
module_hsolver/diago_dav_subspace.cpp:    this->device = psi::device::get_device_type<Device>(this->ctx);
module_hsolver/diago_dav_subspace.cpp:    this->precondition = precondition_in;
module_hsolver/diago_dav_subspace.cpp:    this->one = &this->cs.one;
module_hsolver/diago_dav_subspace.cpp:    this->zero = &this->cs.zero;
module_hsolver/diago_dav_subspace.cpp:    this->neg_one = &this->cs.neg_one;
module_hsolver/diago_dav_subspace.cpp:    delmem_complex_op()(this->ctx, this->hphi);
module_hsolver/diago_dav_subspace.cpp:    delmem_complex_op()(this->ctx, this->hcc);
module_hsolver/diago_dav_subspace.cpp:    delmem_complex_op()(this->ctx, this->scc);
module_hsolver/diago_dav_subspace.cpp:    delmem_complex_op()(this->ctx, this->vcc);
module_hsolver/diago_dav_subspace.cpp:    delmem_real_h_op()(this->cpu_ctx, this->eigenvalue_in_dav);
module_hsolver/diago_dav_subspace.cpp:    if (this->device == psi::GpuDevice)
module_hsolver/diago_dav_subspace.cpp:        delmem_real_op()(this->ctx, this->d_precondition);
module_hsolver/diago_dav_subspace.cpp:    this->dim = psi.get_k_first() ? psi.get_current_nbas() : psi.get_nk() * psi.get_nbasis();
module_hsolver/diago_dav_subspace.cpp:    this->n_band = psi.get_nbands();
module_hsolver/diago_dav_subspace.cpp:    this->nbase_x = Diago_DavSubspace::PW_DIAG_NDIM * this->n_band;
module_hsolver/diago_dav_subspace.cpp:    psi::Psi<T, Device> basis(1, this->nbase_x, this->dim, &(psi.get_ngk(0)));
module_hsolver/diago_dav_subspace.cpp:    ModuleBase::Memory::record("DAV::basis", this->nbase_x * this->dim * sizeof(T));
module_hsolver/diago_dav_subspace.cpp:    resmem_real_h_op()(this->cpu_ctx, this->eigenvalue_in_dav, this->nbase_x, "DAV::eig");
module_hsolver/diago_dav_subspace.cpp:    setmem_real_h_op()(this->cpu_ctx, this->eigenvalue_in_dav, 0, this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:    resmem_complex_op()(this->ctx, this->hphi, this->nbase_x * this->dim, "DAV::hphi");
module_hsolver/diago_dav_subspace.cpp:    setmem_complex_op()(this->ctx, this->hphi, 0, this->nbase_x * this->dim);
module_hsolver/diago_dav_subspace.cpp:    resmem_complex_op()(this->ctx, this->hcc, this->nbase_x * this->nbase_x, "DAV::hcc");
module_hsolver/diago_dav_subspace.cpp:    setmem_complex_op()(this->ctx, this->hcc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:    resmem_complex_op()(this->ctx, this->scc, this->nbase_x * this->nbase_x, "DAV::scc");
module_hsolver/diago_dav_subspace.cpp:    setmem_complex_op()(this->ctx, this->scc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:    resmem_complex_op()(this->ctx, this->vcc, this->nbase_x * this->nbase_x, "DAV::vcc");
module_hsolver/diago_dav_subspace.cpp:    setmem_complex_op()(this->ctx, this->vcc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:    std::vector<bool> convflag(this->n_band, false);
module_hsolver/diago_dav_subspace.cpp:    std::vector<int> unconv(this->n_band);
module_hsolver/diago_dav_subspace.cpp:    this->notconv = this->n_band;
module_hsolver/diago_dav_subspace.cpp:    for (int m = 0; m < this->n_band; m++)
module_hsolver/diago_dav_subspace.cpp:        syncmem_complex_op()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                             this->ctx,
module_hsolver/diago_dav_subspace.cpp:                             this->dim);
module_hsolver/diago_dav_subspace.cpp:    hpsi_info dav_hpsi_in(&basis, psi::Range(1, 0, 0, this->n_band - 1), this->hphi);
module_hsolver/diago_dav_subspace.cpp:    this->cal_elem(this->dim, 
module_hsolver/diago_dav_subspace.cpp:                   this->notconv, 
module_hsolver/diago_dav_subspace.cpp:                   this->hphi, 
module_hsolver/diago_dav_subspace.cpp:                   this->hcc, 
module_hsolver/diago_dav_subspace.cpp:                   this->scc);
module_hsolver/diago_dav_subspace.cpp:    this->diag_zhegvx(nbase,
module_hsolver/diago_dav_subspace.cpp:                      this->n_band,
module_hsolver/diago_dav_subspace.cpp:                      this->hcc,
module_hsolver/diago_dav_subspace.cpp:                      this->scc,
module_hsolver/diago_dav_subspace.cpp:                      this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                      this->eigenvalue_in_dav,
module_hsolver/diago_dav_subspace.cpp:                      this->vcc,
module_hsolver/diago_dav_subspace.cpp:                      this->is_subspace);
module_hsolver/diago_dav_subspace.cpp:    for (size_t m = 0; m < this->n_band; m++)
module_hsolver/diago_dav_subspace.cpp:        eigenvalue_in_hsolver[m] = this->eigenvalue_in_dav[m];
module_hsolver/diago_dav_subspace.cpp:        this->cal_grad(phm_in,
module_hsolver/diago_dav_subspace.cpp:                       this->dim,
module_hsolver/diago_dav_subspace.cpp:                       this->notconv,
module_hsolver/diago_dav_subspace.cpp:                       this->hphi,
module_hsolver/diago_dav_subspace.cpp:                       this->vcc,
module_hsolver/diago_dav_subspace.cpp:                       this->eigenvalue_in_dav);
module_hsolver/diago_dav_subspace.cpp:        this->cal_elem(this->dim, 
module_hsolver/diago_dav_subspace.cpp:                       this->notconv, 
module_hsolver/diago_dav_subspace.cpp:                       this->hphi, 
module_hsolver/diago_dav_subspace.cpp:                       this->hcc, 
module_hsolver/diago_dav_subspace.cpp:                       this->scc);
module_hsolver/diago_dav_subspace.cpp:        this->diag_zhegvx(nbase,
module_hsolver/diago_dav_subspace.cpp:                          this->n_band,
module_hsolver/diago_dav_subspace.cpp:                          this->hcc,
module_hsolver/diago_dav_subspace.cpp:                          this->scc,
module_hsolver/diago_dav_subspace.cpp:                          this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                          this->eigenvalue_in_dav,
module_hsolver/diago_dav_subspace.cpp:                          this->vcc,
module_hsolver/diago_dav_subspace.cpp:        this->notconv = 0;
module_hsolver/diago_dav_subspace.cpp:        for (int m = 0; m < this->n_band; m++)
module_hsolver/diago_dav_subspace.cpp:                convflag[m] = (std::abs(this->eigenvalue_in_dav[m] - eigenvalue_in_hsolver[m])
module_hsolver/diago_dav_subspace.cpp:                convflag[m] = (std::abs(this->eigenvalue_in_dav[m] - eigenvalue_in_hsolver[m]) < empty_ethr);
module_hsolver/diago_dav_subspace.cpp:                unconv[this->notconv] = m;
module_hsolver/diago_dav_subspace.cpp:                this->notconv++;
module_hsolver/diago_dav_subspace.cpp:            eigenvalue_in_hsolver[m] = this->eigenvalue_in_dav[m];
module_hsolver/diago_dav_subspace.cpp:        if ((this->notconv == 0) || 
module_hsolver/diago_dav_subspace.cpp:            (nbase + this->notconv + 1 > this->nbase_x) || 
module_hsolver/diago_dav_subspace.cpp:            setmem_complex_op()(this->ctx, psi.get_pointer(), 0, n_band * psi.get_nbasis());
module_hsolver/diago_dav_subspace.cpp:            gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                                 this->dim,    // m: row of A,C
module_hsolver/diago_dav_subspace.cpp:                                 this->n_band, // n: col of B,C
module_hsolver/diago_dav_subspace.cpp:                                 this->one,
module_hsolver/diago_dav_subspace.cpp:                                 this->dim,
module_hsolver/diago_dav_subspace.cpp:                                 this->vcc, // B nbase * n_band
module_hsolver/diago_dav_subspace.cpp:                                 this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                                 this->zero,
module_hsolver/diago_dav_subspace.cpp:            if (!this->notconv || (dav_iter == DiagoIterAssist<T, Device>::PW_DIAG_NMAX))
module_hsolver/diago_dav_subspace.cpp:                this->refresh(this->dim,
module_hsolver/diago_dav_subspace.cpp:                              this->n_band,
module_hsolver/diago_dav_subspace.cpp:                              this->hphi,
module_hsolver/diago_dav_subspace.cpp:                              this->hcc,
module_hsolver/diago_dav_subspace.cpp:                              this->scc,
module_hsolver/diago_dav_subspace.cpp:                              this->vcc);
module_hsolver/diago_dav_subspace.cpp:                this->ctx, 
module_hsolver/diago_dav_subspace.cpp:                this->ctx, 
module_hsolver/diago_dav_subspace.cpp:                vcc + i * this->nbase_x, 
module_hsolver/diago_dav_subspace.cpp:                vcc + unconv[i] * this->nbase_x, 
module_hsolver/diago_dav_subspace.cpp:            this->eigenvalue_in_dav[i] = this->eigenvalue_in_dav[unconv[i]];
module_hsolver/diago_dav_subspace.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                         this->dim,        // m: row of A,C
module_hsolver/diago_dav_subspace.cpp:                         this->one,        // alpha
module_hsolver/diago_dav_subspace.cpp:                         this->dim,        // LDA
module_hsolver/diago_dav_subspace.cpp:                         this->nbase_x,    // LDB
module_hsolver/diago_dav_subspace.cpp:                         this->zero,       // belta
module_hsolver/diago_dav_subspace.cpp:                         this->dim         // LDC
module_hsolver/diago_dav_subspace.cpp:        std::vector<Real> e_temp_cpu(this->dim, (-this->eigenvalue_in_dav[m]));
module_hsolver/diago_dav_subspace.cpp:        vector_mul_vector_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                                          this->dim,
module_hsolver/diago_dav_subspace.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                         this->dim,        // m: row of A,C
module_hsolver/diago_dav_subspace.cpp:                         this->one,        // alpha
module_hsolver/diago_dav_subspace.cpp:                         this->dim,        // LDA
module_hsolver/diago_dav_subspace.cpp:                         this->nbase_x,    // LDB
module_hsolver/diago_dav_subspace.cpp:                         this->one,        // belta
module_hsolver/diago_dav_subspace.cpp:                         this->dim         // LDC
module_hsolver/diago_dav_subspace.cpp:    std::vector<Real> pre(this->dim, 0.0);
module_hsolver/diago_dav_subspace.cpp:        for (size_t i = 0; i < this->dim; i++)
module_hsolver/diago_dav_subspace.cpp:            double x = this->precondition[i] - this->eigenvalue_in_dav[m];
module_hsolver/diago_dav_subspace.cpp:            this->ctx, 
module_hsolver/diago_dav_subspace.cpp:            this->dim, 
module_hsolver/diago_dav_subspace.cpp:        psi_norm[i] = dot_real_op<T, Device>()(this->ctx, this->dim, &basis(nbase + i, 0), &basis(nbase + i, 0), false);
module_hsolver/diago_dav_subspace.cpp:        vector_div_constant_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                                            this->dim,
module_hsolver/diago_dav_subspace.cpp:    hpsi_info dav_hpsi_in(&basis, psi::Range(1, 0, nbase, nbase + notconv - 1), &hphi[nbase * this->dim]);
module_hsolver/diago_dav_subspace.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                        this->dim,
module_hsolver/diago_dav_subspace.cpp:                        this->one,
module_hsolver/diago_dav_subspace.cpp:                        this->dim,
module_hsolver/diago_dav_subspace.cpp:                        &hphi[nbase * this->dim],
module_hsolver/diago_dav_subspace.cpp:                        this->dim,
module_hsolver/diago_dav_subspace.cpp:                        this->zero,
module_hsolver/diago_dav_subspace.cpp:                        &hcc[nbase * this->nbase_x],
module_hsolver/diago_dav_subspace.cpp:                        this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                        this->dim,
module_hsolver/diago_dav_subspace.cpp:                        this->one,
module_hsolver/diago_dav_subspace.cpp:                        this->dim,
module_hsolver/diago_dav_subspace.cpp:                        this->dim,
module_hsolver/diago_dav_subspace.cpp:                        this->zero,
module_hsolver/diago_dav_subspace.cpp:                        &scc[nbase * this->nbase_x],
module_hsolver/diago_dav_subspace.cpp:                        this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:        auto* swap = new T[notconv * this->nbase_x];
module_hsolver/diago_dav_subspace.cpp:        syncmem_complex_op()(this->ctx, this->ctx, swap, hcc + nbase * this->nbase_x, notconv * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:            Parallel_Reduce::reduce_pool(hcc + nbase * this->nbase_x, notconv * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:            Parallel_Reduce::reduce_pool(scc + nbase * this->nbase_x, notconv * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:                           hcc + nbase * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                           notconv * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                           hcc + nbase * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                           notconv * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:            syncmem_complex_op()(this->ctx, this->ctx, swap, scc + nbase * this->nbase_x, notconv * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:                           scc + nbase * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                           notconv * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                           scc + nbase * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                           notconv * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:            hcc[i * this->nbase_x + i] = set_real_tocomplex(hcc[i * this->nbase_x + i]);
module_hsolver/diago_dav_subspace.cpp:            scc[i * this->nbase_x + i] = set_real_tocomplex(scc[i * this->nbase_x + i]);
module_hsolver/diago_dav_subspace.cpp:            hcc[i * this->nbase_x + j] = get_conj(hcc[j * this->nbase_x + i]);
module_hsolver/diago_dav_subspace.cpp:            scc[i * this->nbase_x + j] = get_conj(scc[j * this->nbase_x + i]);
module_hsolver/diago_dav_subspace.cpp:    for (size_t i = nbase; i < this->nbase_x; i++)
module_hsolver/diago_dav_subspace.cpp:        for (size_t j = nbase; j < this->nbase_x; j++)
module_hsolver/diago_dav_subspace.cpp:            hcc[i * this->nbase_x + j] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:            scc[i * this->nbase_x + j] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:            hcc[j * this->nbase_x + i] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:            scc[j * this->nbase_x + i] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:                    h_diag[i][j] = hcc[i * this->nbase_x + j];
module_hsolver/diago_dav_subspace.cpp:                    s_diag[i][j] = scc[i * this->nbase_x + j];
module_hsolver/diago_dav_subspace.cpp:            if (this->device == psi::GpuDevice)
module_hsolver/diago_dav_subspace.cpp:                resmem_real_op()(this->ctx, eigenvalue_gpu, this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:                    this->ctx, 
module_hsolver/diago_dav_subspace.cpp:                    this->cpu_ctx, 
module_hsolver/diago_dav_subspace.cpp:                    this->eigenvalue_in_dav, 
module_hsolver/diago_dav_subspace.cpp:                    this->nbase_x
module_hsolver/diago_dav_subspace.cpp:                dnevx_op<T, Device>()(this->ctx, nbase, this->nbase_x, this->hcc, nband, eigenvalue_gpu, this->vcc);
module_hsolver/diago_dav_subspace.cpp:                    this->cpu_ctx, 
module_hsolver/diago_dav_subspace.cpp:                    this->ctx, 
module_hsolver/diago_dav_subspace.cpp:                    this->eigenvalue_in_dav, 
module_hsolver/diago_dav_subspace.cpp:                    this->nbase_x
module_hsolver/diago_dav_subspace.cpp:                delmem_real_op()(this->ctx, eigenvalue_gpu);
module_hsolver/diago_dav_subspace.cpp:                    dnevx_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                                          this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                                          this->hcc,
module_hsolver/diago_dav_subspace.cpp:                                          this->eigenvalue_in_dav,
module_hsolver/diago_dav_subspace.cpp:                                          this->vcc);
module_hsolver/diago_dav_subspace.cpp:                    dngvx_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                                          this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                                          this->hcc,
module_hsolver/diago_dav_subspace.cpp:                                          this->scc,
module_hsolver/diago_dav_subspace.cpp:                                          this->eigenvalue_in_dav,
module_hsolver/diago_dav_subspace.cpp:                                          this->vcc);
module_hsolver/diago_dav_subspace.cpp:                    hcc[i * this->nbase_x + j] = h_diag[i][j];
module_hsolver/diago_dav_subspace.cpp:                    scc[i * this->nbase_x + j] = s_diag[i][j];
module_hsolver/diago_dav_subspace.cpp:                for (size_t j = nbase; j < this->nbase_x; j++)
module_hsolver/diago_dav_subspace.cpp:                    hcc[i * this->nbase_x + j] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:                    hcc[j * this->nbase_x + i] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:                    scc[i * this->nbase_x + j] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:                    scc[j * this->nbase_x + i] = cs.zero;
module_hsolver/diago_dav_subspace.cpp:                MPI_Bcast(&vcc[i * this->nbase_x], nbase, MPI_DOUBLE_COMPLEX, 0, POOL_WORLD);
module_hsolver/diago_dav_subspace.cpp:            MPI_Bcast(this->eigenvalue_in_dav, nband, MPI_DOUBLE, 0, POOL_WORLD);
module_hsolver/diago_dav_subspace.cpp:            this->eigenvalue_in_dav[m] = get_real(hcc[m * this->nbase_x + m]);
module_hsolver/diago_dav_subspace.cpp:            vcc[m * this->nbase_x + m] = set_real_tocomplex(1.0);
module_hsolver/diago_dav_subspace.cpp:            MPI_Bcast(this->eigenvalue_in_dav, this->n_band, MPI_DOUBLE, 0, POOL_WORLD);
module_hsolver/diago_dav_subspace.cpp:        syncmem_complex_op()(this->ctx, this->ctx, &basis(i, 0), &psi(i, 0), this->dim);
module_hsolver/diago_dav_subspace.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                         this->dim,
module_hsolver/diago_dav_subspace.cpp:                         this->one,
module_hsolver/diago_dav_subspace.cpp:                         this->hphi,
module_hsolver/diago_dav_subspace.cpp:                         this->dim,
module_hsolver/diago_dav_subspace.cpp:                         this->vcc,
module_hsolver/diago_dav_subspace.cpp:                         this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:                         this->zero,
module_hsolver/diago_dav_subspace.cpp:                         this->dim);
module_hsolver/diago_dav_subspace.cpp:    syncmem_complex_op()(this->ctx, this->ctx, hphi, &basis(nband, 0), this->dim * nband);
module_hsolver/diago_dav_subspace.cpp:        setmem_complex_op()(this->ctx, &hcc[this->nbase_x * i], 0, nbase);
module_hsolver/diago_dav_subspace.cpp:        setmem_complex_op()(this->ctx, &scc[this->nbase_x * i], 0, nbase);
module_hsolver/diago_dav_subspace.cpp:        setmem_complex_op()(this->ctx, &vcc[this->nbase_x * i], 0, nbase);
module_hsolver/diago_dav_subspace.cpp:    if (this->device == psi::GpuDevice)
module_hsolver/diago_dav_subspace.cpp:        psi::memory::resize_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx,
module_hsolver/diago_dav_subspace.cpp:                                                            this->nbase_x * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:        psi::memory::resize_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx,
module_hsolver/diago_dav_subspace.cpp:                                                            this->nbase_x * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:        psi::memory::resize_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx,
module_hsolver/diago_dav_subspace.cpp:                                                            this->nbase_x * this->nbase_x,
module_hsolver/diago_dav_subspace.cpp:        syncmem_d2h_op()(this->cpu_ctx, this->ctx, hcc_cpu, hcc, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:        syncmem_d2h_op()(this->cpu_ctx, this->ctx, scc_cpu, scc, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:        syncmem_d2h_op()(this->cpu_ctx, this->ctx, vcc_cpu, vcc, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:            hcc_cpu[i * this->nbase_x + i] = eigenvalue_in_hsolver[i];
module_hsolver/diago_dav_subspace.cpp:            scc_cpu[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_dav_subspace.cpp:            vcc_cpu[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_dav_subspace.cpp:        syncmem_h2d_op()(this->ctx, this->cpu_ctx, hcc, hcc_cpu, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:        syncmem_h2d_op()(this->ctx, this->cpu_ctx, scc, scc_cpu, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:        syncmem_h2d_op()(this->ctx, this->cpu_ctx, vcc, vcc_cpu, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:        psi::memory::delete_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx, hcc_cpu);
module_hsolver/diago_dav_subspace.cpp:        psi::memory::delete_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx, scc_cpu);
module_hsolver/diago_dav_subspace.cpp:        psi::memory::delete_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx, vcc_cpu);
module_hsolver/diago_dav_subspace.cpp:            hcc[i * this->nbase_x + i] = eigenvalue_in_hsolver[i];
module_hsolver/diago_dav_subspace.cpp:            scc[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_dav_subspace.cpp:            vcc[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_dav_subspace.cpp:    this->notconv = 0;
module_hsolver/diago_dav_subspace.cpp:    if (this->device == psi::GpuDevice)
module_hsolver/diago_dav_subspace.cpp:        resmem_real_op()(this->ctx, this->d_precondition, psi.get_nbasis());
module_hsolver/diago_dav_subspace.cpp:        syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, this->d_precondition, this->precondition, psi.get_nbasis());
module_hsolver/diago_dav_subspace.cpp:        this->is_subspace = true;
module_hsolver/diago_dav_subspace.cpp:        this->is_subspace = false;
module_hsolver/diago_dav_subspace.cpp:        this->nbase_x = 2 * psi.get_nbands();
module_hsolver/diago_dav_subspace.cpp:        resmem_complex_op()(this->ctx, this->scc, this->nbase_x * this->nbase_x, "DAV::scc");
module_hsolver/diago_dav_subspace.cpp:        setmem_complex_op()(this->ctx, this->scc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:        gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                             this->one,
module_hsolver/diago_dav_subspace.cpp:                             this->zero,
module_hsolver/diago_dav_subspace.cpp:                             this->scc,
module_hsolver/diago_dav_subspace.cpp:                             this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:                std::cout << this->scc[i * this->nbase_x + j] << "\t";
module_hsolver/diago_dav_subspace.cpp:        this->diag_once(phm_in, psi, eigenvalue_in_hsolver, is_occupied);
module_hsolver/diago_dav_subspace.cpp:    } while (DiagoIterAssist<T, Device>::test_exit_cond(ntry, this->notconv));
module_hsolver/diago_dav_subspace.cpp:        std::cout << "\n notconv = " << this->notconv;
module_hsolver/diago_dav_subspace.cpp:        gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_dav_subspace.cpp:                             this->one,
module_hsolver/diago_dav_subspace.cpp:                             this->zero,
module_hsolver/diago_dav_subspace.cpp:                             this->scc,
module_hsolver/diago_dav_subspace.cpp:                             this->nbase_x);
module_hsolver/diago_dav_subspace.cpp:                std::cout << this->scc[i * this->nbase_x + j] << "\t";
module_hsolver/diago_david.cpp:    this->device = psi::device::get_device_type<Device>(this->ctx);
module_hsolver/diago_david.cpp:    this->precondition = precondition_in;
module_hsolver/diago_david.cpp:    this->one = &this->cs.one;
module_hsolver/diago_david.cpp:    this->zero = &this->cs.zero;
module_hsolver/diago_david.cpp:    this->neg_one = &this->cs.neg_one;
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, this->hphi);
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, this->sphi);
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, this->hcc);
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, this->scc);
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, this->vcc);
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, this->lagrange_matrix);
module_hsolver/diago_david.cpp:    psi::memory::delete_memory_op<Real, psi::DEVICE_CPU>()(this->cpu_ctx, this->eigenvalue);
module_hsolver/diago_david.cpp:    if (this->device == psi::GpuDevice) {
module_hsolver/diago_david.cpp:        delmem_var_op()(this->ctx, this->d_precondition);
module_hsolver/diago_david.cpp:    this->dim = psi.get_k_first() ? psi.get_current_nbas() : psi.get_nk() * psi.get_nbasis();
module_hsolver/diago_david.cpp:    this->dmx = psi.get_k_first() ? psi.get_nbasis() : psi.get_nk() * psi.get_nbasis();
module_hsolver/diago_david.cpp:    this->n_band = psi.get_nbands();
module_hsolver/diago_david.cpp:    this->nbase_x = DiagoDavid::PW_DIAG_NDIM * this->n_band; // maximum dimension of the reduced basis set
module_hsolver/diago_david.cpp:    psi::memory::resize_memory_op<Real, psi::DEVICE_CPU>()(this->cpu_ctx, this->eigenvalue, this->nbase_x, "DAV::eig");
module_hsolver/diago_david.cpp:    psi::memory::set_memory_op<Real, psi::DEVICE_CPU>()(this->cpu_ctx, this->eigenvalue, 0, this->nbase_x);
module_hsolver/diago_david.cpp:                                                 this->nbase_x,
module_hsolver/diago_david.cpp:                                                 this->dim,
module_hsolver/diago_david.cpp:    ModuleBase::Memory::record("DAV::basis", this->nbase_x * this->dim * sizeof(T));
module_hsolver/diago_david.cpp:    // ModuleBase::ComplexMatrix hp(nbase_x, this->dim); // the product of H and psi in the reduced basis set
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, this->hphi, this->nbase_x * this->dim, "DAV::hphi");
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, this->hphi, 0, this->nbase_x * this->dim);
module_hsolver/diago_david.cpp:    // ModuleBase::ComplexMatrix sp(nbase_x, this->dim); // the Product of S and psi in the reduced basis set
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, this->sphi, this->nbase_x * this->dim, "DAV::sphi");
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, this->sphi, 0, this->nbase_x * this->dim);
module_hsolver/diago_david.cpp:    // ModuleBase::ComplexMatrix hc(this->nbase_x, this->nbase_x); // Hamiltonian on the reduced basis
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, this->hcc, this->nbase_x * this->nbase_x, "DAV::hcc");
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, this->hcc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:    // ModuleBase::ComplexMatrix sc(this->nbase_x, this->nbase_x); // Overlap on the reduced basis
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, this->scc, this->nbase_x * this->nbase_x, "DAV::scc");
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, this->scc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:    // ModuleBase::ComplexMatrix vc(this->nbase_x, this->nbase_x); // Eigenvectors of hc
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, this->vcc, this->nbase_x * this->nbase_x, "DAV::vcc");
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, this->vcc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:    std::vector<bool> convflag(this->n_band, false);
module_hsolver/diago_david.cpp:    std::vector<int> unconv(this->n_band);
module_hsolver/diago_david.cpp:    this->notconv = this->n_band; // the number of the unconvergent bands
module_hsolver/diago_david.cpp:    for (int m = 0; m < this->n_band; m++)
module_hsolver/diago_david.cpp:    // ModuleBase::ComplexMatrix lagrange_matrix(this->n_band, this->n_band);
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, this->lagrange_matrix, this->n_band * this->n_band);
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, this->lagrange_matrix, 0, this->n_band * this->n_band);
module_hsolver/diago_david.cpp:    std::vector<int> pre_matrix_mm_m(this->n_band, 0);
module_hsolver/diago_david.cpp:    std::vector<int> pre_matrix_mv_m(this->n_band, 1);
module_hsolver/diago_david.cpp:    this->planSchmitOrth(this->n_band, pre_matrix_mm_m.data(), pre_matrix_mv_m.data());
module_hsolver/diago_david.cpp:    for (int m = 0; m < this->n_band; m++)
module_hsolver/diago_david.cpp:                reinterpret_cast<std::complex<double>*>(&this->sphi[m * this->dim]));
module_hsolver/diago_david.cpp:                         &this->sphi[m * this->dim],
module_hsolver/diago_david.cpp:                         this->dim,
module_hsolver/diago_david.cpp:                         this->dim,
module_hsolver/diago_david.cpp:    for (int m = 0; m < this->n_band; m++)
module_hsolver/diago_david.cpp:        syncmem_complex_op()(this->ctx, this->ctx, &basis(m, 0), psi.get_k_first() ? &psi(m, 0) : &psi(m, 0, 0), this->dim);
module_hsolver/diago_david.cpp:        this->SchmitOrth(this->dim,
module_hsolver/diago_david.cpp:                         this->n_band,
module_hsolver/diago_david.cpp:                         this->sphi,
module_hsolver/diago_david.cpp:                         &this->lagrange_matrix[m * this->n_band],
module_hsolver/diago_david.cpp:                reinterpret_cast<std::complex<double>*>(&this->sphi[m * this->dim]));
module_hsolver/diago_david.cpp:            phm_in->sPsi(&basis(m, 0), &this->sphi[m * this->dim], this->dim, this->dim, 1);
module_hsolver/diago_david.cpp:    hpsi_info dav_hpsi_in(&basis, psi::Range(1, 0, 0, this->n_band - 1), this->hphi);
module_hsolver/diago_david.cpp:    this->cal_elem(this->dim, nbase, this->notconv, basis, this->hphi, this->sphi, this->hcc, this->scc);
module_hsolver/diago_david.cpp:    this->diag_zhegvx(nbase, this->n_band, this->hcc, this->scc, this->nbase_x, this->eigenvalue, this->vcc);
module_hsolver/diago_david.cpp:    for (int m = 0; m < this->n_band; m++)
module_hsolver/diago_david.cpp:        eigenvalue_in[m] = this->eigenvalue[m];
module_hsolver/diago_david.cpp:        this->cal_grad(phm_in,
module_hsolver/diago_david.cpp:                       this->dim,
module_hsolver/diago_david.cpp:                       this->notconv,
module_hsolver/diago_david.cpp:                       this->hphi,
module_hsolver/diago_david.cpp:                       this->sphi,
module_hsolver/diago_david.cpp:                       this->vcc,
module_hsolver/diago_david.cpp:                       this->eigenvalue);
module_hsolver/diago_david.cpp:        this->cal_elem(this->dim, nbase, this->notconv, basis, this->hphi, this->sphi, this->hcc, this->scc);
module_hsolver/diago_david.cpp:        this->diag_zhegvx(nbase, this->n_band, this->hcc, this->scc, this->nbase_x, this->eigenvalue, this->vcc);
module_hsolver/diago_david.cpp:        this->notconv = 0;
module_hsolver/diago_david.cpp:        for (int m = 0; m < this->n_band; m++)
module_hsolver/diago_david.cpp:            convflag[m] = (std::abs(this->eigenvalue[m] - eigenvalue_in[m]) < DiagoIterAssist<T, Device>::PW_DIAG_THR);
module_hsolver/diago_david.cpp:                unconv[this->notconv] = m;
module_hsolver/diago_david.cpp:                this->notconv++;
module_hsolver/diago_david.cpp:            eigenvalue_in[m] = this->eigenvalue[m];
module_hsolver/diago_david.cpp:        if (!this->notconv || (nbase + this->notconv > this->nbase_x)
module_hsolver/diago_david.cpp:            // ModuleBase::GlobalFunc::ZEROS(psi.get_pointer(), n_band * this->dmx);
module_hsolver/diago_david.cpp:            setmem_complex_op()(this->ctx, psi.get_pointer(), 0, n_band * this->dmx);
module_hsolver/diago_david.cpp:            gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                                      this->dim,           // m: row of A,C
module_hsolver/diago_david.cpp:                                      this->n_band,        // n: col of B,C
module_hsolver/diago_david.cpp:                                      this->one,
module_hsolver/diago_david.cpp:                                      this->dim,
module_hsolver/diago_david.cpp:                                      this->vcc,           // B nbase * n_band
module_hsolver/diago_david.cpp:                                      this->nbase_x,
module_hsolver/diago_david.cpp:                                      this->zero,
module_hsolver/diago_david.cpp:                                      this->dmx
module_hsolver/diago_david.cpp:            if (!this->notconv || (dav_iter == DiagoIterAssist<T, Device>::PW_DIAG_NMAX))
module_hsolver/diago_david.cpp:                this->refresh(this->dim,
module_hsolver/diago_david.cpp:                              this->n_band,
module_hsolver/diago_david.cpp:                              this->hphi,
module_hsolver/diago_david.cpp:                              this->sphi,
module_hsolver/diago_david.cpp:                              this->hcc,
module_hsolver/diago_david.cpp:                              this->scc,
module_hsolver/diago_david.cpp:                              this->vcc);
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, vc_ev_vector, notconv * nbase);
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, vc_ev_vector, 0, notconv * nbase);
module_hsolver/diago_david.cpp:    //         vc_ev_vector[m * nbase + i] = vcc[i * this->nbase_x + unconv[m]];
module_hsolver/diago_david.cpp:        syncmem_complex_op()(this->ctx,
module_hsolver/diago_david.cpp:                             this->ctx,
module_hsolver/diago_david.cpp:                             vcc + unconv[m] * this->nbase_x,
module_hsolver/diago_david.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim, // m: row of A,C
module_hsolver/diago_david.cpp:                              this->one, // alpha
module_hsolver/diago_david.cpp:                              this->dim, // LDA: if(N) max(1,m) if(T) max(1,k)
module_hsolver/diago_david.cpp:                              this->zero, // belta
module_hsolver/diago_david.cpp:                              this->dim // LDC: if(N) max(1, m)
module_hsolver/diago_david.cpp:    //         vc_ev_vector[m * nbase + i] *= -1 * this->eigenvalue[unconv[m]];
module_hsolver/diago_david.cpp:        std::vector<Real> e_temp_cpu(nbase, (-1.0 * this->eigenvalue[unconv[m]]));
module_hsolver/diago_david.cpp:        if (this->device == psi::GpuDevice)
module_hsolver/diago_david.cpp:            resmem_var_op()(this->ctx, e_temp_gpu, nbase);
module_hsolver/diago_david.cpp:            syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, e_temp_gpu, e_temp_cpu.data(), nbase);
module_hsolver/diago_david.cpp:            vector_mul_vector_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:            delmem_var_op()(this->ctx, e_temp_gpu);
module_hsolver/diago_david.cpp:            vector_mul_vector_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim, // m: row of A,C
module_hsolver/diago_david.cpp:                              this->one, // alpha
module_hsolver/diago_david.cpp:                              this->dim, // LDA: if(N) max(1,m) if(T) max(1,k)
module_hsolver/diago_david.cpp:                              this->one, // belta
module_hsolver/diago_david.cpp:                              this->dim // LDC: if(N) max(1, m)
module_hsolver/diago_david.cpp:        if (this->device == psi::GpuDevice)
module_hsolver/diago_david.cpp:            vector_div_vector_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                                                   this->dim,
module_hsolver/diago_david.cpp:                                                   this->d_precondition);
module_hsolver/diago_david.cpp:            vector_div_vector_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                                                   this->dim,
module_hsolver/diago_david.cpp:                                                   this->precondition);
module_hsolver/diago_david.cpp:        // for (int ig = 0; ig < this->dim; ig++)
module_hsolver/diago_david.cpp:        //     ppsi[ig] /= this->precondition[ig];
module_hsolver/diago_david.cpp:    resmem_complex_op()(this->ctx, lagrange, notconv * (nbase + notconv));
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, lagrange, 0, notconv * (nbase + notconv));
module_hsolver/diago_david.cpp:    this->planSchmitOrth(notconv, pre_matrix_mm_m.data(), pre_matrix_mv_m.data());
module_hsolver/diago_david.cpp:                reinterpret_cast<std::complex<double>*>(&sphi[(nbase + m) * this->dim]));
module_hsolver/diago_david.cpp:            phm_in->sPsi(&basis(nbase + m, 0), &sphi[(nbase + m) * this->dim], this->dim, this->dim, 1);
module_hsolver/diago_david.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim, // k: col of A, row of B
module_hsolver/diago_david.cpp:                              this->one, // alpha
module_hsolver/diago_david.cpp:                              this->dim, // LDA: if(N) max(1,m) if(T) max(1,k)
module_hsolver/diago_david.cpp:                              &sphi[nbase * this->dim], // B
module_hsolver/diago_david.cpp:                              this->dim, // LDB: if(N) max(1,k) if(T) max(1,n)
module_hsolver/diago_david.cpp:                              this->zero, // belta
module_hsolver/diago_david.cpp:        this->SchmitOrth(this->dim,
module_hsolver/diago_david.cpp:                reinterpret_cast<std::complex<double>*>(&sphi[(nbase + m) * this->dim]));
module_hsolver/diago_david.cpp:            phm_in->sPsi(&basis(nbase + m, 0), &sphi[(nbase + m) * this->dim], this->dim, this->dim, 1);
module_hsolver/diago_david.cpp:                          &hphi[nbase * this->dim]); // &hp(nbase, 0)
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, lagrange);
module_hsolver/diago_david.cpp:    delmem_complex_op()(this->ctx, vc_ev_vector);
module_hsolver/diago_david.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->one,
module_hsolver/diago_david.cpp:                              &basis(nbase, 0),   // this->dim * notconv
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              hphi,               // this->dim * (nbase + notconv)
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->zero,
module_hsolver/diago_david.cpp:                              this->nbase_x);
module_hsolver/diago_david.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->one,
module_hsolver/diago_david.cpp:                              &basis(nbase, 0),   // this->dim * notconv
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              sphi,               // this->dim * (nbase + notconv)
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->zero,
module_hsolver/diago_david.cpp:                              this->nbase_x);
module_hsolver/diago_david.cpp:        matrixTranspose_op<T, Device>()(this->ctx, this->nbase_x, this->nbase_x, hcc, hcc);
module_hsolver/diago_david.cpp:        matrixTranspose_op<T, Device>()(this->ctx, this->nbase_x, this->nbase_x, scc, scc);
module_hsolver/diago_david.cpp:        auto* swap = new T[notconv * this->nbase_x];
module_hsolver/diago_david.cpp:        syncmem_complex_op()(this->ctx, this->ctx, swap, hcc + nbase * this->nbase_x, notconv * this->nbase_x);
module_hsolver/diago_david.cpp:            Parallel_Reduce::reduce_pool(hcc + nbase * this->nbase_x, notconv * this->nbase_x);
module_hsolver/diago_david.cpp:                MPI_Reduce(swap, hcc + nbase * this->nbase_x, notconv * this->nbase_x, MPI_COMPLEX, MPI_SUM, 0, POOL_WORLD);
module_hsolver/diago_david.cpp:                MPI_Reduce(swap, hcc + nbase * this->nbase_x, notconv * this->nbase_x, MPI_DOUBLE_COMPLEX, MPI_SUM, 0, POOL_WORLD);
module_hsolver/diago_david.cpp:            syncmem_complex_op()(this->ctx, this->ctx, swap, scc + nbase * this->nbase_x, notconv * this->nbase_x);
module_hsolver/diago_david.cpp:                MPI_Reduce(swap, scc + nbase * this->nbase_x, notconv * this->nbase_x, MPI_COMPLEX, MPI_SUM, 0, POOL_WORLD);
module_hsolver/diago_david.cpp:                MPI_Reduce(swap, scc + nbase * this->nbase_x, notconv * this->nbase_x, MPI_DOUBLE_COMPLEX, MPI_SUM, 0, POOL_WORLD);
module_hsolver/diago_david.cpp:        // Parallel_Reduce::reduce_complex_double_pool( hcc + nbase * this->nbase_x, notconv * this->nbase_x );
module_hsolver/diago_david.cpp:        // Parallel_Reduce::reduce_complex_double_pool( scc + nbase * this->nbase_x, notconv * this->nbase_x );
module_hsolver/diago_david.cpp:        matrixTranspose_op<T, Device>()(this->ctx, this->nbase_x, this->nbase_x, hcc, hcc);
module_hsolver/diago_david.cpp:        matrixTranspose_op<T, Device>()(this->ctx, this->nbase_x, this->nbase_x, scc, scc);
module_hsolver/diago_david.cpp:        if (this->device == psi::GpuDevice)
module_hsolver/diago_david.cpp:            resmem_var_op()(this->ctx, eigenvalue_gpu, this->nbase_x);
module_hsolver/diago_david.cpp:            syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, eigenvalue_gpu, this->eigenvalue, this->nbase_x);
module_hsolver/diago_david.cpp:            dnevx_op<T, Device>()(this->ctx, nbase, this->nbase_x, this->hcc, nband, eigenvalue_gpu, this->vcc);
module_hsolver/diago_david.cpp:            syncmem_var_d2h_op()(this->cpu_ctx, this->ctx, this->eigenvalue, eigenvalue_gpu, this->nbase_x);
module_hsolver/diago_david.cpp:            delmem_var_op()(this->ctx, eigenvalue_gpu);
module_hsolver/diago_david.cpp:            dnevx_op<T, Device>()(this->ctx, nbase, this->nbase_x, this->hcc, nband, this->eigenvalue, this->vcc);
module_hsolver/diago_david.cpp:            MPI_Bcast(&vcc[i * this->nbase_x], nbase, MPI_DOUBLE_COMPLEX, 0, POOL_WORLD);
module_hsolver/diago_david.cpp:        MPI_Bcast(this->eigenvalue, nband, MPI_DOUBLE, 0, POOL_WORLD);
module_hsolver/diago_david.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim,            // m: row of A,C
module_hsolver/diago_david.cpp:                              this->one,
module_hsolver/diago_david.cpp:                              this->hphi,           // A dim * nbase
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->vcc,            // B nbase * nband
module_hsolver/diago_david.cpp:                              this->nbase_x,
module_hsolver/diago_david.cpp:                              this->zero,
module_hsolver/diago_david.cpp:                              this->dim
module_hsolver/diago_david.cpp:    gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim,                // m: row of A,C
module_hsolver/diago_david.cpp:                              this->one,
module_hsolver/diago_david.cpp:                              this->sphi,               // A dim * nbase
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->vcc,                // B nbase * nband
module_hsolver/diago_david.cpp:                              this->nbase_x,
module_hsolver/diago_david.cpp:                              this->zero,
module_hsolver/diago_david.cpp:                              this->dim
module_hsolver/diago_david.cpp:    syncmem_complex_op()(this->ctx, this->ctx, hphi, &basis(0, 0), this->dim * nband);
module_hsolver/diago_david.cpp:    syncmem_complex_op()(this->ctx, this->ctx, sphi, &basis(nband, 0), this->dim * nband);
module_hsolver/diago_david.cpp:        for (int ig = 0; ig < this->dim; ig++)
module_hsolver/diago_david.cpp:        syncmem_complex_op()(this->ctx, this->ctx, &basis(m, 0), psi.get_k_first() ? &psi(m, 0) : &psi(m, 0, 0), this->dim);
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, hcc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:    setmem_complex_op()(this->ctx, scc, 0, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:    if (this->device == psi::GpuDevice)
module_hsolver/diago_david.cpp:        psi::memory::resize_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx,
module_hsolver/diago_david.cpp:                                                                               this->nbase_x * this->nbase_x,
module_hsolver/diago_david.cpp:        psi::memory::resize_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx,
module_hsolver/diago_david.cpp:                                                                               this->nbase_x * this->nbase_x,
module_hsolver/diago_david.cpp:        psi::memory::resize_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx,
module_hsolver/diago_david.cpp:                                                                               this->nbase_x * this->nbase_x,
module_hsolver/diago_david.cpp:        syncmem_d2h_op()(this->cpu_ctx, this->ctx, hcc_cpu, hcc, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:        syncmem_d2h_op()(this->cpu_ctx, this->ctx, scc_cpu, scc, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:        syncmem_d2h_op()(this->cpu_ctx, this->ctx, vcc_cpu, vcc, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:            hcc_cpu[i * this->nbase_x + i] = eigenvalue_in[i];
module_hsolver/diago_david.cpp:            scc_cpu[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_david.cpp:            vcc_cpu[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_david.cpp:        syncmem_h2d_op()(this->ctx, this->cpu_ctx, hcc, hcc_cpu, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:        syncmem_h2d_op()(this->ctx, this->cpu_ctx, scc, scc_cpu, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:        syncmem_h2d_op()(this->ctx, this->cpu_ctx, vcc, vcc_cpu, this->nbase_x * this->nbase_x);
module_hsolver/diago_david.cpp:        psi::memory::delete_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx, hcc_cpu);
module_hsolver/diago_david.cpp:        psi::memory::delete_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx, scc_cpu);
module_hsolver/diago_david.cpp:        psi::memory::delete_memory_op<T, psi::DEVICE_CPU>()(this->cpu_ctx, vcc_cpu);
module_hsolver/diago_david.cpp:            hcc[i * this->nbase_x + i] = eigenvalue_in[i];
module_hsolver/diago_david.cpp:            // sc(i, i) = this->one;
module_hsolver/diago_david.cpp:            scc[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_david.cpp:            // vc(i, i) = this->one;
module_hsolver/diago_david.cpp:            vcc[i * this->nbase_x + i] = this->one[0];
module_hsolver/diago_david.cpp:        gemm_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                                  this->dim, // k: col of A, row of B
module_hsolver/diago_david.cpp:                                  this->one, // alpha
module_hsolver/diago_david.cpp:                                  this->dim, // LDA: if(N) max(1,m) if(T) max(1,k)
module_hsolver/diago_david.cpp:                                  &sphi[m * this->dim], // B
module_hsolver/diago_david.cpp:                                  this->dim, // LDB: if(N) max(1,k) if(T) max(1,n)
module_hsolver/diago_david.cpp:                                  this->zero, // belta
module_hsolver/diago_david.cpp:    gemv_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->one,
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              &sphi[m * this->dim],
module_hsolver/diago_david.cpp:                              this->zero,
module_hsolver/diago_david.cpp:    T var = *this->zero;
module_hsolver/diago_david.cpp:    syncmem_d2h_op()(this->cpu_ctx, this->ctx, &var, lagrange_m + m, 1);
module_hsolver/diago_david.cpp:    gemv_op<T, Device>()(this->ctx,
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->neg_one,
module_hsolver/diago_david.cpp:                              this->dim,
module_hsolver/diago_david.cpp:                              this->one,
module_hsolver/diago_david.cpp:    psi_norm -= dot_real_op<T, Device>()(this->ctx, m, lagrange_m, lagrange_m, false);
module_hsolver/diago_david.cpp:        vector_div_constant_op<T, Device>()(this->ctx, this->dim, psi_m, psi_m, psi_norm);
module_hsolver/diago_david.cpp:    this->notconv = 0;
module_hsolver/diago_david.cpp:    if (this->device == psi::GpuDevice)
module_hsolver/diago_david.cpp:        resmem_var_op()(this->ctx, this->d_precondition, psi.get_nbasis());
module_hsolver/diago_david.cpp:        syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, this->d_precondition, this->precondition, psi.get_nbasis());
module_hsolver/diago_david.cpp:        this->diag_mock(phm_in, psi, eigenvalue_in);
module_hsolver/diago_david.cpp:    } while (DiagoIterAssist<T, Device>::test_exit_cond(ntry, this->notconv));
module_hsolver/diago_david.cpp:        std::cout << "\n notconv = " << this->notconv;
module_hsolver/diago_elpa.cpp:    this->DecomposedState=0; // for k pointer, the decomposed s_mat can not be reused
module_hsolver/diago_elpa.cpp:    es.generalized_eigenvector(h_mat.p, s_mat.p, this->DecomposedState, eigen.data(), psi.get_pointer());
module_hsolver/diago_elpa.cpp:    es.generalized_eigenvector(h_mat.p, s_mat.p, this->DecomposedState, eigen.data(), psi.get_pointer());
module_hsolver/genelpa/elpa_new.cpp:    this->isReal = isReal;
module_hsolver/genelpa/elpa_new.cpp:    this->comm = comm;
module_hsolver/genelpa/elpa_new.cpp:    this->nev = nev;
module_hsolver/genelpa/elpa_new.cpp:    this->narows = narows;
module_hsolver/genelpa/elpa_new.cpp:    this->nacols = nacols;
module_hsolver/genelpa/elpa_new.cpp:        this->desc[i] = desc[i];
module_hsolver/genelpa/elpa_new.cpp:    this->setQR(0);
module_hsolver/genelpa/elpa_new.cpp:    this->setKernel(isReal, kernel_id);
module_hsolver/genelpa/elpa_new.cpp:    this->setLoglevel(0);
module_hsolver/genelpa/elpa_new.cpp:    this->isReal = isReal;
module_hsolver/genelpa/elpa_new.cpp:    this->comm = comm;
module_hsolver/genelpa/elpa_new.cpp:    this->nev = nev;
module_hsolver/genelpa/elpa_new.cpp:    this->narows = narows;
module_hsolver/genelpa/elpa_new.cpp:    this->nacols = nacols;
module_hsolver/genelpa/elpa_new.cpp:        this->desc[i] = desc[i];
module_hsolver/genelpa/elpa_new.cpp:    this->setQR(useQR);
module_hsolver/genelpa/elpa_new.cpp:    this->setKernel(isReal, kernel_id);
module_hsolver/genelpa/elpa_new.cpp:    this->setLoglevel(loglevel);
module_hsolver/genelpa/elpa_new.cpp:    this->loglevel = loglevel;
module_hsolver/genelpa/elpa_new.cpp:    this->kernel_id = kernel;
module_hsolver/genelpa/elpa_new.cpp:    this->useQR = useQR;
module_hsolver/hsolver_lcao.cpp:    this->method = method_in;
module_hsolver/hsolver_lcao.cpp:    if (this->method == "scalapack_gvx")
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_lcao.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_lcao.cpp:                delete[] this->pdiagh;
module_hsolver/hsolver_lcao.cpp:                this->pdiagh = nullptr;
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh == nullptr)
module_hsolver/hsolver_lcao.cpp:            this->pdiagh = new DiagoBlas<T>();
module_hsolver/hsolver_lcao.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_lcao.cpp:    else if (this->method == "genelpa")
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_lcao.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_lcao.cpp:                delete[] this->pdiagh;
module_hsolver/hsolver_lcao.cpp:                this->pdiagh = nullptr;
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh == nullptr)
module_hsolver/hsolver_lcao.cpp:            this->pdiagh = new DiagoElpa<T>();
module_hsolver/hsolver_lcao.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_lcao.cpp:    else if (this->method == "cusolver")
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_lcao.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_lcao.cpp:                delete[] this->pdiagh;
module_hsolver/hsolver_lcao.cpp:                this->pdiagh = nullptr;
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh == nullptr)
module_hsolver/hsolver_lcao.cpp:            this->pdiagh = new DiagoCusolver<T>();
module_hsolver/hsolver_lcao.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_lcao.cpp:    else if (this->method == "lapack")
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_lcao.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_lcao.cpp:                delete[] this->pdiagh;
module_hsolver/hsolver_lcao.cpp:                this->pdiagh = nullptr;
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh == nullptr)
module_hsolver/hsolver_lcao.cpp:            this->pdiagh = new DiagoLapack();
module_hsolver/hsolver_lcao.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_lcao.cpp:    else if (this->method == "cg_in_lcao")
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_lcao.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_lcao.cpp:                delete reinterpret_cast<DiagoCG<T>*>(this->pdiagh);
module_hsolver/hsolver_lcao.cpp:                this->pdiagh = nullptr;
module_hsolver/hsolver_lcao.cpp:        if (this->pdiagh == nullptr)
module_hsolver/hsolver_lcao.cpp:            this->pdiagh = new DiagoCG<T>(
module_hsolver/hsolver_lcao.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_lcao.cpp:    if (this->method == "cg_in_lcao")
module_hsolver/hsolver_lcao.cpp:        this->precondition_lcao.resize(psi.get_nbasis());
module_hsolver/hsolver_lcao.cpp:        this->hamiltSolvePsiK(pHamilt, psi, &(pes->ekb(ik, 0)));
module_hsolver/hsolver_lcao.cpp:    if (this->method == "cg_in_lcao")
module_hsolver/hsolver_lcao.cpp:        this->is_first_scf = false;
module_hsolver/hsolver_lcao.cpp:    if (this->method != "genelpa" && this->method != "scalapack_gvx" && this->method != "lapack"
module_hsolver/hsolver_lcao.cpp:                        && this->method != "cusolver" && this->method != "cg_in_lcao")
module_hsolver/hsolver_lcao.cpp:        delete this->pdiagh;
module_hsolver/hsolver_lcao.cpp:        this->pdiagh = nullptr;
module_hsolver/hsolver_lcao.cpp:    this->solveTemplate(pHamilt, psi, pes, this->method, skip_charge);
module_hsolver/hsolver_lcao.cpp:    if (this->method != "cg_in_lcao")
module_hsolver/hsolver_lcao.cpp:        this->pdiagh->diag(hm, psi, eigenvalue);
module_hsolver/hsolver_lcao.cpp:        auto cg = reinterpret_cast<DiagoCG<T>*>(this->pdiagh);
module_hsolver/hsolver_lcao.cpp:        if (this->is_first_scf)
module_hsolver/hsolver_lcao.cpp:            this->precondition_lcao.data(),
module_hsolver/hsolver_lcao.cpp:            ct::TensorShape({static_cast<int>(this->precondition_lcao.size())})
module_hsolver/hsolver_lcao.h:      this->classname = "HSolverPW"; 
module_hsolver/hsolver_lcao.h:      this->ParaV = ParaV_in;
module_hsolver/hsolver_pw.cpp:    this->classname = "HSolverPW";
module_hsolver/hsolver_pw.cpp:    this->wfc_basis = wfc_basis_in;
module_hsolver/hsolver_pw.cpp:    this->pwf = pwf_in;
module_hsolver/hsolver_pw.cpp:    this->diag_ethr = GlobalV::PW_DIAG_THR;
module_hsolver/hsolver_pw.cpp:    /*this->init(pbas_in);*/
module_hsolver/hsolver_pw.cpp:    if (this->method == "cg")
module_hsolver/hsolver_pw.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_pw.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_pw.cpp:                delete reinterpret_cast<DiagoCG<T, Device>*>(this->pdiagh);
module_hsolver/hsolver_pw.cpp:        // this->pdiagh = new DiagoCG<T, Device>(precondition.data());
module_hsolver/hsolver_pw.cpp:        this->pdiagh = new DiagoCG<T, Device>(GlobalV::BASIS_TYPE,
module_hsolver/hsolver_pw.cpp:        this->pdiagh->method = this->method;
module_hsolver/hsolver_pw.cpp:    else if (this->method == "dav")
module_hsolver/hsolver_pw.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_pw.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_pw.cpp:                delete (DiagoDavid<T, Device>*)this->pdiagh;
module_hsolver/hsolver_pw.cpp:                this->pdiagh = new DiagoDavid<T, Device>(precondition.data());
module_hsolver/hsolver_pw.cpp:                this->pdiagh->method = this->method;
module_hsolver/hsolver_pw.cpp:            this->pdiagh = new DiagoDavid<T, Device>(precondition.data());
module_hsolver/hsolver_pw.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_pw.cpp:    else if (this->method == "dav_subspace")
module_hsolver/hsolver_pw.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_pw.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_pw.cpp:                delete (Diago_DavSubspace<T, Device>*)this->pdiagh;
module_hsolver/hsolver_pw.cpp:                this->pdiagh = new Diago_DavSubspace<T, Device>(precondition.data());
module_hsolver/hsolver_pw.cpp:                this->pdiagh->method = this->method;
module_hsolver/hsolver_pw.cpp:            this->pdiagh = new Diago_DavSubspace<T, Device>(precondition.data());
module_hsolver/hsolver_pw.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_pw.cpp:    else if (this->method == "bpcg")
module_hsolver/hsolver_pw.cpp:        if (this->pdiagh != nullptr)
module_hsolver/hsolver_pw.cpp:            if (this->pdiagh->method != this->method)
module_hsolver/hsolver_pw.cpp:                delete (DiagoBPCG<T, Device>*)this->pdiagh;
module_hsolver/hsolver_pw.cpp:                this->pdiagh = new DiagoBPCG<T, Device>(precondition.data());
module_hsolver/hsolver_pw.cpp:                this->pdiagh->method = this->method;
module_hsolver/hsolver_pw.cpp:                reinterpret_cast<DiagoBPCG<T, Device>*>(this->pdiagh)->init_iter(psi);
module_hsolver/hsolver_pw.cpp:            this->pdiagh = new DiagoBPCG<T, Device>(precondition.data());
module_hsolver/hsolver_pw.cpp:            this->pdiagh->method = this->method;
module_hsolver/hsolver_pw.cpp:            reinterpret_cast<DiagoBPCG<T, Device>*>(this->pdiagh)->init_iter(psi);
module_hsolver/hsolver_pw.cpp:    this->precondition.resize(psi.get_nbasis());
module_hsolver/hsolver_pw.cpp:    this->hamilt_ = pHamilt;
module_hsolver/hsolver_pw.cpp:    this->method = method_in;
module_hsolver/hsolver_pw.cpp:    this->initDiagh(psi);
module_hsolver/hsolver_pw.cpp:    if (this->is_first_scf)
module_hsolver/hsolver_pw.cpp:        if (this->diago_full_acc)
module_hsolver/hsolver_pw.cpp:    for (int ik = 0; ik < this->wfc_basis->nks; ++ik)
module_hsolver/hsolver_pw.cpp:            const int npw = this->wfc_basis->npwk[ik];
module_hsolver/hsolver_pw.cpp:                _gk[ig] = this->wfc_basis->getgpluskcar(ik, ig);
module_hsolver/hsolver_pw.cpp:            kpt[0] = this->wfc_basis->kvec_c[ik].x;
module_hsolver/hsolver_pw.cpp:            kpt[1] = this->wfc_basis->kvec_c[ik].y;
module_hsolver/hsolver_pw.cpp:            kpt[2] = this->wfc_basis->kvec_c[ik].z;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][0] = this->wfc_basis->getgcar(ik, ipw).x;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][1] = this->wfc_basis->getgcar(ik, ipw).y;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][2] = this->wfc_basis->getgcar(ik, ipw).z;
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2ix(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iy(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iz(ik).data(),
module_hsolver/hsolver_pw.cpp:        this->updatePsiK(pHamilt, psi, ik);
module_hsolver/hsolver_pw.cpp:        update_precondition(precondition, ik, this->wfc_basis->npwk[ik]);
module_hsolver/hsolver_pw.cpp:        this->hamiltSolvePsiK(pHamilt, psi, eigenvalues.data() + ik * pes->ekb.nc);
module_hsolver/hsolver_pw.cpp:    this->is_first_scf = false;
module_hsolver/hsolver_pw.cpp:    this->endDiagh();
module_hsolver/hsolver_pw.cpp:        for (int ik = 0; ik < this->wfc_basis->nks; ++ik)
module_hsolver/hsolver_pw.cpp:            const int npw = this->wfc_basis->npwk[ik];
module_hsolver/hsolver_pw.cpp:                _gk[ig] = this->wfc_basis->getgpluskcar(ik, ig);
module_hsolver/hsolver_pw.cpp:            kpt[0] = this->wfc_basis->kvec_c[ik].x;
module_hsolver/hsolver_pw.cpp:            kpt[1] = this->wfc_basis->kvec_c[ik].y;
module_hsolver/hsolver_pw.cpp:            kpt[2] = this->wfc_basis->kvec_c[ik].z;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][0] = this->wfc_basis->getgcar(ik, ipw).x;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][1] = this->wfc_basis->getgcar(ik, ipw).y;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][2] = this->wfc_basis->getgcar(ik, ipw).z;
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2ix(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iy(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iz(ik).data(),
module_hsolver/hsolver_pw.cpp:    for (int ik = 0; ik < this->wfc_basis->nks; ++ik)
module_hsolver/hsolver_pw.cpp:            const int npw = this->wfc_basis->npwk[ik];
module_hsolver/hsolver_pw.cpp:                _gk[ig] = this->wfc_basis->getgpluskcar(ik, ig);
module_hsolver/hsolver_pw.cpp:            kpt[0] = this->wfc_basis->kvec_c[ik].x;
module_hsolver/hsolver_pw.cpp:            kpt[1] = this->wfc_basis->kvec_c[ik].y;
module_hsolver/hsolver_pw.cpp:            kpt[2] = this->wfc_basis->kvec_c[ik].z;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][0] = this->wfc_basis->getgcar(ik, ipw).x;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][1] = this->wfc_basis->getgcar(ik, ipw).y;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][2] = this->wfc_basis->getgcar(ik, ipw).z;
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2ix(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iy(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iz(ik).data(),
module_hsolver/hsolver_pw.cpp:        for (int ik = 0; ik < this->wfc_basis->nks; ++ik)
module_hsolver/hsolver_pw.cpp:            const int npw = this->wfc_basis->npwk[ik];
module_hsolver/hsolver_pw.cpp:                _gk[ig] = this->wfc_basis->getgpluskcar(ik, ig);
module_hsolver/hsolver_pw.cpp:            kpt[0] = this->wfc_basis->kvec_c[ik].x;
module_hsolver/hsolver_pw.cpp:            kpt[1] = this->wfc_basis->kvec_c[ik].y;
module_hsolver/hsolver_pw.cpp:            kpt[2] = this->wfc_basis->kvec_c[ik].z;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][0] = this->wfc_basis->getgcar(ik, ipw).x;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][1] = this->wfc_basis->getgcar(ik, ipw).y;
module_hsolver/hsolver_pw.cpp:                gcar[ipw][2] = this->wfc_basis->getgcar(ik, ipw).z;
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2ix(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iy(ik).data(),
module_hsolver/hsolver_pw.cpp:                                        this->wfc_basis->get_ig2iz(ik).data(),
module_hsolver/hsolver_pw.cpp:    if (this->method == "cg")
module_hsolver/hsolver_pw.cpp:        delete reinterpret_cast<DiagoCG<T, Device>*>(this->pdiagh);
module_hsolver/hsolver_pw.cpp:        this->pdiagh = nullptr;
module_hsolver/hsolver_pw.cpp:    if (this->method == "dav")
module_hsolver/hsolver_pw.cpp:        delete (DiagoDavid<T, Device>*)this->pdiagh;
module_hsolver/hsolver_pw.cpp:        this->pdiagh = nullptr;
module_hsolver/hsolver_pw.cpp:    if (this->method == "dav_subspace")
module_hsolver/hsolver_pw.cpp:        delete (Diago_DavSubspace<T, Device>*)this->pdiagh;
module_hsolver/hsolver_pw.cpp:        this->pdiagh = nullptr;
module_hsolver/hsolver_pw.cpp:    if (this->method == "bpcg")
module_hsolver/hsolver_pw.cpp:        delete (DiagoBPCG<T, Device>*)this->pdiagh;
module_hsolver/hsolver_pw.cpp:        this->pdiagh = nullptr;
module_hsolver/hsolver_pw.cpp:                             << DiagoIterAssist<T, Device>::avg_iter / this->wfc_basis->nks
module_hsolver/hsolver_pw.cpp:    if (!this->initialed_psi)
module_hsolver/hsolver_pw.cpp:        this->initialed_psi = true;
module_hsolver/hsolver_pw.cpp:    else if (!this->initialed_psi) // old psi initialization method branch
module_hsolver/hsolver_pw.cpp:            hamilt::diago_PAO_in_pw_k2(this->ctx, ik, psi, this->wfc_basis, this->pwf, pHamilt);
module_hsolver/hsolver_pw.cpp:    if (this->method != "cg")
module_hsolver/hsolver_pw.cpp:        if (this->method == "dav_subspace")
module_hsolver/hsolver_pw.cpp:            ((Diago_DavSubspace<T, Device>*)this->pdiagh)->diag(hm, psi, eigenvalue, is_occupied);
module_hsolver/hsolver_pw.cpp:            this->pdiagh->diag(hm, psi, eigenvalue);
module_hsolver/hsolver_pw.cpp:    auto cg = reinterpret_cast<DiagoCG<T, Device>*>(this->pdiagh);
module_hsolver/hsolver_pw.cpp:                this->ctx,
module_hsolver/hsolver_pw.cpp:                this->ctx,
module_hsolver/hsolver_pw.cpp:    const auto tpiba2 = static_cast<Real>(this->wfc_basis->tpiba2);
module_hsolver/hsolver_pw.cpp:            Real g2kin = static_cast<Real>(this->wfc_basis->getgk2(ik, ig)) * tpiba2;
module_hsolver/hsolver_pw.cpp:            Real g2kin = static_cast<Real>(this->wfc_basis->getgk2(ik, ig)) * tpiba2;
module_hsolver/hsolver_pw.cpp:            if (this->method == "dav_subspace")
module_hsolver/hsolver_pw.cpp:    return this->diag_ethr * static_cast<Real>(std::max(1.0, GlobalV::nelec));
module_hsolver/hsolver_pw.cpp:        if (std::abs(this->diag_ethr - 1.0e-2) < 1.0e-6)
module_hsolver/hsolver_pw.cpp:                // set a strict this->diag_ethr in the input file ()diago_the_init
module_hsolver/hsolver_pw.cpp:                this->diag_ethr = 1.0e-5;
module_hsolver/hsolver_pw.cpp:                this->diag_ethr = 1.0e-2;
module_hsolver/hsolver_pw.cpp:        // if (GlobalV::FINAL_SCF) this->diag_ethr = 1.0e-2;
module_hsolver/hsolver_pw.cpp:            this->diag_ethr = std::max(this->diag_ethr, static_cast<Real>(GlobalV::PW_DIAG_THR));
module_hsolver/hsolver_pw.cpp:            this->diag_ethr = 1.e-2;
module_hsolver/hsolver_pw.cpp:        this->diag_ethr = std::min(this->diag_ethr,
module_hsolver/hsolver_pw.cpp:        this->diag_ethr = std::max(this->diag_ethr, static_cast<Real>(0.5e-4));
module_hsolver/hsolver_pw.cpp:    return this->diag_ethr;
module_hsolver/hsolver_pw.cpp:    ofs_running << " Origin diag_ethr = " << this->diag_ethr << std::endl;
module_hsolver/hsolver_pw.cpp:    this->diag_ethr = 0.1 * drho / GlobalV::nelec;
module_hsolver/hsolver_pw.cpp:        this->diag_ethr = std::max(this->diag_ethr, static_cast<Real>(0.5e-4));
module_hsolver/hsolver_pw.cpp:    ofs_running << " New    diag_ethr = " << this->diag_ethr << std::endl;
module_hsolver/hsolver_pw.cpp:    return this->diag_ethr;
module_hsolver/hsolver_pw_sdft.cpp:    ModuleBase::TITLE(this->classname, "solve");
module_hsolver/hsolver_pw_sdft.cpp:    ModuleBase::timer::tick(this->classname, "solve");
module_hsolver/hsolver_pw_sdft.cpp:	this->hamilt_ = pHamilt;
module_hsolver/hsolver_pw_sdft.cpp:    this->precondition.resize(psi.get_nbasis());
module_hsolver/hsolver_pw_sdft.cpp:    this->method = method_in;
module_hsolver/hsolver_pw_sdft.cpp:    this->initDiagh(psi);
module_hsolver/hsolver_pw_sdft.cpp:            this->updatePsiK(pHamilt, psi, ik);
module_hsolver/hsolver_pw_sdft.cpp:            update_precondition(precondition, ik, this->wfc_basis->npwk[ik]);
module_hsolver/hsolver_pw_sdft.cpp:            this->hamiltSolvePsiK(pHamilt, psi, p_eigenvalues);
module_hsolver/hsolver_pw_sdft.cpp:		this->endDiagh();
module_hsolver/hsolver_pw_sdft.cpp:    	    ModuleBase::timer::tick(this->classname, "solve");
module_hsolver/hsolver_pw_sdft.cpp:        ModuleBase::timer::tick(this->classname, "solve");
module_hsolver/hsolver_pw_sdft.cpp:    	    	    this->diag_ethr = 1.0e-5;
module_hsolver/hsolver_pw_sdft.cpp:    			this->diag_ethr = std::max(this->diag_ethr, GlobalV::PW_DIAG_THR);
module_hsolver/hsolver_pw_sdft.cpp:				this->diag_ethr = std::max(this->diag_ethr, 1.0e-5);
module_hsolver/hsolver_pw_sdft.cpp:			if(GlobalV::NBANDS > 0 && this->stoiter.KS_ne > 1e-6)
module_hsolver/hsolver_pw_sdft.cpp:    	    	this->diag_ethr = std::min(this->diag_ethr, 0.1 * drho / std::max(1.0, this->stoiter.KS_ne));
module_hsolver/hsolver_pw_sdft.cpp:				this->diag_ethr = 0.0;
module_hsolver/hsolver_pw_sdft.cpp:		return this->diag_ethr;
module_hsolver/hsolver_pw_sdft.h:              this->classname = "HSolverPW_SDFT";
module_hsolver/kernels/cuda/diag_cusolver.cu:            this->finalize();
module_hsolver/kernels/cuda/diag_cusolver.cu:            this->init_double(M);
module_hsolver/kernels/cuda/diag_cusolver.cu:            this->finalize();
module_hsolver/kernels/cuda/diag_cusolver.cu:            this->init_complex(M);
module_hsolver/test/diago_cg_float_test.cpp:        // this->pdiagh = new DiagoCG<std::complex<double>, Device>(precondition.data());
module_hsolver/test/diago_cg_real_test.cpp:        // this->pdiagh = new DiagoCG<double, Device>(precondition.data());
module_hsolver/test/diago_cg_test.cpp:        // this->pdiagh = new DiagoCG<std::complex<double>, Device>(precondition.data());
module_hsolver/test/diago_lcao_cusolver_test.cpp:        hk_in = hamilt::MatrixBlock<T>{this->h_local.data(), (size_t)this->nrow, (size_t)this->ncol, this->desc};
module_hsolver/test/diago_lcao_cusolver_test.cpp:        sk_in = hamilt::MatrixBlock<T>{this->s_local.data(), (size_t)this->nrow, (size_t)this->ncol, this->desc};
module_hsolver/test/diago_lcao_cusolver_test.cpp:        if (this->myrank == 0)
module_hsolver/test/diago_lcao_cusolver_test.cpp:            readhfile = LCAO_DIAGO_TEST::read_hs<std::vector<T>>(hfname, this->h);
module_hsolver/test/diago_lcao_cusolver_test.cpp:            readsfile = LCAO_DIAGO_TEST::read_hs<std::vector<T>>(sfname, this->s);
module_hsolver/test/diago_lcao_cusolver_test.cpp:            hdim = sqrt(this->h.size());
module_hsolver/test/diago_lcao_cusolver_test.cpp:            sdim = sqrt(this->s.size());
module_hsolver/test/diago_lcao_cusolver_test.cpp:        bool ok = this->read_HS();
module_hsolver/test/diago_lcao_cusolver_test.cpp:            LCAO_DIAGO_TEST::print_matrix(fp, this->h.data(), nlocal, nlocal, true);
module_hsolver/test/diago_lcao_cusolver_test.cpp:            LCAO_DIAGO_TEST::print_matrix(fp, this->s.data(), nlocal, nlocal, true);
module_hsolver/test/diago_lcao_cusolver_test.cpp:        this->h_local.resize(local_size);
module_hsolver/test/diago_lcao_cusolver_test.cpp:        this->s_local.resize(local_size);
module_hsolver/test/diago_lcao_cusolver_test.cpp:        LCAO_DIAGO_TEST::distribute_data<T>(this->h.data(),
module_hsolver/test/diago_lcao_cusolver_test.cpp:                                            this->h_local.data(),
module_hsolver/test/diago_lcao_cusolver_test.cpp:        LCAO_DIAGO_TEST::distribute_data<T>(this->s.data(),
module_hsolver/test/diago_lcao_cusolver_test.cpp:                                            this->s_local.data(),
module_hsolver/test/diago_lcao_cusolver_test.cpp:        this->pb2d();
module_hsolver/test/diago_lcao_cusolver_test.cpp:        this->distribute_data();
module_hsolver/test/diago_lcao_cusolver_test.cpp:        this->print_hs();
module_hsolver/test/diago_lcao_cusolver_test.cpp:        this->set_env();
module_hsolver/test/diago_lcao_cusolver_test.cpp:            hmtest.h_local = this->h_local;
module_hsolver/test/diago_lcao_cusolver_test.cpp:            hmtest.s_local = this->s_local;
module_hsolver/test/diago_lcao_cusolver_test.cpp:            LCAO_DIAGO_TEST::lapack_diago(this->h.data(), this->s.data(), this->e_lapack.data(), nlocal);
module_hsolver/test/diago_lcao_test.cpp:        hk_in = hamilt::MatrixBlock<T>{this->h_local.data(),
module_hsolver/test/diago_lcao_test.cpp:                                    (size_t)this->nrow,
module_hsolver/test/diago_lcao_test.cpp:                                    (size_t)this->ncol,
module_hsolver/test/diago_lcao_test.cpp:                                    this->desc};
module_hsolver/test/diago_lcao_test.cpp:        sk_in = hamilt::MatrixBlock<T>{this->s_local.data(),
module_hsolver/test/diago_lcao_test.cpp:                                    (size_t)this->nrow,
module_hsolver/test/diago_lcao_test.cpp:                                    (size_t)this->ncol,
module_hsolver/test/diago_lcao_test.cpp:                                    this->desc};
module_hsolver/test/diago_lcao_test.cpp:        if (this->myrank == 0)
module_hsolver/test/diago_lcao_test.cpp:            readhfile = LCAO_DIAGO_TEST::read_hs<std::vector<T>>(hfname, this->h);
module_hsolver/test/diago_lcao_test.cpp:            readsfile = LCAO_DIAGO_TEST::read_hs<std::vector<T>>(sfname, this->s);
module_hsolver/test/diago_lcao_test.cpp:            hdim = sqrt(this->h.size());
module_hsolver/test/diago_lcao_test.cpp:            sdim = sqrt(this->s.size());
module_hsolver/test/diago_lcao_test.cpp:        bool ok = this->read_HS();
module_hsolver/test/diago_lcao_test.cpp:            LCAO_DIAGO_TEST::print_matrix(fp, this->h.data(), nlocal, nlocal, true);
module_hsolver/test/diago_lcao_test.cpp:            LCAO_DIAGO_TEST::print_matrix(fp, this->s.data(), nlocal, nlocal, true);
module_hsolver/test/diago_lcao_test.cpp:        this->h_local.resize(local_size);
module_hsolver/test/diago_lcao_test.cpp:        this->s_local.resize(local_size);
module_hsolver/test/diago_lcao_test.cpp:        LCAO_DIAGO_TEST::distribute_data<T>(this->h.data(),this->h_local.data(),nlocal,nb2d,hmtest.nrow,hmtest.ncol,icontxt);
module_hsolver/test/diago_lcao_test.cpp:        LCAO_DIAGO_TEST::distribute_data<T>(this->s.data(),this->s_local.data(),nlocal,nb2d,hmtest.nrow,hmtest.ncol,icontxt);
module_hsolver/test/diago_lcao_test.cpp:        this->pb2d();
module_hsolver/test/diago_lcao_test.cpp:        this->distribute_data();
module_hsolver/test/diago_lcao_test.cpp:        this->print_hs();
module_hsolver/test/diago_lcao_test.cpp:        this->set_env();
module_hsolver/test/diago_lcao_test.cpp:            hmtest.h_local = this->h_local;
module_hsolver/test/diago_lcao_test.cpp:            hmtest.s_local = this->s_local;
module_hsolver/test/diago_lcao_test.cpp:            LCAO_DIAGO_TEST::lapack_diago(this->h.data(), this->s.data(), this->e_lapack.data(), nlocal);
module_hsolver/test/diago_mock.h:        this->nband = nbd;
module_hsolver/test/diago_mock.h:        this->npw = npw;
module_hsolver/test/diago_mock.h:        this->sparsity = sparsity;
module_hsolver/test/diago_mock.h:        if(this->hpsi != nullptr) 
module_hsolver/test/diago_mock.h:            delete this->hpsi;
module_hsolver/test/diago_mock.h:            this->hpsi = nullptr;
module_hsolver/test/diago_mock.h:    this->ops = new OperatorMock<double>;
module_hsolver/test/diago_mock.h:    delete this->ops;
module_hsolver/test/diago_mock.h:    this->ops = new OperatorMock<std::complex<double>>;
module_hsolver/test/diago_mock.h:    delete this->ops;
module_hsolver/test/diago_mock.h:    this->ops = new OperatorMock<std::complex<float>>;
module_hsolver/test/diago_mock.h:    delete this->ops;
module_hsolver/test/hsolver_pw_sup.h:    this->nks = 1;
module_hsolver/test/hsolver_pw_sup.h:    this->npwk_max = 3;
module_hsolver/test/hsolver_pw_sup.h:    this->gk2 = new double[3];
module_hsolver/test/hsolver_pw_sup.h:    this->npwk = new int[1];
module_hsolver/test/hsolver_pw_sup.h:    this->npwk[0] = 3;
module_hsolver/test/hsolver_pw_sup.h:    this->tpiba2 = 1.0;
module_hsolver/test/hsolver_pw_sup.h:    delete[] this->gk2;
module_hsolver/test/hsolver_pw_sup.h:    delete[] this->npwk;
module_hsolver/test/hsolver_pw_sup.h:    this->gk2[igl] = (ik + igl) * 1.5;
module_hsolver/test/hsolver_pw_sup.h:    return this->gk2[igl];
module_hsolver/test/hsolver_pw_sup.h:    this->one_ = new T(static_cast<T>(1.0));
module_hsolver/test/hsolver_pw_sup.h:    this->zero_ = new T(static_cast<T>(0.0));
module_hsolver/test/hsolver_pw_sup.h:    this->neg_one_ = new T(static_cast<T>(-1.0));
module_hsolver/test/hsolver_pw_sup.h:    this->one_ = new T(static_cast<T>(1.0));
module_hsolver/test/hsolver_pw_sup.h:    this->zero_ = new T(static_cast<T>(0.0));
module_hsolver/test/hsolver_pw_sup.h:    this->neg_one_ = new T(static_cast<T>(-1.0));
module_hsolver/test/hsolver_pw_sup.h:    delete this->one_;
module_hsolver/test/hsolver_pw_sup.h:    delete this->zero_;
module_hsolver/test/hsolver_pw_sup.h:    delete this->neg_one_;
module_hsolver/test/hsolver_pw_sup.h:    this->device = psi::device::get_device_type<Device>(this->ctx);
module_hsolver/test/hsolver_pw_sup.h:    this->precondition = precondition_in;
module_hsolver/test/hsolver_pw_sup.h:    this->one = new T(1.0, 0.0);
module_hsolver/test/hsolver_pw_sup.h:    this->zero = new T(0.0, 0.0);
module_hsolver/test/hsolver_pw_sup.h:    this->neg_one = new T(-1.0, 0.0);
module_hsolver/test/hsolver_pw_sup.h:    delmem_complex_op()(this->ctx, this->hphi);
module_hsolver/test/hsolver_pw_sup.h:    delmem_complex_op()(this->ctx, this->sphi);
module_hsolver/test/hsolver_pw_sup.h:    delmem_complex_op()(this->ctx, this->hcc);
module_hsolver/test/hsolver_pw_sup.h:    delmem_complex_op()(this->ctx, this->scc);
module_hsolver/test/hsolver_pw_sup.h:    delmem_complex_op()(this->ctx, this->vcc);
module_hsolver/test/hsolver_pw_sup.h:    delmem_complex_op()(this->ctx, this->lagrange_matrix);
module_hsolver/test/hsolver_pw_sup.h:    psi::memory::delete_memory_op<Real, psi::DEVICE_CPU>()(this->cpu_ctx, this->eigenvalue);
module_hsolver/test/hsolver_pw_sup.h:    if (this->device == psi::GpuDevice) {
module_hsolver/test/hsolver_pw_sup.h:        delmem_var_op()(this->ctx, this->d_precondition);
module_hsolver/test/hsolver_pw_sup.h:    delete this->one;
module_hsolver/test/hsolver_pw_sup.h:    delete this->zero;
module_hsolver/test/hsolver_pw_sup.h:    delete this->neg_one;
module_hsolver/test/hsolver_supplementary_mock.h:    // hamilt::MatrixBlock<double> temp{&(this->charge->rho[spin][0]), 1, this->charge->nrxx}; //
module_hsolver/test/hsolver_supplementary_mock.h:    // this->chr->get_nspin(), this->chr->get_nrxx()};
module_hsolver/test/hsolver_supplementary_mock.h:    return &(this->charge->rho[spin][0]);
module_hsolver/test/hsolver_supplementary_mock.h:    this->nks = nks_in;*/
module_hsolver/test/test_hsolver.cpp:    this->hs_cf.pdiagh = new hsolver::DiagH_mock<std::complex<float>>;
module_hsolver/test/test_hsolver.cpp:    this->hs_cf.pdiagh->diag(nullptr, this->psi_test_cf, nullptr);
module_hsolver/test/test_hsolver.cpp:    EXPECT_EQ(this->hs_cf.pdiagh->method, "none");
module_hsolver/test/test_hsolver.cpp:    this->hs_cd.pdiagh = new hsolver::DiagH_mock<std::complex<double>>;
module_hsolver/test/test_hsolver.cpp:    this->hs_cd.pdiagh->diag(nullptr, this->psi_test_cd, nullptr);
module_hsolver/test/test_hsolver.cpp:    EXPECT_EQ(this->hs_cd.pdiagh->method, "none");
module_hsolver/test/test_hsolver.cpp:    this->hs_f.pdiagh = new hsolver::DiagH_mock<float>;
module_hsolver/test/test_hsolver.cpp:    this->hs_f.pdiagh->diag(nullptr, this->psi_test_f, nullptr);
module_hsolver/test/test_hsolver.cpp:    EXPECT_EQ(this->hs_f.pdiagh->method, "none");
module_hsolver/test/test_hsolver.cpp:    this->hs_d.pdiagh = new hsolver::DiagH_mock<double>;
module_hsolver/test/test_hsolver.cpp:    this->hs_d.pdiagh->diag(nullptr, this->psi_test_d, nullptr);
module_hsolver/test/test_hsolver.cpp:    EXPECT_EQ(this->hs_d.pdiagh->method, "none");
module_hsolver/test/test_hsolver_pw.cpp:    this->ekb_f.resize(2);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_f.classname, "HSolverPW");
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_f.diag_ethr, 0.01, 1.0e-7);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_d.classname, "HSolverPW");
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_d.diag_ethr, 0.01, 1.0e-7);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_f.initialed_psi, false);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_d.initialed_psi, false);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.solve(&hamilt_test_f, psi_test_cf, &elecstate_test, method_test, true);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_f.initialed_psi, true);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.solve(&hamilt_test_d, psi_test_cd, &elecstate_test, method_test, true);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_d.initialed_psi, true);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.method = "dav";
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.method = "dav";
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.initialed_psi = false;
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.initialed_psi = false;
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.initDiagh(psi_test_cf);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.initDiagh(psi_test_cd);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_f.initialed_psi, false);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_d.initialed_psi, false);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.hamiltSolvePsiK(&hamilt_test_f, psi_test_cf, ekb_f.data());
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.hamiltSolvePsiK(&hamilt_test_d, psi_test_cd, elecstate_test.ekb.c);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.initialed_psi = true;
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.initialed_psi = true;
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.endDiagh();
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.endDiagh();
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_f.initialed_psi, true);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_EQ(this->hs_d.initialed_psi, true);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.updatePsiK(&hamilt_test_f, psi_test_cf, 0);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.updatePsiK(&hamilt_test_d, psi_test_cd, 0);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.update_precondition(this->hs_f.precondition, 0, psi_test_cf.get_nbasis());
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.update_precondition(this->hs_d.precondition, 0, psi_test_cd.get_nbasis());
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_f.precondition[0], 2.414213657, 1e-8);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_f.precondition[1], 3.618033886, 1e-8);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_f.precondition[2], 6.236067772, 1e-8);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_d.precondition[0], 2.414213562, 1e-8);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_d.precondition[1], 3.618033989, 1e-8);
module_hsolver/test/test_hsolver_pw.cpp:    EXPECT_NEAR(this->hs_d.precondition[2], 6.236067977, 1e-8);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_f.solve(&hamilt_test_f, psi_test_cf, &elecstate_test, transform_test_cf, true);
module_hsolver/test/test_hsolver_pw.cpp:    this->hs_d.solve(&hamilt_test_d, psi_test_cd, &elecstate_test, transform_test_cd, true);
module_hsolver/test/test_hsolver_sdft.cpp:    this->nchip = stowf.nchip;;
module_hsolver/test/test_hsolver_sdft.cpp:    this->targetne = 1;
module_hsolver/test/test_hsolver_sdft.cpp:    this->method = method_in;
module_hsolver/test/test_hsolver_sdft.cpp:	EXPECT_EQ(this->hs_d.classname, "HSolverPW_SDFT");
module_hsolver/test/test_hsolver_sdft.cpp:	EXPECT_NEAR(this->hs_d.diag_ethr, 0.01, 1.0e-7);
module_hsolver/test/test_hsolver_sdft.cpp:	EXPECT_EQ(this->hs_d.initialed_psi, false);
module_hsolver/test/test_hsolver_sdft.cpp:	this->hs_d.solve(
module_hsolver/test/test_hsolver_sdft.cpp:	EXPECT_EQ(this->hs_d.initialed_psi, true);
module_hsolver/test/test_hsolver_sdft.cpp:	EXPECT_EQ(this->hs_d.classname, "HSolverPW_SDFT");
module_hsolver/test/test_hsolver_sdft.cpp:	EXPECT_NEAR(this->hs_d.diag_ethr, 1e-7, 1.0e-10);
module_hsolver/test/test_hsolver_sdft.cpp:	this->hs_d.solve(
module_hsolver/test/test_hsolver_sdft.cpp:    this->hs_d.solve(
module_io/berryphase.cpp:	lcao_method.init(*this->lowf->gridt, this->lowf->wfc_k_grid, kv.nkstot);
module_io/berryphase.cpp:				zeta = zeta * lcao_method.det_berryphase(ik_1,ik_2,dk,nbands, *this->lowf, psi_in, kv);
module_io/berryphase.cpp:	if( GlobalV::BASIS_TYPE == "lcao" ) this->lcao_init(kv);
module_io/bessel_basis.cpp:	this->Dk = dk;
module_io/bessel_basis.cpp:	this->ecut = ecutwfc;
module_io/bessel_basis.cpp:	this->rcut = rcut_in;
module_io/bessel_basis.cpp:	this->tolerence = tol_in;
module_io/bessel_basis.cpp:    this->smooth = smooth;
module_io/bessel_basis.cpp:    this->sigma = sigma;
module_io/bessel_basis.cpp:    //	this->Ecut_number = static_cast<int>( sqrt( 2.0 * ecut )* rcut/ModuleBase::PI );// hartree
module_io/bessel_basis.cpp:    this->Ecut_number = static_cast<int>(sqrt(ecut) * rcut / ModuleBase::PI); // Rydberg Unit.
module_io/bessel_basis.cpp:    assert(this->Ecut_number > 0);
module_io/bessel_basis.cpp:	this->init_TableOne( smooth, sigma, ecutwfc, rcut, dr, Dk, lmax_in, Ecut_number, tolerence);
module_io/bessel_basis.cpp:		this->allocate_C4(ntype, lmax_in, ucell.nmax, Ecut_number, ucell);
module_io/bessel_basis.cpp:		this->readin_C4("INPUTs", ntype, ecut, rcut, Ecut_number, tolerence, ucell);
module_io/bessel_basis.cpp:		this->init_Faln(ntype, lmax_in, ucell.nmax, Ecut_number, ucell);
module_io/bessel_basis.cpp:	const double position =  gnorm / this->Dk;
module_io/bessel_basis.cpp:		this->TableOne(l, ie, iq) * x1 * x2 * x3 / 6.0 +
module_io/bessel_basis.cpp:        this->TableOne(l, ie, iq) * x0 * x2 * x3 / 2.0 -
module_io/bessel_basis.cpp:        this->TableOne(l, ie, iq) * x1 * x0 * x3 / 2.0 +
module_io/bessel_basis.cpp:        this->TableOne(l, ie, iq) * x1 * x2 * x0 / 6.0 ;
module_io/bessel_basis.cpp:	const double position =  gnorm / this->Dk;
module_io/bessel_basis.cpp:		this->Faln(it, l, ic, iq) * x1 * x2 * x3 / 6.0 +
module_io/bessel_basis.cpp:        this->Faln(it, l, ic, iq) * x0 * x2 * x3 / 2.0 -
module_io/bessel_basis.cpp:        this->Faln(it, l, ic, iq) * x1 * x0 * x3 / 2.0 +
module_io/bessel_basis.cpp:        this->Faln(it, l, ic, iq) * x1 * x2 * x0 / 6.0 ;
module_io/bessel_basis.cpp:	assert( this->kmesh > 0);
module_io/bessel_basis.cpp:	this->Faln.create(ntype, lmax+1, nmax, this->kmesh);
module_io/bessel_basis.cpp:	this->nwfc = 0;
module_io/bessel_basis.cpp:					for(int ik=0; ik< this->kmesh; ik++)
module_io/bessel_basis.cpp:						this->Faln(it, il, in, ik) += this->C4(it, il, in, ie) * this->TableOne(il, ie, ik);
module_io/bessel_basis.cpp:	this->kmesh = static_cast<int>(sqrt(ecutwfc) / dk) +1 + 4;
module_io/bessel_basis.cpp:	this->TableOne.create(lmax+1, ecut_number, kmesh);
module_io/bessel_basis.cpp:				ModuleBase::Integral::Simpson_Integral(rmesh, function.data(), rab.data(), this->TableOne(l, ie, ik) );
module_io/bessel_basis.cpp:						assert( tmp_ecut == this->ecut );
module_io/bessel_basis.cpp:						assert( tmp_rcut == this->rcut );
module_io/bessel_basis.cpp:						assert( tmp_enumber == this->Ecut_number);
module_io/bessel_basis.cpp:						assert( tmp_tolerence == this->tolerence );
module_io/bessel_basis.cpp:									inc4 >> this->C4(it, il, in, ie);
module_io/bessel_basis.cpp:									//std::cout << "\n" << std::setw(5) << ie << std::setw(25) << this->C4(it, il, in, ie);
module_io/bessel_basis.cpp:	this->C4.create(ntype, lmax+1, nmax, ecut_number);
module_io/bessel_basis.cpp:					this->C4(it, il, in, ie) = 1.0;
module_io/binstream.h:	size_t ch = fread(&data,size,1,this->fileptr);
module_io/binstream.h:    fwrite(&data,size,1,this->fileptr);
module_io/binstream.h:	size_t ch = fread(data,size,n,this->fileptr);
module_io/binstream.h:    fwrite(data,size,n,this->fileptr);
module_io/cal_r_overlap_R.cpp:    this->ParaV = &pv;
module_io/cal_r_overlap_R.cpp:            ir = this->ParaV->global2local_row(iw1);
module_io/cal_r_overlap_R.cpp:                    ic = this->ParaV->global2local_col(iw2);
module_io/cal_r_overlap_R.cpp:                    ModuleIO::output_single_R(ofs_tem1, psi_r_psi_sparse[direction], sparse_threshold, binary, *(this->ParaV));
module_io/cal_r_overlap_R.cpp:            ir = this->ParaV->global2local_row(iw1);
module_io/cal_r_overlap_R.cpp:                    ic = this->ParaV->global2local_col(iw2);
module_io/cal_r_overlap_R.cpp:                ModuleIO::output_single_R(out_r, psi_r_psi_sparse[direction], sparse_threshold, binary, *(this->ParaV));
module_io/fR_overlap.cpp:    this->fr = fr_in;
module_io/fR_overlap.cpp:    this->ucell = ucell_in;
module_io/fR_overlap.cpp:    this->FR_container = new hamilt::HContainer<T>(paraV);
module_io/fR_overlap.cpp:    this->radial_grid_num = radial_grid_num;
module_io/fR_overlap.cpp:    this->Leb_grid = new ModuleBase::Lebedev_laikov_grid(degree);
module_io/fR_overlap.cpp:    this->Leb_grid->generate_grid_points();
module_io/fR_overlap.cpp:    this->initialize_FR(GridD_in, paraV);
module_io/fR_overlap.cpp:    this->fr = FR_in.fr;
module_io/fR_overlap.cpp:    this->ucell = FR_in.ucell;
module_io/fR_overlap.cpp:    this->FR_container = new hamilt::HContainer<T>(*(FR_in.FR_container));
module_io/fR_overlap.cpp:    this->radial_grid_num = FR_in.radial_grid_num;
module_io/fR_overlap.cpp:    this->Leb_grid = new ModuleBase::Lebedev_laikov_grid(FR_in.Leb_grid->degree);
module_io/fR_overlap.cpp:    this->Leb_grid->generate_grid_points();
module_io/fR_overlap.cpp:    this->fr = std::move(FR_in.fr);
module_io/fR_overlap.cpp:    this->ucell = FR_in.ucell;
module_io/fR_overlap.cpp:    this->FR_container = std::move(FR_in.FR_container);
module_io/fR_overlap.cpp:    this->radial_grid_num = FR_in.radial_grid_num;
module_io/fR_overlap.cpp:    this->Leb_grid = new ModuleBase::Lebedev_laikov_grid(FR_in.Leb_grid->degree);
module_io/fR_overlap.cpp:    this->Leb_grid->generate_grid_points();
module_io/fR_overlap.cpp:    if (this->Leb_grid)
module_io/fR_overlap.cpp:        delete this->Leb_grid;
module_io/fR_overlap.cpp:    if (this->FR_container)
module_io/fR_overlap.cpp:        delete this->FR_container;
module_io/fR_overlap.cpp:            if (this->ucell->cal_dtau(iat1, iat2, R_index).norm() * this->ucell->lat0
module_io/fR_overlap.cpp:    for (int iap = 0; iap < this->FR_container->size_atom_pairs(); ++iap)
module_io/fR_overlap.cpp:        hamilt::AtomPair<T>& tmp = this->FR_container->get_atom_pair(iap);
module_io/fR_overlap.cpp:            this->cal_FR_IJR(iat1, iat2, paraV, dtau, data_pointer);
module_io/fR_overlap.cpp:    this->ucell->iat2iait(iat1, &I1, &T1);
module_io/fR_overlap.cpp:    this->ucell->iat2iait(iat2, &I2, &T2);
module_io/fR_overlap.cpp:    Atom& atom1 = this->ucell->atoms[T1];
module_io/fR_overlap.cpp:    Atom& atom2 = this->ucell->atoms[T2];
module_io/fR_overlap.cpp:    ModuleBase::Vector3<double> tau_1 = this->ucell->get_tau(iat1) * this->ucell->lat0;
module_io/fR_overlap.cpp:    const int npol = this->ucell->get_npol();
module_io/fR_overlap.h:        return this->FR_container;
module_io/input.cpp:    this->Default();
module_io/input.cpp:    // only rank 0 reads the input file, check the code in this->Read()
module_io/input.cpp:    bool success = this->Read(fn);
module_io/input.cpp:    this->Default_2();
module_io/input.cpp:    this->Bcast();
module_io/input.cpp:    ModuleBase::Global_File::make_dir_out(this->suffix,
module_io/input.cpp:                                          this->calculation,
module_io/input.cpp:                                          this->mdp.md_restart,
module_io/input.cpp:                                          this->out_alllog); // xiaohui add 2013-09-01
module_io/input.cpp:            read_value(ifs, this->relax_nmax);
module_io/input.cpp:    if (this->stru_file == "")
module_io/input.cpp:        this->stru_file = "STRU";
module_io/input.cpp:    double ntype_stru = this->count_ntype(this->stru_file);
module_io/input.cpp:    if (this->ntype == 0)
module_io/input.cpp:        this->ntype = ntype_stru;
module_io/input.cpp:        GlobalV::ofs_running << "ntype in INPUT is 0, and it is automatically set to " << this->ntype
module_io/input.cpp:    else if (this->ntype != ntype_stru)
module_io/input.cpp:        this->relax_nmax = 1;
module_io/input.cpp:        if (!this->relax_nmax)
module_io/input.cpp:            this->relax_nmax = 50;
module_io/input.cpp:        this->relax_nmax = 1;
module_io/input.cpp:        this->relax_nmax = 1;
module_io/input.cpp:        this->relax_nmax = 1;
module_io/input.cpp:        if (!this->relax_nmax)
module_io/input.cpp:            this->relax_nmax = 50;
module_io/input.cpp:        this->relax_nmax = 1;
module_io/input.cpp:        this->relax_nmax = 1;
module_io/input.cpp:        this->relax_nmax = 1;
module_io/input.cpp:    Parallel_Common::bcast_int(this->relax_nmax);
module_io/input.cpp:        hubbard_u = new double[this->ntype];
module_io/input.cpp:        orbital_corr = new int[this->ntype];
module_io/input.cpp:    for (int i = 0; i < this->ntype; i++)
module_io/input.cpp:    ModuleBase::Global_File::close_all_log(GlobalV::MY_RANK, this->out_alllog);
module_io/istate_charge.cpp:    this->bands_picked_.resize(nbands);
module_io/istate_charge.cpp:            this->idmatrix(ib, nspin, nelec, nlocal, wg);
module_io/istate_charge.cpp:            Gint_inout inout(this->loc->DM, rho, Gint_Tools::job_type::rho);
module_io/istate_charge.cpp:        std::vector<double> wg_local(this->loc->ParaV->ncol, 0.0);
module_io/istate_charge.cpp:        const int ib_local = this->loc->ParaV->global2local_col(ib);
module_io/istate_charge.cpp:        this->psi_gamma->fix_k(is);
module_io/istate_charge.cpp:        psi::Psi<double> wg_wfc(*this->psi_gamma, 1);
module_io/istate_charge.cpp:        this->loc->dm_gamma.at(is).create(wg_wfc.get_nbands(), wg_wfc.get_nbasis());
module_io/istate_charge.cpp:                this->loc->ParaV->desc,
module_io/istate_charge.cpp:                this->psi_gamma->get_pointer(),
module_io/istate_charge.cpp:                this->loc->ParaV->desc,
module_io/istate_charge.cpp:                this->loc->dm_gamma.at(is).c,
module_io/istate_charge.cpp:                this->loc->ParaV->desc);
module_io/istate_charge.cpp:    this->loc->cal_dk_gamma_from_2D_pub();
module_io/istate_envelope.cpp:    this->bands_picked = new bool[nbands];
module_io/istate_envelope.cpp:                lowf.wfc_2d_to_grid(-1, 0, psid->get_pointer(), wfc_gamma_grid[is], this->pes->ekb, this->pes->wg);
module_io/istate_envelope.cpp:                const double ef_tmp = this->pes->eferm.get_efval(is);
module_io/istate_envelope.cpp:                    this->set_pw_wfc(wfcpw, 0, ib, nspin,
module_io/istate_envelope.cpp:    this->bands_picked = new bool[nbands];
module_io/istate_envelope.cpp:                                    this->pes->ekb,
module_io/istate_envelope.cpp:                                    this->pes->wg,
module_io/istate_envelope.cpp:                const double ef_tmp = this->pes->eferm.get_efval(ispin);
module_io/istate_envelope.cpp:                    this->set_pw_wfc(wfcpw, ik, ib, nspin,
module_io/json_output/test/para_json_test.cpp:	this->tot_magnetization = 0.0;
module_io/json_output/test/para_json_test.cpp:	this->abs_magnetization = 0.0;
module_io/json_output/test/para_json_test.cpp:	this->start_magnetization = nullptr;
module_io/json_output/test/para_json_test.cpp:	delete[] this->start_magnetization;
module_io/numerical_basis.cpp:    if (!this->init_label)
module_io/numerical_basis.cpp:        this->bessel_basis.init(
module_io/numerical_basis.cpp:        this->mu_index = this->init_mu_index();
module_io/numerical_basis.cpp:        this->init_label = true;
module_io/numerical_basis.cpp:    this->numerical_atomic_wfc(ik, wfcpw, psi, sf);
module_io/numerical_basis.cpp:    if (!this->init_label)
module_io/numerical_basis.cpp:        this->bessel_basis.init(
module_io/numerical_basis.cpp:        this->mu_index = this->init_mu_index();
module_io/numerical_basis.cpp:        this->init_label = true;
module_io/numerical_basis.cpp:        ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,"number of eigenvalues of Jl(x)", this->bessel_basis.get_ecut_number());
module_io/numerical_basis.cpp:                = this->cal_overlap_Q(ik, npw, wfcpw, psi, static_cast<double>(derivative_order), sf);
module_io/numerical_basis.cpp:                overlap_Sq[ik] = this->cal_overlap_Sq( ik, npw, static_cast<double>(derivative_order), sf, wfcpw);
module_io/numerical_basis.cpp:        const ModuleBase::matrix overlap_V = this->cal_overlap_V(wfcpw,
module_io/numerical_basis.cpp:        if(ofs.good()) this->output_info(ofs, bessel_basis, kv); // header of orb_matrix* file
module_io/numerical_basis.cpp:        if(ofs.good()) this->output_k(ofs, kv); // <WEIGHTS_OF_KPOINTS>...</WEIGHTS_OF_KPOINTS>
module_io/numerical_basis.cpp:        if(ofs.good()) this->output_overlap_Q(ofs, overlap_Q, kv); // <OVERLAP_Q>...</OVERLAP_Q>
module_io/numerical_basis.cpp:            if(ofs.good()) this->output_overlap_Sq(ss.str(), ofs, overlap_Sq, kv); // <OVERLAP_Sq>...</OVERLAP_Sq>
module_io/numerical_basis.cpp:        if(ofs.good()) this->output_overlap_V(ofs, overlap_V); // <OVERLAP_V>...</OVERLAP_V>
module_io/numerical_basis.cpp:    ModuleBase::ComplexArray overlap_Q(GlobalV::NBANDS, GlobalV::NLOCAL, this->bessel_basis.get_ecut_number() );
module_io/numerical_basis.cpp:	const ModuleBase::realArray flq = this->cal_flq(ik, gk);
module_io/numerical_basis.cpp:                for (int ie=0; ie < this->bessel_basis.get_ecut_number(); ie++)
module_io/numerical_basis.cpp:                            overlap_Q(ib, this->mu_index[T](I, L, N, m), ie) = overlap_tmp;
module_io/numerical_basis.cpp:    const int enumber = this->bessel_basis.get_ecut_number();
module_io/numerical_basis.cpp:	const ModuleBase::realArray flq = this->cal_flq(ik, gk);
module_io/numerical_basis.cpp:                                        const int iwt1 = this->mu_index[T1](I1,l1,ic1,m1);
module_io/numerical_basis.cpp:                                            const int iwt2 = this->mu_index[T2](I2,l2,ic2,m2);
module_io/numerical_basis.cpp:	const int enumber = this->bessel_basis.get_ecut_number();
module_io/numerical_basis.cpp:                flq(il,ie,ig) = this->bessel_basis.Polynomial_Interpolation2(il, ie, gk[ig].norm() * GlobalC::ucell.tpiba );
module_io/numerical_basis.cpp:                        flq[ig] = this->bessel_basis.
module_io/numerical_basis.cpp:                            psi( this->mu_index[it](ia,l,ic,m), ig) =
module_io/numerical_descriptor.cpp:	this->init_label = false;
module_io/numerical_descriptor.cpp:	this->lmax = -1;
module_io/numerical_descriptor.cpp:	this->nmax = -1;
module_io/numerical_descriptor.cpp:	this->lmax = lmax_in;
module_io/numerical_descriptor.cpp:    this->bessel_basis.init(
module_io/numerical_descriptor.cpp:		this->lmax,
module_io/numerical_descriptor.cpp:	this->nmax = Numerical_Descriptor::bessel_basis.get_ecut_number();
module_io/numerical_descriptor.cpp:    this->init_mu_index();
module_io/numerical_descriptor.cpp:    this->init_label = true;
module_io/numerical_descriptor.cpp:    ModuleBase::realArray overlap_Q1(nks, GlobalV::NBANDS, this->nlocal );
module_io/numerical_descriptor.cpp:    ModuleBase::realArray overlap_Q2(nks, GlobalV::NBANDS, this->nlocal );
module_io/numerical_descriptor.cpp:        this->jlq3d_overlap(overlap_Q1, overlap_Q2, ik, ik, npw, psi);
module_io/numerical_descriptor.cpp:    //this->output_overlap_Q( ofs, overlap_Q1, overlap_Q2 );
module_io/numerical_descriptor.cpp:			this->generate_descriptor(overlap_Q1, overlap_Q2, it ,ia, d, nd);
module_io/numerical_descriptor.cpp:    const int total_lm = ( this->lmax + 1) * ( this->lmax + 1);
module_io/numerical_descriptor.cpp:	GlobalV::ofs_running << " lmax = " << this->lmax << std::endl;
module_io/numerical_descriptor.cpp:	GlobalV::ofs_running << " nmax = " << this->nmax << std::endl;
module_io/numerical_descriptor.cpp:		this->mu_index[it].create(
module_io/numerical_descriptor.cpp:										this->mu_index[it](ia,l,n,m) = mu;
module_io/numerical_descriptor.cpp:	this->nlocal = mu;
module_io/output_dm.cpp:        this->_fn = this->_directory + "/SPIN" + std::to_string(this->_is + 1) + "_DM";
module_io/output_dm.cpp:        this->_fn = this->_directory + "/SPIN" + std::to_string(this->_is + 1) + "_DM_R";
module_io/output_mat_sparse.cpp:				this->_v_eff, 
module_io/output_mat_sparse.cpp:                this->_pv,
module_io/output_mat_sparse.cpp:				this->_lm, 
module_io/output_mat_sparse.cpp:                this->_grid,
module_io/output_mat_sparse.cpp:                this->_pv, 
module_io/output_mat_sparse.cpp:				this->_lm, 
module_io/output_mat_sparse.cpp:				this->_grid,
module_io/output_mat_sparse.cpp:				this->_gen_h); // LiuXh add 2019-07-15
module_io/output_mat_sparse.cpp:				this->_v_eff, 
module_io/output_mat_sparse.cpp:                this->_gen_h,
module_io/output_mat_sparse.cpp:				this->_gint_k, // mohan add 2024-04-01
module_io/output_mat_sparse.cpp:				this->_lm,
module_io/output_mat_sparse.cpp:                this->_grid, // mohan add 2024-04-06
module_io/output_mat_sparse.cpp:        r_matrix.init(this->_pv);
module_io/output_mat_sparse.cpp:            r_matrix.out_rR_other(_istep, this->_lm.output_R_coor);
module_io/output_rho.cpp:        this->_fn = this->_directory + "/" + _prefix + "SPIN" + std::to_string(this->_is + 1) + "_" + _tag + ".cube";
module_io/output_rho.cpp:        this->_fn = this->_directory + "/SPIN" + std::to_string(this->_is + 1) + "_" + _tag + ".cube";
module_io/td_current_io.cpp:        int ik_begin = DM.get_DMK_nks() * (is - 1); // jump this->_nks for spin_down if nspin==2
module_io/test/dos_test.h:		this->isk.reserve(nks);
module_io/test/dos_test.h:		this->wk.reserve(nks);
module_io/test/dos_test.h:				ifs>>dummy >>kx >>ky >>kz >>this->wk[ik];
module_io/test/dos_test.h:		this->ekb.create(nks,nbands);
module_io/test/dos_test.h:		this->wg.create(nks,nbands);
module_io/test/dos_test.h:					ifs>> dummy >> this->ekb(ik,ib) >> this->wg(ik,ib);
module_io/test/dos_test.h:		this->ekb *= 1.0/ModuleBase::Ry_to_eV; 
module_io/test/for_testing_input_conv.h:    this->latName = latname_in;
module_io/test/for_testing_input_conv.h:    this->ntype = ntype_in;
module_io/test/for_testing_input_conv.h:    this->lmaxmax = lmaxmax_in;
module_io/test/for_testing_input_conv.h:    this->init_vel = init_vel_in;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 1;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[0] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[1] = 0;
module_io/test/for_testing_input_conv.h:        this->lc[2] = 0;
module_io/test/prepare_unitcell.h:		this->ntype = this->elements.size();
module_io/test/prepare_unitcell.h:		ucell->setup(this->latname,
module_io/test/prepare_unitcell.h:				this->ntype,
module_io/test/prepare_unitcell.h:				this->lmaxmax,
module_io/test/prepare_unitcell.h:				this->init_vel,
module_io/test/prepare_unitcell.h:				this->fixed_axes);
module_io/test/prepare_unitcell.h:			ucell->atom_label[it] = this->elements[it];
module_io/test/prepare_unitcell.h:			ucell->atom_mass[it] = this->atomic_mass[it];
module_io/test/prepare_unitcell.h:			ucell->pseudo_fn[it] = this->pp_files[it];
module_io/test/prepare_unitcell.h:			ucell->pseudo_type[it] = this->pp_types[it];
module_io/test/prepare_unitcell.h:			ucell->orbital_fn[it] = this->orb_files[it];
module_io/test/prepare_unitcell.h:		ucell->lat0 = this->lat0;
module_io/test/prepare_unitcell.h:		ucell->latvec.e11 = this->latvec[0];
module_io/test/prepare_unitcell.h:		ucell->latvec.e12 = this->latvec[1];
module_io/test/prepare_unitcell.h:		ucell->latvec.e13 = this->latvec[2];
module_io/test/prepare_unitcell.h:		ucell->latvec.e21 = this->latvec[3];
module_io/test/prepare_unitcell.h:		ucell->latvec.e22 = this->latvec[4];
module_io/test/prepare_unitcell.h:	       	ucell->latvec.e23 = this->latvec[5];
module_io/test/prepare_unitcell.h:		ucell->latvec.e31 = this->latvec[6];
module_io/test/prepare_unitcell.h:		ucell->latvec.e32 = this->latvec[7];
module_io/test/prepare_unitcell.h:		ucell->latvec.e33 = this->latvec[8];
module_io/test/prepare_unitcell.h:		ucell->Coordinate = this->coor_type;
module_io/test/prepare_unitcell.h:		this->atomic_index = 0;
module_io/test/prepare_unitcell.h:			ucell->atoms[it].label = this->elements[it];
module_io/test/prepare_unitcell.h:			ucell->atoms[it].na = this->natom[it];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].x = this->coordinates[this->atomic_index*3+0];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].y = this->coordinates[this->atomic_index*3+1];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].taud[ia].z = this->coordinates[this->atomic_index*3+2];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].x = this->coordinates[this->atomic_index*3+0];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].y = this->coordinates[this->atomic_index*3+1];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].tau[ia].z = this->coordinates[this->atomic_index*3+2];
module_io/test/prepare_unitcell.h:				if(this->init_vel)
module_io/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].x = this->velocity[this->atomic_index*3+0];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].y = this->velocity[this->atomic_index*3+1];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].vel[ia].z = this->velocity[this->atomic_index*3+2];
module_io/test/prepare_unitcell.h:				if(this->selective_dynamics)
module_io/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].x = this->mbl[this->atomic_index*3+0];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].y = this->mbl[this->atomic_index*3+1];
module_io/test/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].z = this->mbl[this->atomic_index*3+2];
module_io/test/prepare_unitcell.h:				++(this->atomic_index);
module_io/test/prepare_unitcell.h:		ucell->nat = this->natom.sum();
module_io/test/single_R_io_test.cpp:    this->global2local_row_ = new int[M_A];
module_io/test/single_R_io_test.cpp:    this->global2local_row_[0] = 0;
module_io/test/single_R_io_test.cpp:    this->global2local_row_[1] = 1;
module_io/test/single_R_io_test.cpp:    this->global2local_row_[2] = -1;
module_io/test/single_R_io_test.cpp:    this->global2local_row_[3] = 2;
module_io/test/single_R_io_test.cpp:    this->global2local_row_[4] = -1; //Some rows have global2local_row_ < 0
module_io/test/sparse_matrix_test.cpp:    this->sm.insert(2, 2, static_cast<TypeParam>(3.0));
module_io/test/sparse_matrix_test.cpp:    this->sm.insert(3, 3, static_cast<TypeParam>(4.0));
module_io/test/sparse_matrix_test.cpp:    EXPECT_EQ(this->sm.getNNZ(), 2);
module_io/test/sparse_matrix_test.cpp:    EXPECT_EQ(this->sm.getCols(), 4);
module_io/test/sparse_matrix_test.cpp:    EXPECT_EQ(this->sm.getRows(), 4);
module_io/test/sparse_matrix_test.cpp:    EXPECT_DOUBLE_EQ(get_value(this->sm(2, 2)), 3.0);
module_io/test/sparse_matrix_test.cpp:    EXPECT_DOUBLE_EQ(get_value(this->sm(3, 3)), 4.0);
module_io/test/sparse_matrix_test.cpp:    EXPECT_EXIT(this->sm.insert(2, -1, static_cast<TypeParam>(3.0)), ::testing::ExitedWithCode(0), "");
module_io/test/sparse_matrix_test.cpp:    EXPECT_EXIT(this->sm.insert(-1, 0, static_cast<TypeParam>(3.0)), ::testing::ExitedWithCode(0), "");
module_io/test/sparse_matrix_test.cpp:    EXPECT_EXIT(this->sm.insert(2, 4, static_cast<TypeParam>(3.0)), ::testing::ExitedWithCode(0), "");
module_io/test/sparse_matrix_test.cpp:    EXPECT_EXIT(this->sm.insert(4, 2, static_cast<TypeParam>(3.0)), ::testing::ExitedWithCode(0), "");
module_io/test/write_orb_info_test.cpp:	this->tot_magnetization = 0.0;
module_io/test/write_orb_info_test.cpp:	this->abs_magnetization = 0.0;
module_io/test/write_orb_info_test.cpp:	this->start_magnetization = nullptr;
module_io/test/write_orb_info_test.cpp:	delete[] this->start_magnetization;
module_io/test_serial/dm_io_test.cpp:	this->tot_magnetization = 0.0;
module_io/test_serial/dm_io_test.cpp:	this->abs_magnetization = 0.0;
module_io/test_serial/dm_io_test.cpp:	this->start_magnetization = nullptr;
module_io/test_serial/dm_io_test.cpp:	delete[] this->start_magnetization;
module_io/test_serial/prepare_unitcell.h:		this->ntype = this->elements.size();
module_io/test_serial/prepare_unitcell.h:		ucell->setup(this->latname,
module_io/test_serial/prepare_unitcell.h:				this->ntype,
module_io/test_serial/prepare_unitcell.h:				this->lmaxmax,
module_io/test_serial/prepare_unitcell.h:				this->init_vel,
module_io/test_serial/prepare_unitcell.h:				this->fixed_axes);
module_io/test_serial/prepare_unitcell.h:			ucell->atom_label[it] = this->elements[it];
module_io/test_serial/prepare_unitcell.h:			ucell->atom_mass[it] = this->atomic_mass[it];
module_io/test_serial/prepare_unitcell.h:			ucell->pseudo_fn[it] = this->pp_files[it];
module_io/test_serial/prepare_unitcell.h:			ucell->pseudo_type[it] = this->pp_types[it];
module_io/test_serial/prepare_unitcell.h:			ucell->orbital_fn[it] = this->orb_files[it];
module_io/test_serial/prepare_unitcell.h:		ucell->lat0 = this->lat0;
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e11 = this->latvec[0];
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e12 = this->latvec[1];
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e13 = this->latvec[2];
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e21 = this->latvec[3];
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e22 = this->latvec[4];
module_io/test_serial/prepare_unitcell.h:	       	ucell->latvec.e23 = this->latvec[5];
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e31 = this->latvec[6];
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e32 = this->latvec[7];
module_io/test_serial/prepare_unitcell.h:		ucell->latvec.e33 = this->latvec[8];
module_io/test_serial/prepare_unitcell.h:		ucell->Coordinate = this->coor_type;
module_io/test_serial/prepare_unitcell.h:		this->atomic_index = 0;
module_io/test_serial/prepare_unitcell.h:			ucell->atoms[it].label = this->elements[it];
module_io/test_serial/prepare_unitcell.h:			ucell->atoms[it].na = this->natom[it];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].taud[ia].x = this->coordinates[this->atomic_index*3+0];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].taud[ia].y = this->coordinates[this->atomic_index*3+1];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].taud[ia].z = this->coordinates[this->atomic_index*3+2];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].tau[ia].x = this->coordinates[this->atomic_index*3+0];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].tau[ia].y = this->coordinates[this->atomic_index*3+1];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].tau[ia].z = this->coordinates[this->atomic_index*3+2];
module_io/test_serial/prepare_unitcell.h:				if(this->init_vel)
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].vel[ia].x = this->velocity[this->atomic_index*3+0];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].vel[ia].y = this->velocity[this->atomic_index*3+1];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].vel[ia].z = this->velocity[this->atomic_index*3+2];
module_io/test_serial/prepare_unitcell.h:				if(this->selective_dynamics)
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].x = this->mbl[this->atomic_index*3+0];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].y = this->mbl[this->atomic_index*3+1];
module_io/test_serial/prepare_unitcell.h:					ucell->atoms[it].mbl[ia].z = this->mbl[this->atomic_index*3+2];
module_io/test_serial/prepare_unitcell.h:				++(this->atomic_index);
module_io/test_serial/prepare_unitcell.h:		ucell->nat = this->natom.sum();
module_io/test_serial/read_wfc_nao_test.cpp:      const double* ElecState::getRho(int spin) const{return &(this->eferm.ef);}//just for mock
module_io/test_serial/rho_io_test.cpp:    this->tot_magnetization = 0.0;
module_io/test_serial/rho_io_test.cpp:    this->abs_magnetization = 0.0;
module_io/test_serial/rho_io_test.cpp:    this->start_magnetization = nullptr;
module_io/test_serial/rho_io_test.cpp:    delete[] this->start_magnetization;
module_io/to_wannier90.cpp:    this->out_wannier_mmn = out_wannier_mmn;
module_io/to_wannier90.cpp:    this->out_wannier_amn = out_wannier_amn;
module_io/to_wannier90.cpp:    this->out_wannier_unk = out_wannier_unk;
module_io/to_wannier90.cpp:    this->out_wannier_eig = out_wannier_eig;
module_io/to_wannier90.cpp:    this->out_wannier_wvfn_formatted = out_wannier_wvfn_formatted;
module_io/to_wannier90.cpp:    this->nnkpfile = nnkpfile;
module_io/to_wannier90.cpp:    this->wannier_file_name = nnkpfile;
module_io/to_wannier90.cpp:    this->wannier_file_name = wannier_file_name.substr(0, wannier_file_name.length() - 5);
module_io/to_wannier90.cpp:    this->wannier_spin = wannier_spin;
module_io/to_wannier90_lcao.cpp:    this->ParaV = pv;
module_io/to_wannier90_lcao.cpp:        this->FR.resize(dk_size);
module_io/to_wannier90_lcao.cpp:    int row = this->ParaV->get_row_size();
module_io/to_wannier90_lcao.cpp:    int col = this->ParaV->get_col_size();
module_io/to_wannier90_lcao.cpp:            &psi_in(ik, 0, 0), &one, &one, this->ParaV->desc,
module_io/to_wannier90_lcao.cpp:            midmatrix, &one, &one, this->ParaV->desc,
module_io/to_wannier90_lcao.cpp:            C_matrix, &one, &one, this->ParaV->desc);
module_io/to_wannier90_lcao.cpp:            C_matrix, &one, &one, this->ParaV->desc,
module_io/to_wannier90_lcao.cpp:            &psi_in(ikb, 0, 0), &one, &one, this->ParaV->desc,
module_io/to_wannier90_lcao.cpp:            out_matrix, &one, &one, this->ParaV->desc);
module_io/to_wannier90_lcao.cpp:        int ir = this->ParaV->global2local_row(m);
module_io/to_wannier90_lcao.cpp:                int ic = this->ParaV->global2local_col(n);
module_io/to_wannier90_lcao.cpp:    int row = this->ParaV->get_row_size();
module_io/to_wannier90_lcao.cpp:    int row = this->ParaV->get_row_size();
module_io/to_wannier90_lcao.cpp:    int row = this->ParaV->get_row_size();
module_io/to_wannier90_lcao.cpp:            int ic = this->ParaV->global2local_col(ib);
module_io/to_wannier90_lcao.cpp:            int ic = this->ParaV->global2local_col(ib);
module_io/to_wannier90_lcao_in_pw.cpp:    this->ParaV = pv;
module_io/to_wannier90_lcao_in_pw.cpp:    this->psi_init_ = new psi_initializer_nao<std::complex<double>, psi::DEVICE_CPU>();
module_io/to_wannier90_lcao_in_pw.cpp:    this->psi_init_->initialize(sf_ptr, wfcpw_ptr, &(GlobalC::ucell), &(GlobalC::Pkpoints), 1, nullptr, GlobalV::MY_RANK);
module_io/to_wannier90_lcao_in_pw.cpp:    this->psi_init_->initialize(sf_ptr, wfcpw_ptr, &(GlobalC::ucell), 1, nullptr);
module_io/to_wannier90_lcao_in_pw.cpp:    this->psi_init_->tabulate();
module_io/to_wannier90_lcao_in_pw.cpp:    this->psi_init_->allocate(true);
module_io/to_wannier90_lcao_in_pw.cpp:    this->psi_init_->proj_ao_onkG(ik);
module_io/to_wannier90_lcao_in_pw.cpp:    std::weak_ptr<psi::Psi<std::complex<double>>> psig = this->psi_init_->share_psig();
module_io/to_wannier90_lcao_in_pw.cpp:    int row = this->ParaV->get_row_size();
module_io/to_wannier90_lcao_in_pw.cpp:        int ic = this->ParaV->global2local_col(ib);
module_io/to_wannier90_lcao_in_pw.cpp:                global_row_index = this->ParaV->local2global_row(ir);
module_io/unk_overlap_lcao.cpp:        for (int ik = 0; ik < this->kpoints_number; ik++)
module_io/unk_overlap_lcao.cpp:    this->kpoints_number = nkstot;
module_io/unk_overlap_lcao.cpp:    this->prepare_midmatrix_pblas(ik_L, ik_R, dk, midmatrix, *lowf.ParaV, kv);
module_io/unk_overlap_lcao.cpp:	this->init(gt, wfc_k_grid, kv.nkstot);
module_io/unk_overlap_lcao.cpp:	this->cal_R_number();
module_io/unk_overlap_lcao.cpp:	this->cal_orb_overlap();
module_io/unk_overlap_lcao.cpp:    for (int ik = 0; ik < this->kpoints_number; ik++)
module_io/unk_overlap_lcao.cpp:    GlobalV::ofs_running << "(" << 0 << "," << 0 << ") = " << std::abs(this->unkdotp_LCAO(0,0,0,0,dk)) << std::endl;
module_io/unk_overlap_lcao.cpp:            GlobalV::ofs_running << "(" << ib2 << "," << ib << ") = " << std::abs(this->unkdotp_LCAO(0,0,ib2,ib,dk)) <<
module_md/test/setcell.h:    this->tot_magnetization = 0.0;
module_md/test/setcell.h:    this->abs_magnetization = 0.0;
module_md/test/setcell.h:    this->start_magnetization = nullptr;
module_md/test/setcell.h:    delete[] this->start_magnetization;
module_psi/psi.cpp:    this->npol = GlobalV::NPOL;
module_psi/psi.cpp:    this->device = device::get_device_type<Device>(this->ctx);
module_psi/psi.cpp:    if (this->allocate_inside) delete_memory_op()(this->ctx, this->psi);
module_psi/psi.cpp:    this->ngk = ngk_in;
module_psi/psi.cpp:    this->npol = GlobalV::NPOL;
module_psi/psi.cpp:    this->device = device::get_device_type<Device>(this->ctx);
module_psi/psi.cpp:    this->k_first = k_first_in;
module_psi/psi.cpp:    this->ngk = ngk_in;
module_psi/psi.cpp:    this->current_b = 0;
module_psi/psi.cpp:    this->current_k = 0;
module_psi/psi.cpp:    this->npol = GlobalV::NPOL;
module_psi/psi.cpp:    this->device = device::get_device_type<Device>(this->ctx);
module_psi/psi.cpp:    this->resize(nk_in, nbd_in, nbs_in);
module_psi/psi.cpp:    device::print_device_info<Device>(this->ctx, GlobalV::ofs_device);
module_psi/psi.cpp:    device::record_device_memory<Device>(this->ctx,
module_psi/psi.cpp:    this->k_first = k_first_in;
module_psi/psi.cpp:    this->ngk = ngk_in;
module_psi/psi.cpp:    this->current_b = 0;
module_psi/psi.cpp:    this->current_k = 0;
module_psi/psi.cpp:    this->npol = GlobalV::NPOL;
module_psi/psi.cpp:    this->device = device::get_device_type<Device>(this->ctx);
module_psi/psi.cpp:    this->nk = nk_in;
module_psi/psi.cpp:    this->nbands = nbd_in;
module_psi/psi.cpp:    this->nbasis = nbs_in;
module_psi/psi.cpp:    this->current_nbasis = nbs_in;
module_psi/psi.cpp:    this->psi_current = this->psi = psi_pointer;
module_psi/psi.cpp:    this->allocate_inside = false;
module_psi/psi.cpp:    device::print_device_info<Device>(this->ctx, GlobalV::ofs_device);
module_psi/psi.cpp:    this->k_first = psi_in.get_k_first();
module_psi/psi.cpp:    this->device = psi_in.device;
module_psi/psi.cpp:    this->resize(nk_in, nband_in, psi_in.get_nbasis());
module_psi/psi.cpp:    this->ngk = psi_in.ngk;
module_psi/psi.cpp:    this->npol = psi_in.npol;
module_psi/psi.cpp:            this->current_k = psi_in.get_current_k();
module_psi/psi.cpp:        synchronize_memory_op()(this->ctx, psi_in.get_device(), this->psi, psi_in.get_pointer(), this->size());
module_psi/psi.cpp:    this->k_first = psi_in.get_k_first();
module_psi/psi.cpp:    this->device = device::get_device_type<Device>(this->ctx);
module_psi/psi.cpp:    assert(this->device == psi_in.device);
module_psi/psi.cpp:    this->ngk = psi_in.ngk;
module_psi/psi.cpp:    this->npol = psi_in.npol;
module_psi/psi.cpp:    this->nk = nk_in;
module_psi/psi.cpp:    this->nbands = nband_in;
module_psi/psi.cpp:    this->nbasis = psi_in.nbasis;
module_psi/psi.cpp:    this->psi_current = psi_pointer;
module_psi/psi.cpp:    this->allocate_inside = false;
module_psi/psi.cpp:    this->psi = psi_pointer;
module_psi/psi.cpp:    this->ngk = psi_in.get_ngk_pointer();
module_psi/psi.cpp:    this->npol = psi_in.npol;
module_psi/psi.cpp:    this->nk = psi_in.get_nk();
module_psi/psi.cpp:    this->nbands = psi_in.get_nbands();
module_psi/psi.cpp:    this->nbasis = psi_in.get_nbasis();
module_psi/psi.cpp:    this->current_k = psi_in.get_current_k();
module_psi/psi.cpp:    this->current_b = psi_in.get_current_b();
module_psi/psi.cpp:    this->k_first = psi_in.get_k_first();
module_psi/psi.cpp:    // this function will copy psi_in.psi to this->psi no matter the device types of each other.
module_psi/psi.cpp:    this->device = device::get_device_type<Device>(this->ctx);
module_psi/psi.cpp:    this->resize(psi_in.get_nk(), psi_in.get_nbands(), psi_in.get_nbasis());
module_psi/psi.cpp:    memory::synchronize_memory_op<T, Device, Device>()(this->ctx,
module_psi/psi.cpp:                                                       this->psi,
module_psi/psi.cpp:    this->psi_bias = psi_in.get_psi_bias();
module_psi/psi.cpp:    this->current_nbasis = psi_in.get_current_nbas();
module_psi/psi.cpp:    this->psi_current = this->psi + psi_in.get_psi_bias();
module_psi/psi.cpp:    this->ngk = psi_in.get_ngk_pointer();
module_psi/psi.cpp:    this->npol = psi_in.npol;
module_psi/psi.cpp:    this->nk = psi_in.get_nk();
module_psi/psi.cpp:    this->nbands = psi_in.get_nbands();
module_psi/psi.cpp:    this->nbasis = psi_in.get_nbasis();
module_psi/psi.cpp:    this->current_k = psi_in.get_current_k();
module_psi/psi.cpp:    this->current_b = psi_in.get_current_b();
module_psi/psi.cpp:    this->k_first = psi_in.get_k_first();
module_psi/psi.cpp:    // this function will copy psi_in.psi to this->psi no matter the device types of each other.
module_psi/psi.cpp:    this->device = device::get_device_type<Device>(this->ctx);
module_psi/psi.cpp:    this->resize(psi_in.get_nk(), psi_in.get_nbands(), psi_in.get_nbasis());
module_psi/psi.cpp:    memory::cast_memory_op<T, T_in, Device, Device_in>()(this->ctx,
module_psi/psi.cpp:                                                         this->psi,
module_psi/psi.cpp:    this->psi_bias = psi_in.get_psi_bias();
module_psi/psi.cpp:    this->current_nbasis = psi_in.get_current_nbas();
module_psi/psi.cpp:    this->psi_current = this->psi + psi_in.get_psi_bias();
module_psi/psi.cpp:    resize_memory_op()(this->ctx, this->psi, nks_in * static_cast<std::size_t>(nbands_in) * nbasis_in, "no_record");
module_psi/psi.cpp:    this->nk = nks_in;
module_psi/psi.cpp:    this->nbands = nbands_in;
module_psi/psi.cpp:    this->nbasis = nbasis_in;
module_psi/psi.cpp:    this->current_nbasis = nbasis_in;
module_psi/psi.cpp:    this->psi_current = this->psi;
module_psi/psi.cpp:    return this->psi_current;
module_psi/psi.cpp:    assert(this->k_first ? ikb < this->nbands : ikb < this->nk);
module_psi/psi.cpp:    return &this->psi_current[ikb * this->nbasis];
module_psi/psi.cpp:    return this->ngk;
module_psi/psi.cpp:    return this->k_first;
module_psi/psi.cpp:    return this->ctx;
module_psi/psi.cpp:    return this->psi_bias;
module_psi/psi.cpp:    return this->nk;
module_psi/psi.cpp:    return this->nbands;
module_psi/psi.cpp:    return this->nbasis;
module_psi/psi.cpp:    if (this->psi == nullptr)
module_psi/psi.cpp:    return this->nk * static_cast<std::size_t>(this->nbands) * this->nbasis;
module_psi/psi.cpp:    this->current_k = ik;
module_psi/psi.cpp:    if (this->ngk != nullptr && this->npol != 2)
module_psi/psi.cpp:        this->current_nbasis = this->ngk[ik];
module_psi/psi.cpp:        this->current_nbasis = this->nbasis;
module_psi/psi.cpp:    if (this->k_first)this->current_b = 0;
module_psi/psi.cpp:    int base = this->current_b * this->nk * this->nbasis;
module_psi/psi.cpp:    if (ik >= this->nk)
module_psi/psi.cpp:        this->psi_bias = base;
module_psi/psi.cpp:        this->psi_current = const_cast<T*>(&(this->psi[base]));
module_psi/psi.cpp:        this->psi_bias = k_first ? ik * this->nbands * this->nbasis : base + ik * this->nbasis;
module_psi/psi.cpp:        this->psi_current = const_cast<T*>(&(this->psi[psi_bias]));
module_psi/psi.cpp:    this->current_b = ib;
module_psi/psi.cpp:    if (!this->k_first)this->current_k = 0;
module_psi/psi.cpp:    int base = this->current_k * this->nbands * this->nbasis;
module_psi/psi.cpp:    if (ib >= this->nbands)
module_psi/psi.cpp:        this->psi_bias = base;
module_psi/psi.cpp:        this->psi_current = const_cast<T*>(&(this->psi[base]));
module_psi/psi.cpp:        this->psi_bias = k_first ? base + ib * this->nbasis : ib * this->nk * this->nbasis;
module_psi/psi.cpp:        this->psi_current = const_cast<T*>(&(this->psi[psi_bias]));
module_psi/psi.cpp:    this->current_k = ik;
module_psi/psi.cpp:    this->current_b = ib;
module_psi/psi.cpp:    if (ik >= this->nk || ib >= this->nbands)
module_psi/psi.cpp:        this->psi_bias = 0;
module_psi/psi.cpp:        this->psi_current = const_cast<T*>(&(this->psi[0]));
module_psi/psi.cpp:        this->psi_bias = k_first ? (ik * this->nbands + ib) * this->nbasis : (ib * this->nk + ik) * this->nbasis;
module_psi/psi.cpp:        this->psi_current = const_cast<T*>(&(this->psi[psi_bias]));
module_psi/psi.cpp:    assert(this->k_first ? ikb1 < this->nk && ikb2 < this->nbands : ikb1 < this->nbands && ikb2 < this->nk);
module_psi/psi.cpp:    return this->k_first ? this->psi[(ikb1 * this->nbands + ikb2) * this->nbasis + ibasis] : this->psi[(ikb1 * this->nk + ikb2) * this->nbasis + ibasis];
module_psi/psi.cpp:    assert(this->k_first ? this->current_b == 0 : this->current_k == 0);
module_psi/psi.cpp:    assert(this->k_first ? ikb2 >= 0 && ikb2 < this->nbands : ikb2 >= 0 && ikb2 < this->nk);
module_psi/psi.cpp:    assert(ibasis >= 0 && ibasis < this->nbasis);
module_psi/psi.cpp:    return this->psi_current[ikb2 * this->nbasis + ibasis];
module_psi/psi.cpp:    assert(ibasis >= 0 && ibasis < this->nbasis);
module_psi/psi.cpp:    return this->psi_current[ibasis];
module_psi/psi.cpp:    return this->current_k;
module_psi/psi.cpp:    return this->current_b;
module_psi/psi.cpp:    return this->current_nbasis;
module_psi/psi.cpp:    if (!this->ngk) return this->nbasis;
module_psi/psi.cpp:    return this->ngk[ik_in];
module_psi/psi.cpp:    // this->psi.assign(this->psi.size(), T(0));
module_psi/psi.cpp:    set_memory_op()(this->ctx, this->psi, 0, this->size());
module_psi/psi.cpp:    if (range.k_first != this->k_first || r1 < 0 || r2 < r1
module_psi/psi.cpp:        // || (range.k_first && (r2 >= this->nbands || i1 >= this->nk))
module_psi/psi.cpp:        // || (!range.k_first && (r2 >= this->nk || i1 >= this->nbands)))
module_psi/psi.cpp:        || (range.k_first ? (i1 >= this->nk) : (i1 >= this->nbands))    // illegal index 1
module_psi/psi.cpp:        || (range.k_first ? (i1 > 0 && r2 >= this->nbands) : (i1 > 0 && r2 >= this->nk)) // illegal range of index 2
module_psi/psi.cpp:        || (range.k_first ? (i1 < 0 && r2 >= this->nk) : (i1 < 0 && r2 >= this->nbands))) // illegal range of index 1
module_psi/psi.cpp:        const T* p = &this->psi[r1 * (k_first ? this->nbands : this->nk) * this->nbasis];
module_psi/psi.cpp:        int m = (r2 - r1 + 1) * this->npol;
module_psi/psi.cpp:        const T* p = &this->psi[(i1 * (k_first ? this->nbands : this->nk) + r1) * this->nbasis];
module_psi/psi.cpp:        int m = (r2 - r1 + 1) * this->npol;
module_psi/psi.h:    // size_t size() const {return this->psi.size();}
module_psi/psi_initializer.cpp:        The way of calculating this->p_ucell_->natomwfc is, for each atom, read pswfc and for s, it is 1, for p, it is 3
module_psi/psi_initializer.cpp:    if(this->method_ == "random") 
module_psi/psi_initializer.cpp:        this->nbands_complem_ = 0;
module_psi/psi_initializer.cpp:        if(this->method_.substr(0, 6) == "atomic")
module_psi/psi_initializer.cpp:            if(this->p_ucell_->natomwfc >= GlobalV::NBANDS)
module_psi/psi_initializer.cpp:                nbands_actual = this->p_ucell_->natomwfc;
module_psi/psi_initializer.cpp:                this->nbands_complem_ = 0;
module_psi/psi_initializer.cpp:                this->nbands_complem_ = GlobalV::NBANDS - this->p_ucell_->natomwfc;
module_psi/psi_initializer.cpp:        else if(this->method_.substr(0, 3) == "nao")
module_psi/psi_initializer.cpp:            for(int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer.cpp:                for(int ia = 0; ia < this->p_ucell_->atoms[it].na; ia++)
module_psi/psi_initializer.cpp:                    for(int l = 0; l < this->p_ucell_->atoms[it].nwl + 1; l++)
module_psi/psi_initializer.cpp:                        //nbands_local += this->p_ucell_->atoms[it].l_nchi[l]*(2*l+1) * GlobalV::NPOL;
module_psi/psi_initializer.cpp:							nbands_local += this->p_ucell_->atoms[it].l_nchi[l] * GlobalV::NPOL;
module_psi/psi_initializer.cpp:							nbands_local += this->p_ucell_->atoms[it].l_nchi[l]*(2*l+1) * GlobalV::NPOL;
module_psi/psi_initializer.cpp:                this->nbands_complem_ = 0;
module_psi/psi_initializer.cpp:                this->nbands_complem_ = GlobalV::NBANDS - nbands_local;
module_psi/psi_initializer.cpp:	int nkpts_actual = (GlobalV::CALCULATION == "nscf" && this->mem_saver_ == 1)? 1 : this->pw_wfc_->nks;
module_psi/psi_initializer.cpp:    int nbasis_actual = this->pw_wfc_->npwk_max * GlobalV::NPOL;
module_psi/psi_initializer.cpp:                                                     this->pw_wfc_->npwk);
module_psi/psi_initializer.cpp:                    GlobalV::NBANDS * this->pw_wfc_->npwk_max * GlobalV::NPOL*
module_psi/psi_initializer.cpp:    this->psig_ = std::make_shared<psi::Psi<T, Device>>(nkpts_actual, 
module_psi/psi_initializer.cpp:                                                        this->pw_wfc_->npwk);
module_psi/psi_initializer.cpp:                nbands_actual * this->pw_wfc_->npwk_max * GlobalV::NPOL*
module_psi/psi_initializer.cpp:                         << "nbands_complem = " << this->nbands_complem_ << "\n"
module_psi/psi_initializer.cpp:                         << "npwk_max = " << this->pw_wfc_->npwk_max << "\n"
module_psi/psi_initializer.cpp:    const int ng = this->pw_wfc_->npwk[ik];
module_psi/psi_initializer.cpp:    if (this->random_seed_ > 0) // qianrui add 2021-8-13
module_psi/psi_initializer.cpp:        srand(unsigned(this->random_seed_ + this->p_parakpts_->startk_pool[GlobalV::MY_POOL] + ik));
module_psi/psi_initializer.cpp:        const int nxy = this->pw_wfc_->fftnxy;
module_psi/psi_initializer.cpp:        const int nz = this->pw_wfc_->nz;
module_psi/psi_initializer.cpp:        const int nstnz = this->pw_wfc_->nst*nz;
module_psi/psi_initializer.cpp:            T* psi_slice = &(psi[iw * this->pw_wfc_->npwk_max * GlobalV::NPOL]);
module_psi/psi_initializer.cpp:                    if(this->pw_wfc_->fftixy2ip[ir] < 0) continue;
module_psi/psi_initializer.cpp:                    const double rr = tmprr[this->pw_wfc_->getigl2isz(ik,ig)];
module_psi/psi_initializer.cpp:                    const double arg= ModuleBase::TWO_PI * tmparg[this->pw_wfc_->getigl2isz(ik,ig)];
module_psi/psi_initializer.cpp:                    const double gk2 = this->pw_wfc_->getgk2(ik,ig);
module_psi/psi_initializer.cpp:                    psi_slice[ig+startig] = this->template cast_to_T<T>(std::complex<double>(rr*cos(arg)/(gk2 + 1.0), rr*sin(arg)/(gk2 + 1.0)));
module_psi/psi_initializer.cpp:                startig += this->pw_wfc_->npwk_max;
module_psi/psi_initializer.cpp:        if (this->random_seed_ > 0) // qianrui add 2021-8-13
module_psi/psi_initializer.cpp:            srand(unsigned(this->random_seed_ + ik));
module_psi/psi_initializer.cpp:            T* psi_slice = &(psi[iw * this->pw_wfc_->npwk_max * GlobalV::NPOL]);
module_psi/psi_initializer.cpp:                const double gk2 = this->pw_wfc_->getgk2(ik,ig);
module_psi/psi_initializer.cpp:                psi_slice[ig] = this->template cast_to_T<T>(std::complex<double>(rr*cos(arg)/(gk2 + 1.0), rr*sin(arg)/(gk2 + 1.0)));
module_psi/psi_initializer.cpp:                for (int ig = this->pw_wfc_->npwk_max; ig < this->pw_wfc_->npwk_max + ng; ig++)
module_psi/psi_initializer.cpp:                    const double gk2 = this->pw_wfc_->getgk2(ik,ig-this->pw_wfc_->npwk_max);
module_psi/psi_initializer.cpp:                    psi_slice[ig] = this->template cast_to_T<T>(std::complex<double>(rr*cos(arg)/(gk2 + 1.0), rr*sin(arg)/(gk2 + 1.0)));
module_psi/psi_initializer.cpp:    const int is = this->ixy2is_[ir];
module_psi/psi_initializer.cpp:	const int ip = this->pw_wfc_->fftixy2ip[ir];
module_psi/psi_initializer.cpp:    const int nz = this->pw_wfc_->nz;
module_psi/psi_initializer.h:        Parallel_Kpoints* p_parakpts() const { return this->p_parakpts_; }
module_psi/psi_initializer.h:        void set_parakpts(Parallel_Kpoints* p_parakpts) { this->p_parakpts_ = p_parakpts; }
module_psi/psi_initializer.h:        UnitCell* p_ucell() const { return this->p_ucell_; }
module_psi/psi_initializer.h:        pseudopot_cell_vnl* p_pspot_nl() const { return this->p_pspot_nl_; }
module_psi/psi_initializer.h:        Structure_Factor* p_sf() const { return this->sf_; }
module_psi/psi_initializer.h:        ModulePW::PW_Basis_K* pw_wfc() const { return this->pw_wfc_; }
module_psi/psi_initializer.h:        int random_seed() const { return this->random_seed_; }
module_psi/psi_initializer.h:        std::vector<int> ixy2is() const { return this->ixy2is_; }
module_psi/psi_initializer.h:        int mem_saver() const { return this->mem_saver_; }
module_psi/psi_initializer.h:        double random_mix() const { return this->random_mix_; }
module_psi/psi_initializer.h:        bool initialized() const { return this->initialized_; }
module_psi/psi_initializer.h:        std::string method() const { return this->method_; }
module_psi/psi_initializer.h:        int nbands_complem() const { return this->nbands_complem_; }
module_psi/psi_initializer.h:        std::weak_ptr<psi::Psi<T, Device>> share_psig() { return this->psig_; }
module_psi/psi_initializer.h:        void set_ucell(UnitCell* p_ucell_in) { this->p_ucell_ = p_ucell_in; }
module_psi/psi_initializer.h:        void set_pspot_nl(pseudopot_cell_vnl* p_pspot_nl_in) { this->p_pspot_nl_ = p_pspot_nl_in; }
module_psi/psi_initializer.h:        void set_sf(Structure_Factor* sf_in) { this->sf_ = sf_in; }
module_psi/psi_initializer.h:        void set_pw_wfc(ModulePW::PW_Basis_K* pw_wfc_in) { this->pw_wfc_ = pw_wfc_in; }
module_psi/psi_initializer.h:        void set_random_mix(const double random_mix_in) { this->random_mix_ = random_mix_in; }
module_psi/psi_initializer.h:        void set_ixy2is(const std::vector<int>& ixy2is_in) { this->ixy2is_ = ixy2is_in; }
module_psi/psi_initializer.h:        void set_random_seed(const int random_seed_in) { this->random_seed_ = random_seed_in; }
module_psi/psi_initializer.h:        void set_mem_saver(const int mem_saver_in) { this->mem_saver_ = mem_saver_in; }
module_psi/psi_initializer.h:        void set_initialized(bool initialized_in) { this->initialized_ = initialized_in; }
module_psi/psi_initializer.h:        void set_method(std::string method_in) { this->method_ = method_in; }
module_psi/psi_initializer.h:        void set_nbands_complem(int nbands_in) { this->nbands_complem_ = nbands_in; }
module_psi/psi_initializer_atomic.cpp:    int dim1 = this->p_ucell_->ntype;
module_psi/psi_initializer_atomic.cpp:    for (int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_atomic.cpp:        dim2 = (this->p_ucell_->atoms[it].ncpp.nchi > dim2) ? this->p_ucell_->atoms[it].ncpp.nchi : dim2;
module_psi/psi_initializer_atomic.cpp:    this->ovlp_pswfcjlq_.create(dim1, dim2, dim3);
module_psi/psi_initializer_atomic.cpp:    this->ovlp_pswfcjlq_.zero_out();
module_psi/psi_initializer_atomic.cpp:    this->sf_ = sf;
module_psi/psi_initializer_atomic.cpp:    this->pw_wfc_ = pw_wfc;
module_psi/psi_initializer_atomic.cpp:    this->p_ucell_ = p_ucell;
module_psi/psi_initializer_atomic.cpp:    this->p_parakpts_ = p_parakpts;
module_psi/psi_initializer_atomic.cpp:    this->p_pspot_nl_ = p_pspot_nl;
module_psi/psi_initializer_atomic.cpp:    this->random_seed_ = random_seed;
module_psi/psi_initializer_atomic.cpp:    this->allocate_table();
module_psi/psi_initializer_atomic.cpp:    this->sf_ = sf;
module_psi/psi_initializer_atomic.cpp:    this->pw_wfc_ = pw_wfc;
module_psi/psi_initializer_atomic.cpp:    this->p_ucell_ = p_ucell;
module_psi/psi_initializer_atomic.cpp:    this->p_pspot_nl_ = p_pspot_nl;
module_psi/psi_initializer_atomic.cpp:    this->random_seed_ = random_seed;
module_psi/psi_initializer_atomic.cpp:    this->allocate_table();
module_psi/psi_initializer_atomic.cpp:    for (int it=0; it<this->p_ucell_->ntype; it++)
module_psi/psi_initializer_atomic.cpp:        maxn_rgrid = (this->p_ucell_->atoms[it].ncpp.msh > maxn_rgrid) ? this->p_ucell_->atoms[it].ncpp.msh : maxn_rgrid;
module_psi/psi_initializer_atomic.cpp:    const double pref = ModuleBase::FOUR_PI / sqrt(this->p_ucell_->omega);
module_psi/psi_initializer_atomic.cpp:    for (int it=0; it<this->p_ucell_->ntype; it++)
module_psi/psi_initializer_atomic.cpp:		Atom* atom = &this->p_ucell_->atoms[it];
module_psi/psi_initializer_atomic.cpp:                this->sbt.direct(l, atom->ncpp.msh, atom->ncpp.r, pswfcr.data(), GlobalV::NQX, qgrid.data(), ovlp_pswfcjlq_q.data(), 1);
module_psi/psi_initializer_atomic.cpp:                    this->ovlp_pswfcjlq_(it, ic, iq) = pref * ovlp_pswfcjlq_q[iq];
module_psi/psi_initializer_atomic.cpp:    this->psig_->fix_k(ik);
module_psi/psi_initializer_atomic.cpp:    //this->print_status(psi);
module_psi/psi_initializer_atomic.cpp:    const int npw = this->pw_wfc_->npwk[ik];
module_psi/psi_initializer_atomic.cpp:    int lmax = this->p_ucell_->lmax_ppwf;
module_psi/psi_initializer_atomic.cpp:        gk[ig] = this->pw_wfc_->getgpluskcar(ik, ig);
module_psi/psi_initializer_atomic.cpp:    for (int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_atomic.cpp:        for (int ia = 0; ia < this->p_ucell_->atoms[it].na; ia++)
module_psi/psi_initializer_atomic.cpp:            std::complex<double> *sk = this->sf_->get_sk(ik, it, ia, this->pw_wfc_);
module_psi/psi_initializer_atomic.cpp:            for (int ipswfc = 0; ipswfc < this->p_ucell_->atoms[it].ncpp.nchi; ipswfc++)
module_psi/psi_initializer_atomic.cpp:                if (this->p_ucell_->atoms[it].ncpp.oc[ipswfc] >= 0.0)
module_psi/psi_initializer_atomic.cpp:                    const int l = this->p_ucell_->atoms[it].ncpp.lchi[ipswfc];
module_psi/psi_initializer_atomic.cpp:                            this->ovlp_pswfcjlq_, it, ipswfc, 
module_psi/psi_initializer_atomic.cpp:                            GlobalV::NQX, GlobalV::DQ, gk[ig].norm() * this->p_ucell_->tpiba );
module_psi/psi_initializer_atomic.cpp:                        if(this->p_ucell_->atoms[it].ncpp.has_so)
module_psi/psi_initializer_atomic.cpp:                            const double j = this->p_ucell_->atoms[it].ncpp.jchi[ipswfc];
module_psi/psi_initializer_atomic.cpp:                                                const int ind = this->p_pspot_nl_->lmaxkb + soc.sph_ind(l,j,m,is); // ind can be l+m, l+m+1, l+m-1
module_psi/psi_initializer_atomic.cpp:                                                    (*(this->psig_))(index, 
module_psi/psi_initializer_atomic.cpp:                                                                    ig + this->pw_wfc_->npwk_max*is ) =
module_psi/psi_initializer_atomic.cpp:                                                                        this->template cast_to_T<T>(
module_psi/psi_initializer_atomic.cpp:                                                    (*(this->psig_))(index, 
module_psi/psi_initializer_atomic.cpp:                                                                    ig + this->pw_wfc_->npwk_max*is ) = 
module_psi/psi_initializer_atomic.cpp:                                                                        this->template cast_to_T<T>(
module_psi/psi_initializer_atomic.cpp:                                    for(int jpsiwfc = 0; jpsiwfc < this->p_ucell_->atoms[it].ncpp.nchi; jpsiwfc++)
module_psi/psi_initializer_atomic.cpp:                                            (this->p_ucell_->atoms[it].ncpp.lchi[jpsiwfc] == l)
module_psi/psi_initializer_atomic.cpp:                                          &&(fabs(this->p_ucell_->atoms[it].ncpp.jchi[jpsiwfc] - l + 0.5) < 1e-4))
module_psi/psi_initializer_atomic.cpp:                                                this->ovlp_pswfcjlq_, it, ipswfc_noncolin_soc, 
module_psi/psi_initializer_atomic.cpp:                                                GlobalV::NQX, GlobalV::DQ, gk[ig].norm() * this->p_ucell_->tpiba);
module_psi/psi_initializer_atomic.cpp:                                alpha = this->p_ucell_->atoms[it].angle1[ia];
module_psi/psi_initializer_atomic.cpp:                                gamma = -1 * this->p_ucell_->atoms[it].angle2[ia] + 0.5 * ModuleBase::PI;
module_psi/psi_initializer_atomic.cpp:                                    if(index+2*l+1 > this->p_ucell_->natomwfc)
module_psi/psi_initializer_atomic.cpp:                                        std::cout<<__FILE__<<__LINE__<<" "<<index<<" "<<this->p_ucell_->natomwfc<<std::endl;
module_psi/psi_initializer_atomic.cpp:                                        (*(this->psig_))(index, ig) = 
module_psi/psi_initializer_atomic.cpp:                                            this->template cast_to_T<T>(phase_factor(0.5*gamma, 0)*fup);
module_psi/psi_initializer_atomic.cpp:                                        (*(this->psig_))(index, ig+this->pw_wfc_->npwk_max) = 
module_psi/psi_initializer_atomic.cpp:                                            this->template cast_to_T<T>(phase_factor(-0.5*gamma, 0)*fdw);
module_psi/psi_initializer_atomic.cpp:                                        (*(this->psig_))(index+2*l+1, ig) = 
module_psi/psi_initializer_atomic.cpp:                                            this->template cast_to_T<T>(phase_factor(0.5*gamma, 0)*fup);
module_psi/psi_initializer_atomic.cpp:                                        (*(this->psig_))(index+2*l+1, ig+this->pw_wfc_->npwk_max) = 
module_psi/psi_initializer_atomic.cpp:                                            this->template cast_to_T<T>(phase_factor(-0.5*gamma, 0)*fdw);
module_psi/psi_initializer_atomic.cpp:                            //alpha = this->p_ucell_->magnet.angle1_[it];
module_psi/psi_initializer_atomic.cpp:                            //gamman = -this->p_ucell_->magnet.angle2_[it] + 0.5*ModuleBase::PI;
module_psi/psi_initializer_atomic.cpp:                            alpha = this->p_ucell_->atoms[it].angle1[ia];
module_psi/psi_initializer_atomic.cpp:                            gamman = -1 * this->p_ucell_->atoms[it].angle2[ia] + 0.5 * ModuleBase::PI;
module_psi/psi_initializer_atomic.cpp:                                if(index+2*l+1 > this->p_ucell_->natomwfc)
module_psi/psi_initializer_atomic.cpp:                                    std::cout<<__FILE__<<__LINE__<<" "<<index<<" "<<this->p_ucell_->natomwfc<<std::endl;
module_psi/psi_initializer_atomic.cpp:                                     (*(this->psig_))(index, ig) = 
module_psi/psi_initializer_atomic.cpp:                                        this->template cast_to_T<T>(
module_psi/psi_initializer_atomic.cpp:                                     (*(this->psig_))(index, ig+ this->pw_wfc_->npwk_max) = 
module_psi/psi_initializer_atomic.cpp:                                        this->template cast_to_T<T>(
module_psi/psi_initializer_atomic.cpp:                                     (*(this->psig_))(index+2*l+1, ig) = 
module_psi/psi_initializer_atomic.cpp:                                        this->template cast_to_T<T>(
module_psi/psi_initializer_atomic.cpp:                                     (*(this->psig_))(index+2*l+1, ig+ this->pw_wfc_->npwk_max) = 
module_psi/psi_initializer_atomic.cpp:                                        this->template cast_to_T<T>(
module_psi/psi_initializer_atomic.cpp:                                (*(this->psig_))(index, ig) = 
module_psi/psi_initializer_atomic.cpp:                                    this->template cast_to_T<T>(
module_psi/psi_initializer_atomic.cpp:	if(this->nbands_complem() > 0)
module_psi/psi_initializer_atomic.cpp:		this->random_t(this->psig_->get_pointer(), index, this->psig_->get_nbands(), ik);
module_psi/psi_initializer_atomic.h:        psi_initializer_atomic() {this->set_method("atomic");}
module_psi/psi_initializer_atomic_random.cpp:    this->ixy2is_.clear();
module_psi/psi_initializer_atomic_random.cpp:    this->ixy2is_.resize(this->pw_wfc_->fftnxy);
module_psi/psi_initializer_atomic_random.cpp:    this->pw_wfc_->getfftixy2is(this->ixy2is_.data());
module_psi/psi_initializer_atomic_random.cpp:    this->ixy2is_.clear();
module_psi/psi_initializer_atomic_random.cpp:    this->ixy2is_.resize(this->pw_wfc_->fftnxy);
module_psi/psi_initializer_atomic_random.cpp:    this->pw_wfc_->getfftixy2is(this->ixy2is_.data());
module_psi/psi_initializer_atomic_random.cpp:    double rm = this->random_mix();
module_psi/psi_initializer_atomic_random.cpp:    this->psig_->fix_k(ik);
module_psi/psi_initializer_atomic_random.cpp:    psi::Psi<T, Device> psi_random(1, this->psig_->get_nbands(), this->psig_->get_nbasis(), nullptr);
module_psi/psi_initializer_atomic_random.cpp:    this->random_t(psi_random.get_pointer(), 0, psi_random.get_nbands(), ik);
module_psi/psi_initializer_atomic_random.cpp:    for(int iband = 0; iband < this->psig_->get_nbands(); iband++)
module_psi/psi_initializer_atomic_random.cpp:        for(int ibasis = 0; ibasis < this->psig_->get_nbasis(); ibasis++)
module_psi/psi_initializer_atomic_random.cpp:            (*(this->psig_))(iband, ibasis) = ((Real)(1-rm))*(*(this->psig_))(iband, ibasis) + ((Real)rm)*psi_random(iband, ibasis);
module_psi/psi_initializer_atomic_random.h:        psi_initializer_atomic_random() {this->set_method("atomic+random"); this->set_random_mix(0.05);}
module_psi/psi_initializer_nao.cpp:        for (int itype = 0; itype < this->p_ucell_->ntype; itype++)
module_psi/psi_initializer_nao.cpp:            this->orbital_files_.push_back(orbital_files[itype]);
module_psi/psi_initializer_nao.cpp:        for(int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_nao.cpp:            for(int l = 0; l <= this->p_ucell_->atoms[it].nwl; l++)
module_psi/psi_initializer_nao.cpp:                nchi += this->p_ucell_->atoms[it].l_nchi[l];
module_psi/psi_initializer_nao.cpp:            ifs_it.open(GlobalV::global_orbital_dir+this->orbital_files_[it]);
module_psi/psi_initializer_nao.cpp:                GlobalV::ofs_warning<<"psi_initializer_nao<T, Device>::read_orbital_files: cannot open orbital file: "<<this->orbital_files_[it]<<std::endl;
module_psi/psi_initializer_nao.cpp:                GlobalV::ofs_running<<"psi_initializer_nao<T, Device>::read_orbital_files: reading orbital file: "<<this->orbital_files_[it]<<std::endl;
module_psi/psi_initializer_nao.cpp:            for(int l = 0; l <= this->p_ucell_->atoms[it].nwl; l++)
module_psi/psi_initializer_nao.cpp:                for(int ichi = 0; ichi < this->p_ucell_->atoms[it].l_nchi[l]; ichi++)
module_psi/psi_initializer_nao.cpp:                    GlobalV::ofs_running<<" reading orbital of element "<<this->p_ucell_->atoms[it].label<<std::endl
module_psi/psi_initializer_nao.cpp:                    ifs_it.open(GlobalV::global_orbital_dir+this->orbital_files_[it]);
module_psi/psi_initializer_nao.cpp:                            GlobalV::ofs_warning<<" psi_initializer_nao<T, Device>::read_orbital_files: cannot find orbital of element "<<this->p_ucell_->atoms[it].label<<std::endl
module_psi/psi_initializer_nao.cpp:            this->n_rgrid_.push_back(n_rgrid_it);
module_psi/psi_initializer_nao.cpp:            this->rgrid_.push_back(rgrid_it);
module_psi/psi_initializer_nao.cpp:            this->rvalue_.push_back(rvalue_it);
module_psi/psi_initializer_nao.cpp:		this->orbital_files_.resize(this->p_ucell_->ntype);
module_psi/psi_initializer_nao.cpp:    Parallel_Common::bcast_string(this->orbital_files_.data(), this->p_ucell_->ntype);
module_psi/psi_initializer_nao.cpp:		this->n_rgrid_.resize(this->p_ucell_->ntype);
module_psi/psi_initializer_nao.cpp:    int nchi[this->p_ucell_->ntype];
module_psi/psi_initializer_nao.cpp:		for(int it = 0; it < this->p_ucell_->ntype; it++) 
module_psi/psi_initializer_nao.cpp:			nchi[it] = this->n_rgrid_[it].size();
module_psi/psi_initializer_nao.cpp:    Parallel_Common::bcast_int(nchi, this->p_ucell_->ntype);
module_psi/psi_initializer_nao.cpp:        this->n_rgrid_.resize(this->p_ucell_->ntype);
module_psi/psi_initializer_nao.cpp:        this->rgrid_.resize(this->p_ucell_->ntype);
module_psi/psi_initializer_nao.cpp:        this->rvalue_.resize(this->p_ucell_->ntype);
module_psi/psi_initializer_nao.cpp:        for(int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_nao.cpp:            this->n_rgrid_[it].resize(nchi[it]);
module_psi/psi_initializer_nao.cpp:            this->rgrid_[it].resize(nchi[it]);
module_psi/psi_initializer_nao.cpp:            this->rvalue_[it].resize(nchi[it]);
module_psi/psi_initializer_nao.cpp:	for(int it = 0; it < this->p_ucell_->ntype; it++) 
module_psi/psi_initializer_nao.cpp:		Parallel_Common::bcast_int(this->n_rgrid_[it].data(), nchi[it]);
module_psi/psi_initializer_nao.cpp:        for(int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_nao.cpp:                this->rgrid_[it][ichi].resize(this->n_rgrid_[it][ichi]);
module_psi/psi_initializer_nao.cpp:                this->rvalue_[it][ichi].resize(this->n_rgrid_[it][ichi]);
module_psi/psi_initializer_nao.cpp:    for(int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_nao.cpp:            Parallel_Common::bcast_double(this->rgrid_[it][ichi].data(), this->n_rgrid_[it][ichi]);
module_psi/psi_initializer_nao.cpp:            Parallel_Common::bcast_double(this->rvalue_[it][ichi].data(), this->n_rgrid_[it][ichi]);
module_psi/psi_initializer_nao.cpp:    int dim1 = this->p_ucell_->ntype;
module_psi/psi_initializer_nao.cpp:    for (int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_nao.cpp:        for (int l = 0; l < this->p_ucell_->atoms[it].nwl+1; l++)
module_psi/psi_initializer_nao.cpp:            nzeta += this->p_ucell_->atoms[it].l_nchi[l];
module_psi/psi_initializer_nao.cpp:    this->ovlp_flzjlq_.create(dim1, dim2, dim3);
module_psi/psi_initializer_nao.cpp:    this->ovlp_flzjlq_.zero_out();
module_psi/psi_initializer_nao.cpp:    this->sf_ = sf;
module_psi/psi_initializer_nao.cpp:    this->pw_wfc_ = pw_wfc;
module_psi/psi_initializer_nao.cpp:    this->p_ucell_ = p_ucell;
module_psi/psi_initializer_nao.cpp:    this->p_parakpts_ = p_parakpts;
module_psi/psi_initializer_nao.cpp:    this->p_pspot_nl_ = p_pspot_nl;
module_psi/psi_initializer_nao.cpp:    this->random_seed_ = random_seed;
module_psi/psi_initializer_nao.cpp:    this->allocate_table();
module_psi/psi_initializer_nao.cpp:    this->read_external_orbs(this->p_ucell_->orbital_fn, rank);
module_psi/psi_initializer_nao.cpp:    //this->cal_ovlp_flzjlq(); //because GlobalV::NQX will change during vcrelax, so it should be called in both init and init_after_vc
module_psi/psi_initializer_nao.cpp:    this->sf_ = sf;
module_psi/psi_initializer_nao.cpp:    this->pw_wfc_ = pw_wfc;
module_psi/psi_initializer_nao.cpp:    this->p_ucell_ = p_ucell;
module_psi/psi_initializer_nao.cpp:    this->p_pspot_nl_ = p_pspot_nl;
module_psi/psi_initializer_nao.cpp:    this->random_seed_ = random_seed;
module_psi/psi_initializer_nao.cpp:    this->allocate_table();
module_psi/psi_initializer_nao.cpp:    this->read_external_orbs(this->p_ucell_->orbital_fn, 0);
module_psi/psi_initializer_nao.cpp:    //this->cal_ovlp_flzjlq(); //because GlobalV::NQX will change during vcrelax, so it should be called in both init and init_after_vc
module_psi/psi_initializer_nao.cpp:    this->ovlp_flzjlq_.zero_out();
module_psi/psi_initializer_nao.cpp:    for(int it=0; it<this->p_ucell_->ntype; it++)
module_psi/psi_initializer_nao.cpp:        for(int l=0; l<this->p_ucell_->atoms[it].nwl+1; l++)
module_psi/psi_initializer_nao.cpp:            for(int izeta=0; izeta<this->p_ucell_->atoms[it].l_nchi[l]; izeta++)
module_psi/psi_initializer_nao.cpp:                this->sbt.direct(l, 
module_psi/psi_initializer_nao.cpp:                                 this->n_rgrid_[it][ic],
module_psi/psi_initializer_nao.cpp:                                 this->rgrid_[it][ic].data(),
module_psi/psi_initializer_nao.cpp:                                 this->rvalue_[it][ic].data(),
module_psi/psi_initializer_nao.cpp:                    this->ovlp_flzjlq_(it, ic, iq) = ovlp_flzjlq_q[iq];
module_psi/psi_initializer_nao.cpp:    this->psig_->fix_k(ik);
module_psi/psi_initializer_nao.cpp:    const int npw = this->pw_wfc_->npwk[ik];
module_psi/psi_initializer_nao.cpp:    const int total_lm = ( this->p_ucell_->lmax + 1) * ( this->p_ucell_->lmax + 1);
module_psi/psi_initializer_nao.cpp:        gk[ig] = this->pw_wfc_->getgpluskcar(ik, ig);
module_psi/psi_initializer_nao.cpp:    for (int it = 0; it < this->p_ucell_->ntype; it++)
module_psi/psi_initializer_nao.cpp:        for (int ia = 0; ia < this->p_ucell_->atoms[it].na; ia++)
module_psi/psi_initializer_nao.cpp:            std::complex<double>* sk = this->sf_->get_sk(ik, it, ia, this->pw_wfc_);
module_psi/psi_initializer_nao.cpp:            for(int L = 0; L < this->p_ucell_->atoms[it].nwl+1; L++)
module_psi/psi_initializer_nao.cpp:                for(int N=0; N < this->p_ucell_->atoms[it].l_nchi[L]; N++)
module_psi/psi_initializer_nao.cpp:							this->ovlp_flzjlq_, // the spherical bessel transform of numerical orbital function
module_psi/psi_initializer_nao.cpp:							gk[ig].norm() * this->p_ucell_->tpiba // norm of (G+k) = K
module_psi/psi_initializer_nao.cpp:                                alpha = this->p_ucell_->atoms[it].angle1[ia];
module_psi/psi_initializer_nao.cpp:                                gamma = -1 * this->p_ucell_->atoms[it].angle2[ia] + 0.5 * ModuleBase::PI;
module_psi/psi_initializer_nao.cpp:                                        (*(this->psig_))(ibasis, ig) = 
module_psi/psi_initializer_nao.cpp:                                            this->template cast_to_T<T>(
module_psi/psi_initializer_nao.cpp:                                        (*(this->psig_))(ibasis, ig + this->pw_wfc_->npwk_max) =
module_psi/psi_initializer_nao.cpp:                                            this->template cast_to_T<T>(
module_psi/psi_initializer_nao.cpp:                                        (*(this->psig_))(ibasis+2*L+1,ig) =
module_psi/psi_initializer_nao.cpp:                                            this->template cast_to_T<T>(
module_psi/psi_initializer_nao.cpp:                                       (*(this->psig_))(ibasis+2*L+1, ig + this->pw_wfc_->npwk_max) =
module_psi/psi_initializer_nao.cpp:                                            this->template cast_to_T<T>(
module_psi/psi_initializer_nao.cpp:                                (*(this->psig_))(ibasis, ig) =  this->template cast_to_T<T>(lphase * sk[ig] * ylm(lm, ig) * ovlp_flzjlg[ig]);
module_psi/psi_initializer_nao.cpp:    if(this->nbands_complem() > 0)
module_psi/psi_initializer_nao.cpp:        this->random_t(this->psig_->get_pointer(), ibasis, this->psig_->get_nbands(), ik);
module_psi/psi_initializer_nao.h:        psi_initializer_nao() {this->set_method("nao");};
module_psi/psi_initializer_nao_random.cpp:    this->ixy2is_.clear();
module_psi/psi_initializer_nao_random.cpp:    this->ixy2is_.resize(this->pw_wfc_->fftnxy);
module_psi/psi_initializer_nao_random.cpp:    this->pw_wfc_->getfftixy2is(this->ixy2is_.data());
module_psi/psi_initializer_nao_random.cpp:    this->ixy2is_.clear();
module_psi/psi_initializer_nao_random.cpp:    this->ixy2is_.resize(this->pw_wfc_->fftnxy);
module_psi/psi_initializer_nao_random.cpp:    this->pw_wfc_->getfftixy2is(this->ixy2is_.data());
module_psi/psi_initializer_nao_random.cpp:    double rm = this->random_mix();
module_psi/psi_initializer_nao_random.cpp:    this->psig_->fix_k(ik);
module_psi/psi_initializer_nao_random.cpp:    psi::Psi<T, Device> psi_random(1, this->psig_->get_nbands(), this->psig_->get_nbasis(), nullptr);
module_psi/psi_initializer_nao_random.cpp:    this->random_t(psi_random.get_pointer(), 0, psi_random.get_nbands(), ik);
module_psi/psi_initializer_nao_random.cpp:    for(int iband = 0; iband < this->psig_->get_nbands(); iband++)
module_psi/psi_initializer_nao_random.cpp:        for(int ibasis = 0; ibasis < this->psig_->get_nbasis(); ibasis++)
module_psi/psi_initializer_nao_random.cpp:            (*(this->psig_))(iband, ibasis) = ((Real)(1-rm))*(*(this->psig_))(iband, ibasis) + ((Real)rm)*psi_random(iband, ibasis);
module_psi/psi_initializer_nao_random.h:        psi_initializer_nao_random() {this->set_method("nao+random"); this->set_random_mix(0.05);};
module_psi/psi_initializer_random.cpp:    this->pw_wfc_ = pw_wfc;
module_psi/psi_initializer_random.cpp:    this->p_ucell_ = p_ucell;
module_psi/psi_initializer_random.cpp:    this->p_parakpts_ = p_parakpts;
module_psi/psi_initializer_random.cpp:    this->random_seed_ = random_seed;
module_psi/psi_initializer_random.cpp:    this->p_pspot_nl_ = p_pspot_nl;
module_psi/psi_initializer_random.cpp:    this->ixy2is_.clear();
module_psi/psi_initializer_random.cpp:    this->ixy2is_.resize(this->pw_wfc_->fftnxy);
module_psi/psi_initializer_random.cpp:    this->pw_wfc_->getfftixy2is(this->ixy2is_.data());
module_psi/psi_initializer_random.cpp:    this->pw_wfc_ = pw_wfc;
module_psi/psi_initializer_random.cpp:    this->p_ucell_ = p_ucell;
module_psi/psi_initializer_random.cpp:    this->random_seed_ = random_seed;
module_psi/psi_initializer_random.cpp:    this->p_pspot_nl_ = p_pspot_nl;
module_psi/psi_initializer_random.cpp:    this->ixy2is_.clear();
module_psi/psi_initializer_random.cpp:    this->ixy2is_.resize(this->pw_wfc_->fftnxy);
module_psi/psi_initializer_random.cpp:    this->pw_wfc_->getfftixy2is(this->ixy2is_.data());
module_psi/psi_initializer_random.cpp:    this->random_t(psi, iw_start, iw_end, ik);
module_psi/psi_initializer_random.cpp:    this->psig_->fix_k(ik);
module_psi/psi_initializer_random.cpp:    this->random(this->psig_->get_pointer(), 0, this->psig_->get_nbands(), ik);
module_psi/psi_initializer_random.h:        psi_initializer_random() {this->set_method("random");};
module_psi/test/psi_initializer_unit_test.cpp:            this->p_sf = new Structure_Factor();
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc = new ModulePW::PW_Basis_K();
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell = new UnitCell();
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pspot_vnl = new pseudopot_cell_vnl();
module_psi/test/psi_initializer_unit_test.cpp:            this->p_parakpts = new Parallel_Kpoints();
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->a1 = {10.0, 0.0, 0.0};
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->a2 = {0.0, 10.0, 0.0};
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->a3 = {0.0, 0.0, 10.0};
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->lat0 = 1.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->latvec.e11 = 10.0; this->p_ucell->latvec.e12 = 0.0; this->p_ucell->latvec.e13 = 0.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->latvec.e21 = 0.0; this->p_ucell->latvec.e22 = 10.0; this->p_ucell->latvec.e23 = 0.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->latvec.e31 = 0.0; this->p_ucell->latvec.e32 = 0.0; this->p_ucell->latvec.e33 = 10.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->GT = this->p_ucell->latvec.Inverse();
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->G = this->p_ucell->GT.Transpose();
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->GGT = this->p_ucell->G * this->p_ucell->GT;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->tpiba = 2.0 * M_PI / this->p_ucell->lat0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->tpiba2 = this->p_ucell->tpiba * this->p_ucell->tpiba;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_ucell->atom_label != nullptr) delete[] this->p_ucell->atom_label;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atom_label = new std::string[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atom_label[0] = "Si";
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->nat = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->ntype = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms = new Atom[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].label = "Si";
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].mass = 28.0855;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].na = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].angle1 = new double[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].angle1[0] = 0.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].angle2 = new double[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].angle2[0] = 0.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].tau[0] = {0.0, 0.0, 0.0};
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].taud[0] = {0.25, 0.25, 0.25};
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].mbl[0] = {0, 0, 0};
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_ucell->pseudo_fn != nullptr) delete[] this->p_ucell->pseudo_fn;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->pseudo_fn = new std::string[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->pseudo_fn[0] = "Si_NCSR_ONCVPSP_v0.5_dojo.upf";
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->natomwfc = 4;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.nchi = 2;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.mesh = 10;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.msh = 10;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.lmax = 2;
module_psi/test/psi_initializer_unit_test.cpp:            //if(this->p_ucell->atoms[0].ncpp.rab != nullptr) delete[] this->p_ucell->atoms[0].ncpp.rab;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.rab = new double[10];
module_psi/test/psi_initializer_unit_test.cpp:            for(int i = 0; i < 10; ++i) this->p_ucell->atoms[0].ncpp.rab[i] = 0.01;
module_psi/test/psi_initializer_unit_test.cpp:            //if(this->p_ucell->atoms[0].ncpp.r != nullptr) delete[] this->p_ucell->atoms[0].ncpp.r;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.r = new double[10];
module_psi/test/psi_initializer_unit_test.cpp:            for(int i = 0; i < 10; ++i) this->p_ucell->atoms[0].ncpp.r[i] = 0.01*i;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.chi.create(2, 10);
module_psi/test/psi_initializer_unit_test.cpp:            for(int i = 0; i < 2; ++i) for(int j = 0; j < 10; ++j) this->p_ucell->atoms[0].ncpp.chi(i, j) = 0.01;
module_psi/test/psi_initializer_unit_test.cpp:            //if(this->p_ucell->atoms[0].ncpp.lchi != nullptr) delete[] this->p_ucell->atoms[0].ncpp.lchi;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.lchi = new int[2];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.lchi[0] = 0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.lchi[1] = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->lmax_ppwf = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.oc = new double[2];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.oc[0] = 1.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.oc[1] = 1.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.has_so = false;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.jchi = new double[2];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.jchi[0] = 0.5;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].ncpp.jchi[1] = 1.5;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->lmax = 2;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_ucell->orbital_fn != nullptr) delete[] this->p_ucell->orbital_fn;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->orbital_fn = new std::string[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->orbital_fn[0] = "Si_gga_8au_60Ry_2s2p1d.orb";
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].nwl = 2;
module_psi/test/psi_initializer_unit_test.cpp:            delete[] this->p_ucell->atoms[0].l_nchi;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].l_nchi = new int[3];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].l_nchi[0] = 2;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].l_nchi[1] = 2;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_ucell->atoms[0].l_nchi[2] = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->nks = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->npwk_max = 1;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->npwk != nullptr) delete[] this->p_pw_wfc->npwk;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->npwk = new int[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->npwk[0] = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->fftnxy = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->fftnz = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->nst = 1;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->nz = 1;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->is2fftixy != nullptr) delete[] this->p_pw_wfc->is2fftixy;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->is2fftixy = new int[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->is2fftixy[0] = 0;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->fftixy2ip != nullptr) delete[] this->p_pw_wfc->fftixy2ip;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->fftixy2ip = new int[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->fftixy2ip[0] = 0;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->igl2isz_k != nullptr) delete[] this->p_pw_wfc->igl2isz_k;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->igl2isz_k = new int[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->igl2isz_k[0] = 0;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->gcar != nullptr) delete[] this->p_pw_wfc->gcar;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->gcar = new ModuleBase::Vector3<double>[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->gcar[0] = {0.0, 0.0, 0.0};
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->igl2isz_k != nullptr) delete[] this->p_pw_wfc->igl2isz_k;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->igl2isz_k = new int[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->igl2isz_k[0] = 0;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->gk2 != nullptr) delete[] this->p_pw_wfc->gk2;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->gk2 = new double[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->gk2[0] = 0.0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->latvec.e11 = this->p_ucell->latvec.e11; this->p_pw_wfc->latvec.e12 = this->p_ucell->latvec.e12; this->p_pw_wfc->latvec.e13 = this->p_ucell->latvec.e13;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->latvec.e21 = this->p_ucell->latvec.e21; this->p_pw_wfc->latvec.e22 = this->p_ucell->latvec.e22; this->p_pw_wfc->latvec.e23 = this->p_ucell->latvec.e23;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->latvec.e31 = this->p_ucell->latvec.e31; this->p_pw_wfc->latvec.e32 = this->p_ucell->latvec.e32; this->p_pw_wfc->latvec.e33 = this->p_ucell->latvec.e33;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->G = this->p_ucell->G;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->GT = this->p_ucell->GT;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->GGT = this->p_ucell->GGT;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->lat0 = this->p_ucell->lat0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->tpiba = 2.0 * M_PI / this->p_ucell->lat0;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->tpiba2 = this->p_pw_wfc->tpiba * this->p_pw_wfc->tpiba;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->kvec_c != nullptr) delete[] this->p_pw_wfc->kvec_c;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->kvec_c = new ModuleBase::Vector3<double>[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->kvec_c[0] = {0.0, 0.0, 0.0};
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_pw_wfc->kvec_d != nullptr) delete[] this->p_pw_wfc->kvec_d;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->kvec_d = new ModuleBase::Vector3<double>[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pw_wfc->kvec_d[0] = {0.0, 0.0, 0.0};
module_psi/test/psi_initializer_unit_test.cpp:            this->p_pspot_vnl->lmaxkb = 0;
module_psi/test/psi_initializer_unit_test.cpp:            if(this->p_parakpts->startk_pool != nullptr) delete[] this->p_parakpts->startk_pool;
module_psi/test/psi_initializer_unit_test.cpp:            this->p_parakpts->startk_pool = new int[1];
module_psi/test/psi_initializer_unit_test.cpp:            this->p_parakpts->startk_pool[0] = 0;
module_psi/test/psi_initializer_unit_test.cpp:            delete this->p_sf;
module_psi/test/psi_initializer_unit_test.cpp:            delete this->p_pw_wfc;
module_psi/test/psi_initializer_unit_test.cpp:            delete this->p_ucell;
module_psi/test/psi_initializer_unit_test.cpp:            delete this->p_pspot_vnl;
module_psi/test/psi_initializer_unit_test.cpp:            delete this->p_parakpts;
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ("random", this->psi_init->method());
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ("atomic", this->psi_init->method());
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ("atomic+random", this->psi_init->method());
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ("nao", this->psi_init->method());
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ("nao+random", this->psi_init->method());
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(this->psi_init->template cast_to_T<std::complex<double>>(cd), cd);
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(this->psi_init->template cast_to_T<std::complex<float>>(cd), cf);
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(this->psi_init->template cast_to_T<double>(cd), d);
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(this->psi_init->template cast_to_T<float>(cd), f);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(0, this->psi_init->nbands_complem());
module_psi/test/psi_initializer_unit_test.cpp:    auto psig = this->psi_init->share_psig().lock();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(0, this->psi_init->nbands_complem());
module_psi/test/psi_initializer_unit_test.cpp:    auto psig = this->psi_init->share_psig().lock();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(0, this->psi_init->nbands_complem());
module_psi/test/psi_initializer_unit_test.cpp:    auto psig = this->psi_init->share_psig().lock();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(0, this->psi_init->nbands_complem());
module_psi/test/psi_initializer_unit_test.cpp:    auto psig = this->psi_init->share_psig().lock();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    EXPECT_EQ(0, this->psi_init->nbands_complem());
module_psi/test/psi_initializer_unit_test.cpp:    auto psig = this->psi_init->share_psig().lock();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->atoms[0].ncpp.has_so = false;
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->natomwfc *= 2;
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->atoms[0].ncpp.has_so = false;
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->natomwfc /= 2;
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->atoms[0].ncpp.has_so = true;
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->natomwfc *= 2;
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->atoms[0].ncpp.has_so = false;
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->natomwfc /= 2;
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_atomic_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao_random<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->atoms[0].ncpp.has_so = false;
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->atoms[0].ncpp.has_so = true;
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_psi/test/psi_initializer_unit_test.cpp:    this->p_ucell->atoms[0].ncpp.has_so = true;
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init = new psi_initializer_nao<std::complex<double>, psi::DEVICE_CPU>();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_parakpts, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed,
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl,
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->initialize(this->p_sf, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pw_wfc, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_ucell, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->random_seed, 
module_psi/test/psi_initializer_unit_test.cpp:                               this->p_pspot_vnl);
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->tabulate(); // always: new, initialize, tabulate, allocate, proj_ao_onkG
module_psi/test/psi_initializer_unit_test.cpp:    psi::Psi<std::complex<double>>* psi = this->psi_init->allocate();
module_psi/test/psi_initializer_unit_test.cpp:    this->psi_init->proj_ao_onkG(0);
module_relax/relax_driver.cpp:    this->istep = 1;
module_relax/relax_driver.cpp:            this->etot = p_esolver->cal_energy();
module_relax/relax_driver.cpp:                    stop = rl.relax_step(force, stress, this->etot);
module_relax/relax_driver.cpp:                                             this->etot,
module_relax/relax_new/line_search.cpp:        return this->first_order(x,y,f,xnew);
module_relax/relax_new/line_search.cpp:        return this->third_order(x,y,f,xnew,conv_thr);
module_relax/relax_new/line_search.cpp:        this->init_brent(x,y,f);
module_relax/relax_new/line_search.cpp:        this->update_brent(x,y,f);
module_relax/relax_new/line_search.cpp:        return this->brent(x,y,f,xnew,conv_thr);
module_relax/relax_new/relax.cpp:    bool relax_done = this->setup_gradient(force, stress);
module_relax/relax_new/relax.cpp:    this->calculate_gamma();
module_relax/relax_new/relax.cpp:    bool ls_done = this->check_line_search();
module_relax/relax_new/relax.cpp:        this->new_direction();
module_relax/relax_new/relax.cpp:        this->move_cell_ions(true);
module_relax/relax_new/relax.cpp:        this->perform_line_search();
module_relax/relax_new/relax.cpp:        this->move_cell_ions(false);
module_relax/relax_new/relax.cpp:    brent_done = this->ls.line_search(restart_brent, x, y, f, xnew, force_thr_eva);
module_relax/relax_new/relax.cpp:    this->ls.line_search(restart, x, y, f, xnew, yd);
module_relax/relax_new/test/relax_test.cpp:            this->setup_cell();
module_relax/relax_new/test/relax_test.h:    for (int it = 0; it < this->ntype; it++)
module_relax/relax_new/test/relax_test.h:        Atom* atom = &this->atoms[it];
module_relax/relax_new/test/relax_test.h:            this->atoms[it].taud[ia].x += posd_in[iat*3];
module_relax/relax_new/test/relax_test.h:            this->atoms[it].taud[ia].y += posd_in[iat*3 + 1];
module_relax/relax_new/test/relax_test.h:            this->atoms[it].taud[ia].z += posd_in[iat*3 + 2];
module_relax/relax_new/test/relax_test.h:    assert(iat == this->nat);
module_relax/relax_old/bfgs_basic.cpp:        //      s[i] = this->pos[i] - this->pos_p[i];
module_relax/relax_old/bfgs_basic.cpp:        s[i] = this->check_move(lat0, pos[i], pos_p[i]);
module_relax/relax_old/bfgs_basic.cpp:        y[i] = this->grad[i] - this->grad_p[i];
module_relax/relax_old/bfgs_basic.cpp:        this->reset_hessian();
module_relax/relax_old/bfgs_basic.cpp:            Hs[i] += this->inv_hess(i, j) * s[j];
module_relax/relax_old/bfgs_basic.cpp:            Hy[i] += this->inv_hess(i, j) * y[j];
module_relax/relax_old/bfgs_basic.cpp:            yH[i] += y[j] * this->inv_hess(j, i); // mohan modify 2009-09-07
module_relax/relax_old/bfgs_basic.cpp:            this->inv_hess(i, j)
module_relax/relax_old/bfgs_basic.cpp:    bool wolfe1 = (etot - etot_p) < this->relax_bfgs_w1 * dot_p;
module_relax/relax_old/bfgs_basic.cpp:    bool wolfe2 = std::abs(dot) > -this->relax_bfgs_w2 * dot_p;
module_relax/relax_old/bfgs_basic.cpp:    this->wolfe_flag = wolfe1 && wolfe2;
module_relax/relax_old/bfgs_basic.cpp:    this->save_flag = true;
module_relax/relax_old/bfgs_basic.cpp:        this->pos_p[i] = this->pos[i];
module_relax/relax_old/bfgs_basic.cpp:        this->grad_p[i] = this->grad[i];
module_relax/relax_old/bfgs_basic.cpp:        this->move_p[i] = this->move[i];
module_relax/relax_old/bfgs_basic.cpp:        this->check_wolfe_conditions();
module_relax/relax_old/bfgs_basic.cpp:        this->update_inverse_hessian(lat0);
module_relax/relax_old/bfgs_basic.cpp:                tmp += this->inv_hess(i, j) * this->grad[j];
module_relax/relax_old/bfgs_basic.cpp:            this->move[i] = -tmp;
module_relax/relax_old/bfgs_basic.cpp:        this->reset_hessian();
module_relax/relax_old/bfgs_basic.cpp:        this->tr_min_hit = false;
module_relax/relax_old/bfgs_basic.cpp:        this->compute_trust_radius();
module_relax/relax_old/bfgs_basic.cpp:    bool ltest = (etot - etot_p) < this->relax_bfgs_w1 * dot;
module_relax/relax_old/bfgs_basic.cpp:    double norm_move = dot_func(this->move, this->move, dim);
module_relax/relax_old/bfgs_basic.cpp:    if (this->wolfe_flag)
module_relax/relax_old/bfgs_basic.cpp:        this->reset_hessian();
module_relax/relax_old/ions_move_bfgs.cpp:    this->allocate_basic();
module_relax/relax_old/ions_move_bfgs.cpp:    this->save_flag = false;
module_relax/relax_old/ions_move_bfgs.cpp:    this->init_done = true;
module_relax/relax_old/ions_move_bfgs.cpp:        Ions_Move_Basic::setup_gradient(ucell, force, this->pos, this->grad);
module_relax/relax_old/ions_move_bfgs.cpp:        Ions_Move_Basic::setup_gradient(ucell, force, pos_tmp.data(), this->grad);
module_relax/relax_old/ions_move_bfgs.cpp:    Ions_Move_Basic::check_converged(ucell, this->grad);
module_relax/relax_old/ions_move_bfgs.cpp:        this->restart_bfgs(ucell.lat0);
module_relax/relax_old/ions_move_bfgs.cpp:        this->bfgs_routine(ucell.lat0);
module_relax/relax_old/ions_move_bfgs.cpp:        this->save_bfgs();
module_relax/relax_old/ions_move_bfgs.cpp:    if (this->save_flag)
module_relax/relax_old/ions_move_bfgs.cpp:            trust_radius_old += this->move_p[i] * this->move_p[i];
module_relax/relax_old/ions_move_bfgs.cpp:            this->move_p[i] = this->check_move(lat0, pos[i], pos_p[i]) / trust_radius_old;
module_relax/relax_old/ions_move_bfgs.cpp:        this->reset_hessian();
module_relax/relax_old/ions_move_bfgs.cpp:        this->tr_min_hit = false;
module_relax/relax_old/ions_move_bfgs.cpp:            dE0s += this->grad_p[i] * this->move_p[i];
module_relax/relax_old/ions_move_bfgs.cpp:            this->pos[i] = pos_p[i];
module_relax/relax_old/ions_move_bfgs.cpp:            this->grad[i] = grad_p[i];
module_relax/relax_old/ions_move_bfgs.cpp:            this->reset_hessian();
module_relax/relax_old/ions_move_bfgs.cpp:                this->move[i] = -grad[i];
module_relax/relax_old/ions_move_bfgs.cpp:                this->move[i] = this->move_p[i] / trust_radius_old;
module_relax/relax_old/ions_move_bfgs.cpp:        this->new_step(lat0);
module_relax/relax_old/ions_move_bfgs.cpp:    double norm = dot_func(this->move, this->move, dim);
module_relax/relax_old/ions_move_cg.cpp:    this->pos0 = nullptr;
module_relax/relax_old/ions_move_cg.cpp:    this->grad0 = nullptr;
module_relax/relax_old/ions_move_cg.cpp:    this->cg_grad0 = nullptr;
module_relax/relax_old/ions_move_cg.cpp:    this->move0 = nullptr;
module_relax/relax_old/ions_move_cg.cpp:    this->pos0 = new double[dim];
module_relax/relax_old/ions_move_cg.cpp:    this->grad0 = new double[dim];
module_relax/relax_old/ions_move_cg.cpp:    this->cg_grad0 = new double[dim];
module_relax/relax_old/ions_move_cg.cpp:    this->move0 = new double[dim];
module_relax/relax_old/ions_move_cg.cpp:    this->e0 = 0.0;
module_relax/relax_old/ions_move_methods.cpp:        this->bfgs.allocate();
module_relax/relax_old/ions_move_methods.cpp:        this->sd.allocate();
module_relax/relax_old/ions_move_methods.cpp:        this->cg.allocate();
module_relax/relax_old/ions_move_methods.cpp:        this->cg.allocate();
module_relax/relax_old/ions_move_methods.cpp:        this->bfgs.allocate(); // added by pengfei  13-8-8
module_relax/relax_old/ions_move_sd.cpp:    this->energy_saved = 1.0e10;
module_relax/relax_old/ions_move_sd.cpp:    this->grad_saved = nullptr;
module_relax/relax_old/ions_move_sd.cpp:    this->pos_saved = nullptr;
module_relax/relax_old/ions_move_sd.cpp:    this->grad_saved = new double[dim];
module_relax/relax_old/ions_move_sd.cpp:    this->pos_saved = new double[dim];
module_relax/relax_old/ions_move_sd.cpp:        this->cal_tradius_sd();
module_relax/relax_old/lattice_change_cg.cpp:    this->lat0 = nullptr;
module_relax/relax_old/lattice_change_cg.cpp:    this->grad0 = nullptr;
module_relax/relax_old/lattice_change_cg.cpp:    this->cg_grad0 = nullptr;
module_relax/relax_old/lattice_change_cg.cpp:    this->move0 = nullptr;
module_relax/relax_old/lattice_change_cg.cpp:    this->lat0 = new double[dim];
module_relax/relax_old/lattice_change_cg.cpp:    this->grad0 = new double[dim];
module_relax/relax_old/lattice_change_cg.cpp:    this->cg_grad0 = new double[dim];
module_relax/relax_old/lattice_change_cg.cpp:    this->move0 = new double[dim];
module_relax/relax_old/lattice_change_cg.cpp:    this->e0 = 0.0;
module_relax/relax_old/relax_old.cpp:    if (this->if_do_relax(ucell))
module_relax/relax_old/relax_old.cpp:        converged = this->do_relax(istep, force, energy, ucell, force_step);
module_relax/relax_old/relax_old.cpp:    if (this->if_do_cellrelax(ucell))
module_relax/relax_old/relax_old.cpp:        converged = this->do_cellrelax(istep, stress_step, stress, energy, ucell);
module_ri/Exx_LRI.hpp:    this->mpi_comm = mpi_comm_in;
module_ri/Exx_LRI.hpp:    this->p_kv = &kv_in;
module_ri/Exx_LRI.hpp:	this->lcaos = Exx_Abfs::Construct_Orbs::change_orbs( GlobalC::ORB, this->info.kmesh_times );
module_ri/Exx_LRI.hpp://	Exx_Abfs::Util::bcast( this->info.files_abfs, 0, this->mpi_comm );
module_ri/Exx_LRI.hpp:		abfs_same_atom = Exx_Abfs::Construct_Orbs::abfs_same_atom( this->lcaos, this->info.kmesh_times, this->info.pca_threshold );
module_ri/Exx_LRI.hpp:	if(this->info.files_abfs.empty())
module_ri/Exx_LRI.hpp:		this->abfs = abfs_same_atom;
module_ri/Exx_LRI.hpp:		this->abfs = Exx_Abfs::IO::construct_abfs( abfs_same_atom, GlobalC::ORB, this->info.files_abfs, this->info.kmesh_times );
module_ri/Exx_LRI.hpp:	Exx_Abfs::Construct_Orbs::print_orbs_size(this->abfs, GlobalV::ofs_running);
module_ri/Exx_LRI.hpp:		switch(this->info.ccp_type)
module_ri/Exx_LRI.hpp:				const double hf_Rcut = std::pow(0.75 * this->p_kv->nkstot_full/nspin0 * GlobalC::ucell.omega / (ModuleBase::PI), 1.0/3.0);
module_ri/Exx_LRI.hpp:				return {{"hse_omega", this->info.hse_omega}};
module_ri/Exx_LRI.hpp:    this->abfs_ccp = Conv_Coulomb_Pot_K::cal_orbs_ccp(this->abfs, this->info.ccp_type, get_ccp_parameter(), this->info.ccp_rmesh_times);
module_ri/Exx_LRI.hpp:	for( size_t T=0; T!=this->abfs.size(); ++T )
module_ri/Exx_LRI.hpp:		GlobalC::exx_info.info_ri.abfs_Lmax = std::max( GlobalC::exx_info.info_ri.abfs_Lmax, static_cast<int>(this->abfs[T].size())-1 );
module_ri/Exx_LRI.hpp:	this->cv.set_orbitals(
module_ri/Exx_LRI.hpp:		this->lcaos, this->abfs, this->abfs_ccp,
module_ri/Exx_LRI.hpp:		this->info.kmesh_times, this->info.ccp_rmesh_times );
module_ri/Exx_LRI.hpp://	this->m_abfsabfs.init_radial_table(Rradial);
module_ri/Exx_LRI.hpp://	this->m_abfslcaos_lcaos.init_radial_table(Rradial);
module_ri/Exx_LRI.hpp:	const std::array<Tcell,Ndim> period = {this->p_kv->nmp[0], this->p_kv->nmp[1], this->p_kv->nmp[2]};
module_ri/Exx_LRI.hpp:	this->exx_lri.set_parallel(this->mpi_comm, atoms_pos, latvec, period);
module_ri/Exx_LRI.hpp:	const std::array<Tcell,Ndim> period_Vs = LRI_CV_Tools::cal_latvec_range<Tcell>(1+this->info.ccp_rmesh_times);	
module_ri/Exx_LRI.hpp:		list_As_Vs = RI::Distribute_Equally::distribute_atoms_periods(this->mpi_comm, atoms, period_Vs, 2, false);
module_ri/Exx_LRI.hpp:		Vs = this->cv.cal_Vs(
module_ri/Exx_LRI.hpp:	this->cv.Vws = LRI_CV_Tools::get_CVws(Vs);
module_ri/Exx_LRI.hpp:	this->exx_lri.set_Vs(std::move(Vs), this->info.V_threshold);
module_ri/Exx_LRI.hpp:			dVs = this->cv.cal_dVs(
module_ri/Exx_LRI.hpp:		this->cv.dVws = LRI_CV_Tools::get_dCVws(dVs);
module_ri/Exx_LRI.hpp:		this->exx_lri.set_dVs(std::move(dVs), this->info.V_grad_threshold);
module_ri/Exx_LRI.hpp:		list_As_Cs = RI::Distribute_Equally::distribute_atoms_periods(this->mpi_comm, atoms, period_Cs, 2, false);
module_ri/Exx_LRI.hpp:		Cs_dCs = this->cv.cal_Cs_dCs(
module_ri/Exx_LRI.hpp:	this->cv.Cws = LRI_CV_Tools::get_CVws(Cs);
module_ri/Exx_LRI.hpp:	this->exx_lri.set_Cs(std::move(Cs), this->info.C_threshold);
module_ri/Exx_LRI.hpp:		this->cv.dCws = LRI_CV_Tools::get_dCVws(dCs);
module_ri/Exx_LRI.hpp:		this->exx_lri.set_dCs(std::move(dCs), this->info.C_grad_threshold);
module_ri/Exx_LRI.hpp:	this->exx_lri.set_csm_threshold(this->info.cauchy_threshold);
module_ri/Exx_LRI.hpp:	this->Hexxs.resize(GlobalV::NSPIN);
module_ri/Exx_LRI.hpp:	this->Eexx = 0;
module_ri/Exx_LRI.hpp:			this->exx_lri.set_Ds(Ds[is], this->info.dm_threshold);
module_ri/Exx_LRI.hpp:			this->exx_lri.cal_Hs();
module_ri/Exx_LRI.hpp:			this->exx_lri.set_Ds(Ds[is], this->info.dm_threshold, std::to_string(is));
module_ri/Exx_LRI.hpp:			this->exx_lri.cal_Hs({"","",std::to_string(is)});
module_ri/Exx_LRI.hpp:		this->Hexxs[is] = RI::Communicate_Tensors_Map_Judge::comm_map2_first(
module_ri/Exx_LRI.hpp:			this->mpi_comm, std::move(this->exx_lri.Hs), std::get<0>(judge[is]), std::get<1>(judge[is]));
module_ri/Exx_LRI.hpp:        this->Eexx += std::real(this->exx_lri.energy);
module_ri/Exx_LRI.hpp:		post_process_Hexx(this->Hexxs[is]);
module_ri/Exx_LRI.hpp:	this->Eexx = post_process_Eexx(this->Eexx);
module_ri/Exx_LRI.hpp:	this->exx_lri.set_csm_threshold(this->info.cauchy_force_threshold);
module_ri/Exx_LRI.hpp:	this->force_exx.create(GlobalC::ucell.nat, Ndim);
module_ri/Exx_LRI.hpp:		this->exx_lri.cal_force({"","",std::to_string(is),"",""});
module_ri/Exx_LRI.hpp:			for(const auto &force_item : this->exx_lri.force[idim])
module_ri/Exx_LRI.hpp:				this->force_exx(force_item.first, idim) += std::real(force_item.second);
module_ri/Exx_LRI.hpp:	this->force_exx *= frac;
module_ri/Exx_LRI.hpp:	this->exx_lri.set_csm_threshold(this->info.cauchy_stress_threshold);
module_ri/Exx_LRI.hpp:	this->stress_exx.create(Ndim, Ndim);
module_ri/Exx_LRI.hpp:		this->exx_lri.cal_stress({"","",std::to_string(is),"",""});
module_ri/Exx_LRI.hpp:				this->stress_exx(idim0,idim1) += std::real(this->exx_lri.stress(idim0,idim1));
module_ri/Exx_LRI.hpp:	this->stress_exx *= frac;
module_ri/Exx_LRI_interface.h:    std::vector< std::map<int, std::map<TAC, RI::Tensor<Tdata>>>>& get_Hexxs() const { return this->exx_ptr->Hexxs; }
module_ri/Exx_LRI_interface.h:    double& get_Eexx() const { return this->exx_ptr->Eexx; }
module_ri/Exx_LRI_interface.hpp:    oar(this->exx_ptr->Hexxs);
module_ri/Exx_LRI_interface.hpp:	iar(this->exx_ptr->Hexxs);
module_ri/Exx_LRI_interface.hpp:    for (int is = 0;is < this->exx_ptr->Hexxs.size();++is)
module_ri/Exx_LRI_interface.hpp:        for (const auto& HexxA : this->exx_ptr->Hexxs[is])
module_ri/Exx_LRI_interface.hpp:            this->calculate_RI_Tensor_sparse(sparse_threshold, this->exx_ptr->Hexxs[is], ucell),
module_ri/Exx_LRI_interface.hpp:    this->exx_ptr->Hexxs.resize(GlobalV::NSPIN);
module_ri/Exx_LRI_interface.hpp:                    this->exx_ptr->Hexxs[is][iat1][{iat2, dR}] = RI::Tensor<Tdata>({ static_cast<size_t>(ucell.atoms[ucell.iat2it[iat1]].nw), static_cast<size_t>(ucell.atoms[ucell.iat2it[iat2]].nw) });
module_ri/Exx_LRI_interface.hpp:                    this->exx_ptr->Hexxs.at(is).at(iat1).at({ iat2, dR })(ucell.iwt2iw[i], ucell.iwt2iw[j]) = matrix(i, j);
module_ri/Exx_LRI_interface.hpp:        this->exx_ptr->cal_exx_ions();
module_ri/Exx_LRI_interface.hpp:			this->mix_DMk_2D.set_nks(kv.nks, GlobalV::GAMMA_ONLY_LOCAL);
module_ri/Exx_LRI_interface.hpp:                this->mix_DMk_2D.set_mixing(nullptr);
module_ri/Exx_LRI_interface.hpp:				this->mix_DMk_2D.set_mixing(chgmix.get_mixing());
module_ri/Exx_LRI_interface.hpp:        this->two_level_step = 0;
module_ri/Exx_LRI_interface.hpp:        if (!GlobalC::exx_info.info_global.separate_loop && this->two_level_step)
module_ri/Exx_LRI_interface.hpp:            this->mix_DMk_2D.mix(dm.get_DMK_vector(), flag_restart);
module_ri/Exx_LRI_interface.hpp:					? RI_2D_Comm::split_m2D_ktoR<Tdata>(*this->exx_ptr->p_kv, this->mix_DMk_2D.get_DMk_gamma_out(), *dm.get_paraV_pointer())
module_ri/Exx_LRI_interface.hpp:					: RI_2D_Comm::split_m2D_ktoR<Tdata>(*this->exx_ptr->p_kv, this->mix_DMk_2D.get_DMk_k_out(), *dm.get_paraV_pointer());
module_ri/Exx_LRI_interface.hpp:            this->exx_ptr->cal_exx_elec(Ds, *dm.get_paraV_pointer());
module_ri/Exx_LRI_interface.hpp:            && this->two_level_step == 0 && iter == 1)
module_ri/Exx_LRI_interface.hpp:            if (GlobalV::MY_RANK == 0)GlobalC::restart.load_disk("Eexx", 0, 1, &this->exx_ptr->Eexx);
module_ri/Exx_LRI_interface.hpp:            Parallel_Common::bcast_double(this->exx_ptr->Eexx);
module_ri/Exx_LRI_interface.hpp:            this->exx_ptr->Eexx /= GlobalC::exx_info.info_global.hybrid_alpha;
module_ri/Exx_LRI_interface.hpp:        elec.set_exx(this->get_Eexx());
module_ri/Exx_LRI_interface.hpp:            this->exx_ptr->Eexx = 0;
module_ri/Exx_LRI_interface.hpp:            if (this->two_level_step)
module_ri/Exx_LRI_interface.hpp:                this->two_level_step++;
module_ri/Exx_LRI_interface.hpp:        else if (this->two_level_step == GlobalC::exx_info.info_global.hybrid_step
module_ri/Exx_LRI_interface.hpp:            || (iter == 1 && this->two_level_step != 0))
module_ri/Exx_LRI_interface.hpp:            if (this->two_level_step == 0)
module_ri/Exx_LRI_interface.hpp:            const bool flag_restart = (this->two_level_step == 0) ? true : false;
module_ri/Exx_LRI_interface.hpp:            this->mix_DMk_2D.mix(dm.get_DMK_vector(), flag_restart);
module_ri/Exx_LRI_interface.hpp:					? RI_2D_Comm::split_m2D_ktoR<Tdata>(*this->exx_ptr->p_kv, this->mix_DMk_2D.get_DMk_gamma_out(), *dm.get_paraV_pointer())
module_ri/Exx_LRI_interface.hpp:					: RI_2D_Comm::split_m2D_ktoR<Tdata>(*this->exx_ptr->p_kv, this->mix_DMk_2D.get_DMk_k_out(), *dm.get_paraV_pointer());
module_ri/Exx_LRI_interface.hpp:            this->exx_ptr->cal_exx_elec(Ds, *dm.get_paraV_pointer());
module_ri/Exx_LRI_interface.hpp:            this->two_level_step++;
module_ri/Inverse_Matrix.hpp:	this->A = m.copy();
module_ri/Inverse_Matrix.hpp:	this->A = RI::Tensor<Tdata>({n_all, n_all});
module_ri/Inverse_Matrix.hpp:					this->A(im0+n0_partial[Im0], im1+n1_partial[Im1]) = m_tmp(im0,im1);
module_ri/Inverse_Matrix.hpp:	return this->A.copy();
module_ri/Inverse_Matrix.hpp:	assert( std::accumulate(n0.begin(), n0.end(), 0) == this->A.shape[0] );
module_ri/Inverse_Matrix.hpp:	assert( std::accumulate(n1.begin(), n1.end(), 0) == this->A.shape[1] );
module_ri/Inverse_Matrix.hpp:					m_tmp(im0,im1) = this->A(im0+n0_partial[Im0], im1+n1_partial[Im1]);
module_ri/LRI_CV.h:	size_t get_index_abfs_size(const size_t &iat){return this->index_abfs[iat].count_size; }
module_ri/LRI_CV.hpp:	this->lcaos = lcaos_in;
module_ri/LRI_CV.hpp:	this->abfs = abfs_in;
module_ri/LRI_CV.hpp:	this->abfs_ccp = abfs_ccp_in;
module_ri/LRI_CV.hpp:	this->ccp_rmesh_times = ccp_rmesh_times_in;
module_ri/LRI_CV.hpp:	this->index_lcaos = ModuleBase::Element_Basis_Index::construct_index( range_lcaos );
module_ri/LRI_CV.hpp:	this->index_abfs = ModuleBase::Element_Basis_Index::construct_index( range_abfs );
module_ri/LRI_CV.hpp:	this->m_abfs_abfs.init( 2, kmesh_times, (1+this->ccp_rmesh_times)/2.0 );
module_ri/LRI_CV.hpp:	this->m_abfs_abfs.init_radial( this->abfs_ccp, this->abfs );
module_ri/LRI_CV.hpp:	this->m_abfs_abfs.init_radial_table();
module_ri/LRI_CV.hpp:	this->m_abfslcaos_lcaos.init( 1, kmesh_times, 1 );
module_ri/LRI_CV.hpp:	this->m_abfslcaos_lcaos.init_radial( this->abfs_ccp, this->lcaos, this->lcaos );
module_ri/LRI_CV.hpp:	this->m_abfslcaos_lcaos.init_radial_table();
module_ri/LRI_CV.hpp:	return this->cal_datas(list_A0, list_A1, flags, this->ccp_rmesh_times, func_DPcal_V);
module_ri/LRI_CV.hpp:		this->cal_datas(list_A0, list_A1, flags, this->ccp_rmesh_times, func_DPcal_dV));
module_ri/LRI_CV.hpp:		Cs_dCs_tmp = this->cal_datas(list_A0, list_A1, flags, std::min(1.0,this->ccp_rmesh_times), func_DPcal_C_dC);
module_ri/LRI_CV.hpp:				this->index_abfs, this->index_abfs,
module_ri/LRI_CV.hpp:		&this->m_abfs_abfs,
module_ri/LRI_CV.hpp:	return this->DPcal_o11(it0, it1, R, flags.at("writable_Vws"), this->rwlock_Vw, this->Vws, cal_overlap_matrix);
module_ri/LRI_CV.hpp:		const size_t size = this->index_abfs[it0].count_size;
module_ri/LRI_CV.hpp:			pthread_rwlock_wrlock(&this->rwlock_dVw);
module_ri/LRI_CV.hpp:			this->dVws[it0][it1][R] = dV;
module_ri/LRI_CV.hpp:			pthread_rwlock_unlock(&this->rwlock_dVw);
module_ri/LRI_CV.hpp:		&this->m_abfs_abfs,
module_ri/LRI_CV.hpp:	return this->DPcal_o11(it0, it1, R, flags.at("writable_dVws"), this->rwlock_dVw, this->dVws, cal_grad_overlap_matrix);
module_ri/LRI_CV.hpp:	pthread_rwlock_rdlock(&this->rwlock_Cw);
module_ri/LRI_CV.hpp:	const RI::Tensor<Tdata> C_read = RI::Global_Func::find(this->Cws, it0, it1, R);
module_ri/LRI_CV.hpp:	pthread_rwlock_unlock(&this->rwlock_Cw);
module_ri/LRI_CV.hpp:	pthread_rwlock_rdlock(&this->rwlock_dCw);
module_ri/LRI_CV.hpp:	const std::array<RI::Tensor<Tdata>,3> dC_read = RI::Global_Func::find(this->dCws, it0, it1, R);
module_ri/LRI_CV.hpp:	pthread_rwlock_unlock(&this->rwlock_dCw);
module_ri/LRI_CV.hpp:				A = this->m_abfslcaos_lcaos.template cal_overlap_matrix<Tdata>(
module_ri/LRI_CV.hpp:						this->index_abfs, this->index_lcaos, this->index_lcaos,
module_ri/LRI_CV.hpp:			const RI::Tensor<Tdata> V = this->DPcal_V( it0, it0, {0,0,0}, {{"writable_Vws",true}});
module_ri/LRI_CV.hpp:				pthread_rwlock_wrlock(&this->rwlock_Cw);
module_ri/LRI_CV.hpp:				this->Cws[it0][it1][{0,0,0}] = C;
module_ri/LRI_CV.hpp:				pthread_rwlock_unlock(&this->rwlock_Cw);
module_ri/LRI_CV.hpp:				const RI::Shape_Vector sizes = {this->index_abfs[it0].count_size,
module_ri/LRI_CV.hpp:				                                this->index_lcaos[it0].count_size,
module_ri/LRI_CV.hpp:				                                this->index_lcaos[it0].count_size};
module_ri/LRI_CV.hpp:					pthread_rwlock_wrlock(&this->rwlock_dCw);
module_ri/LRI_CV.hpp:					this->dCws[it0][it1][{0,0,0}] = dC;
module_ri/LRI_CV.hpp:					pthread_rwlock_unlock(&this->rwlock_dCw);
module_ri/LRI_CV.hpp:				A = {this->m_abfslcaos_lcaos.template cal_overlap_matrix<Tdata>(
module_ri/LRI_CV.hpp:						this->index_abfs, this->index_lcaos, this->index_lcaos,
module_ri/LRI_CV.hpp:				     this->m_abfslcaos_lcaos.template cal_overlap_matrix<Tdata>(
module_ri/LRI_CV.hpp:						this->index_abfs, this->index_lcaos, this->index_lcaos,
module_ri/LRI_CV.hpp:				pthread_rwlock_wrlock(&this->rwlock_Cw);
module_ri/LRI_CV.hpp:				this->Cws[it0][it1][R] = C[0];
module_ri/LRI_CV.hpp:				this->Cws[it1][it0][Rm] = LRI_CV_Tools::transpose12(C[1]);
module_ri/LRI_CV.hpp:				pthread_rwlock_unlock(&this->rwlock_Cw);
module_ri/LRI_CV.hpp:					dA = {this->m_abfslcaos_lcaos.template cal_grad_overlap_matrix<Tdata>(
module_ri/LRI_CV.hpp:								this->index_abfs, this->index_lcaos, this->index_lcaos,
module_ri/LRI_CV.hpp:					       this->m_abfslcaos_lcaos.template cal_grad_overlap_matrix<Tdata>(
module_ri/LRI_CV.hpp:								this->index_abfs, this->index_lcaos, this->index_lcaos,
module_ri/LRI_CV.hpp:					pthread_rwlock_wrlock(&this->rwlock_dCw);
module_ri/LRI_CV.hpp:					this->dCws[it0][it1][R] = dC[0];
module_ri/LRI_CV.hpp:					this->dCws[it1][it0][Rm] = LRI_CV_Tools::negative(LRI_CV_Tools::transpose12(dC[1]));
module_ri/LRI_CV.hpp:					pthread_rwlock_unlock(&this->rwlock_dCw);
module_ri/Matrix_Orbs11.cpp:	this->MOT.allocate(
module_ri/Matrix_Orbs11.cpp:	this->MOT.init_Table_Spherical_Bessel (2, mode, Lmax_used, Lmax, GlobalC::exx_info.info_ri.abfs_Lmax, GlobalC::ORB, GlobalC::ucell.infoNL.Beta);
module_ri/Matrix_Orbs11.cpp://	this->MOT.init_OV_Tpair();							// for this->MOT.OV_L2plus1
module_ri/Matrix_Orbs11.cpp://	this->MOT.Destroy_Table_Spherical_Bessel (Lmax_used);				// why?
module_ri/Matrix_Orbs11.cpp:	this->MGT.init_Gaunt_CH( Lmax );
module_ri/Matrix_Orbs11.cpp:	this->MGT.init_Gaunt( Lmax );
module_ri/Matrix_Orbs11.cpp:									this->MOT, this->MGT)));
module_ri/Matrix_Orbs11.cpp:									this->MOT, this->MGT)));
module_ri/Matrix_Orbs11.cpp:					const double position = R * GlobalC::ucell.lat0 / this->MOT.dr;
module_ri/Matrix_Orbs11.h:	// this->center2_orb11_s[TA][TB][LA][NA][LB][NB]
module_ri/Matrix_Orbs21.cpp:	this->MOT.allocate(
module_ri/Matrix_Orbs21.cpp:	this->MOT.init_Table_Spherical_Bessel (3,mode, Lmax_used, Lmax, GlobalC::exx_info.info_ri.abfs_Lmax, GlobalC::ORB, GlobalC::ucell.infoNL.Beta);
module_ri/Matrix_Orbs21.cpp://	this->MOT.init_OV_Tpair();							// for this->MOT.OV_L2plus1
module_ri/Matrix_Orbs21.cpp://	this->MOT.Destroy_Table_Spherical_Bessel (Lmax_used);				// why?
module_ri/Matrix_Orbs21.cpp:	this->MGT.init_Gaunt_CH( 2*Lmax+1 );			// why +1
module_ri/Matrix_Orbs21.cpp:	this->MGT.init_Gaunt( 2*Lmax+1 );
module_ri/Matrix_Orbs21.cpp:											this->MOT, this->MGT)));
module_ri/Matrix_Orbs21.cpp:											this->MOT, this->MGT)));
module_ri/Matrix_Orbs21.cpp:					const double position = R * GlobalC::ucell.lat0 / this->MOT.dr;
module_ri/Matrix_Orbs21.h:	// this->center2_orb21_s[TA][TB][LA1][NA1][LA2][NA2][LB][NB]
module_ri/Matrix_Orbs22.cpp:	this->MOT.allocate(
module_ri/Matrix_Orbs22.cpp:	this->MOT.init_Table_Spherical_Bessel (4, mode, Lmax_used, Lmax, GlobalC::exx_info.info_ri.abfs_Lmax, GlobalC::ORB, GlobalC::ucell.infoNL.Beta);
module_ri/Matrix_Orbs22.cpp://	this->MOT.init_OV_Tpair();							// for this->MOT.OV_L2plus1
module_ri/Matrix_Orbs22.cpp://	this->MOT.Destroy_Table_Spherical_Bessel (Lmax_used);				// why?
module_ri/Matrix_Orbs22.cpp:	this->MGT.init_Gaunt_CH( 2*Lmax+1 );			// why +1
module_ri/Matrix_Orbs22.cpp:	this->MGT.init_Gaunt( 2*Lmax+1 );
module_ri/Matrix_Orbs22.cpp:													this->MOT, this->MGT)));
module_ri/Matrix_Orbs22.cpp:													this->MOT, this->MGT)));
module_ri/Matrix_Orbs22.cpp:					const double position = R * GlobalC::ucell.lat0 / this->MOT.dr;
module_ri/Matrix_Orbs22.h:	// this->center2_orb22_s[TA][TB][LA1][NA1][LA2][NA2][LB1][NB1][LB2][NB2]
module_ri/Mix_DMk_2D.cpp:    this->gamma_only = gamma_only_in;
module_ri/Mix_DMk_2D.cpp:    if (this->gamma_only)
module_ri/Mix_DMk_2D.cpp:		this->mix_DMk_gamma.resize(nks);
module_ri/Mix_DMk_2D.cpp:		this->mix_DMk_k.resize(nks);
module_ri/Mix_DMk_2D.cpp:	if(this->gamma_only)
module_ri/Mix_DMk_2D.cpp:        for (Mix_Matrix<std::vector<double>>& mix_one : this->mix_DMk_gamma)
module_ri/Mix_DMk_2D.cpp:        for (Mix_Matrix<std::vector<std::complex<double>>>& mix_one : this->mix_DMk_k)
module_ri/Mix_DMk_2D.cpp:	if(this->gamma_only)
module_ri/Mix_DMk_2D.cpp:        for (Mix_Matrix<std::vector<double>>& mix_one : this->mix_DMk_gamma)
module_ri/Mix_DMk_2D.cpp:        for (Mix_Matrix<std::vector<std::complex<double>>>& mix_one : this->mix_DMk_k)
module_ri/Mix_DMk_2D.cpp:	assert(this->mix_DMk_gamma.size() == dm.size());
module_ri/Mix_DMk_2D.cpp:		this->mix_DMk_gamma[ik].mix(dm[ik], flag_restart);
module_ri/Mix_DMk_2D.cpp:	assert(this->mix_DMk_k.size() == dm.size());
module_ri/Mix_DMk_2D.cpp:		this->mix_DMk_k[ik].mix(dm[ik], flag_restart);
module_ri/Mix_DMk_2D.cpp:    std::vector<const std::vector<double>*> DMk_out(this->mix_DMk_gamma.size());
module_ri/Mix_DMk_2D.cpp:	for(int ik=0; ik<this->mix_DMk_gamma.size(); ++ik)
module_ri/Mix_DMk_2D.cpp:		DMk_out[ik] = &this->mix_DMk_gamma[ik].get_data_out();
module_ri/Mix_DMk_2D.cpp:    std::vector<const std::vector<std::complex<double>>*> DMk_out(this->mix_DMk_k.size());
module_ri/Mix_DMk_2D.cpp:	for(int ik=0; ik<this->mix_DMk_k.size(); ++ik)
module_ri/Mix_DMk_2D.cpp:		DMk_out[ik] = &this->mix_DMk_k[ik].get_data_out();
module_ri/Mix_Matrix.cpp:			this->mixing = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_ri/Mix_Matrix.cpp:		this->data_out = data_in;
module_ri/Mix_Matrix.cpp:		this->mixing->init_mixing_data(this->matrix_data, data_in.nc*data_in.nr, sizeof(*data_in.c));
module_ri/Mix_Matrix.cpp:		this->mixing->push_data(this->matrix_data, data_out.c, data_in.c, nullptr, false);
module_ri/Mix_Matrix.cpp:		this->mixing->mix_data(this->matrix_data, data_out.c);
module_ri/Mix_Matrix.cpp:		delete this->mixing;
module_ri/Mix_Matrix.cpp:		this->mixing = nullptr;
module_ri/Mix_Matrix.cpp:        this->mixing = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_ri/Mix_Matrix.cpp:        this->data_out = data_in;
module_ri/Mix_Matrix.cpp:        this->mixing->init_mixing_data(this->matrix_data, data_in.nc * data_in.nr, sizeof(*data_in.c));
module_ri/Mix_Matrix.cpp:        this->mixing->push_data(this->matrix_data, data_out.c, data_in.c, nullptr, false);
module_ri/Mix_Matrix.cpp:        this->mixing->mix_data(this->matrix_data, data_out.c);
module_ri/Mix_Matrix.cpp:        delete this->mixing;
module_ri/Mix_Matrix.cpp:        this->mixing = nullptr;
module_ri/Mix_Matrix.cpp:        this->mixing = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_ri/Mix_Matrix.cpp:        this->data_out = data_in;
module_ri/Mix_Matrix.cpp:        this->mixing->init_mixing_data(this->matrix_data, data_in.size(), sizeof(*data_in.data()));
module_ri/Mix_Matrix.cpp:        this->mixing->push_data(this->matrix_data, data_out.data(), data_in.data(), nullptr, false);
module_ri/Mix_Matrix.cpp:        this->mixing->mix_data(this->matrix_data, data_out.data());
module_ri/Mix_Matrix.cpp:        delete this->mixing;
module_ri/Mix_Matrix.cpp:        this->mixing = nullptr;
module_ri/Mix_Matrix.cpp:        this->mixing = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_ri/Mix_Matrix.cpp:        this->data_out = data_in;
module_ri/Mix_Matrix.cpp:        this->mixing->init_mixing_data(this->matrix_data, data_in.size(), sizeof(*data_in.data()));
module_ri/Mix_Matrix.cpp:        this->mixing->push_data(this->matrix_data, data_out.data(), data_in.data(), nullptr, false);
module_ri/Mix_Matrix.cpp:        this->mixing->mix_data(this->matrix_data, data_out.data());
module_ri/Mix_Matrix.cpp:        delete this->mixing;
module_ri/Mix_Matrix.cpp:        this->mixing = nullptr;
module_ri/Mix_Matrix.cpp:        this->mixing = new Base_Mixing::Plain_Mixing(this->mixing_beta);
module_ri/Mix_Matrix.cpp:        this->data_out = data_in;
module_ri/Mix_Matrix.cpp:        this->mixing->init_mixing_data(this->matrix_data, data_in.NumElements(), sizeof(data_in.SizeOfType(data_in.data_type())));
module_ri/Mix_Matrix.cpp:            this->mixing->push_data(this->matrix_data, data_out.data<double>(), data_in.data<double>(), nullptr, false);
module_ri/Mix_Matrix.cpp:            this->mixing->mix_data(this->matrix_data, data_out.data<double>());
module_ri/Mix_Matrix.cpp:            this->mixing->push_data(this->matrix_data, data_out.data<std::complex<double>>(), data_in.data<std::complex<double>>(), nullptr, false);
module_ri/Mix_Matrix.cpp:            this->mixing->mix_data(this->matrix_data, data_out.data<std::complex<double>>());
module_ri/Mix_Matrix.cpp:        delete this->mixing;
module_ri/Mix_Matrix.cpp:        this->mixing = nullptr;
module_ri/Mix_Matrix.h:        this->mixing = mixing_in;
module_ri/Mix_Matrix.h:        if (this->mixing == nullptr)
module_ri/Mix_Matrix.h:            this->separate_loop = true;
module_ri/Mix_Matrix.h:        return this->data_out;
module_ri/RPA_LRI.hpp:    this->mpi_comm = mpi_comm_in;
module_ri/RPA_LRI.hpp:    this->lcaos = exx_lri_rpa.lcaos;
module_ri/RPA_LRI.hpp:    this->abfs = exx_lri_rpa.abfs;
module_ri/RPA_LRI.hpp:    this->abfs_ccp = exx_lri_rpa.abfs_ccp;
module_ri/RPA_LRI.hpp:    this->p_kv = &kv_in;
module_ri/RPA_LRI.hpp:    //	this->cv = std::move(exx_lri_rpa.cv);
module_ri/RPA_LRI.hpp:    const std::array<Tcell, Ndim> period_Vs = LRI_CV_Tools::cal_latvec_range<Tcell>(1 + this->info.ccp_rmesh_times);
module_ri/RPA_LRI.hpp:        = RI::Distribute_Equally::distribute_atoms(this->mpi_comm, atoms, period_Vs, 2, false);
module_ri/RPA_LRI.hpp:    this->Vs_period = RI::RI_Tools::cal_period(Vs, period);
module_ri/RPA_LRI.hpp:        = RI::Distribute_Equally::distribute_atoms_periods(this->mpi_comm, atoms, period_Cs, 2, false);
module_ri/RPA_LRI.hpp:    this->Cs_period = RI::RI_Tools::cal_period(Cs, period);
module_ri/RPA_LRI.hpp:    this->out_bands(pelec);
module_ri/RPA_LRI.hpp:    this->out_eigen_vector(parav, psi);
module_ri/RPA_LRI.hpp:    this->out_struc();
module_ri/RPA_LRI.hpp:    this->cal_rpa_cv();
module_ri/RPA_LRI.hpp:    std::cout << "rpa_pca_threshold: " << this->info.pca_threshold << std::endl;
module_ri/RPA_LRI.hpp:    std::cout << "rpa_ccp_rmesh_times: " << this->info.ccp_rmesh_times << std::endl;
module_ri/RPA_LRI.hpp:    this->out_Cs();
module_ri/RPA_LRI.hpp:    this->out_coulomb_k();
module_ri/RPA_LRI.hpp:    for (auto &Ip: this->Cs_period)
module_ri/RPA_LRI.hpp:    for (auto &Ip: this->Vs_period)
module_ri/RPA_LRI.hpp:// 	if(this->info == this->exx.info)
module_ri/RPA_LRI.hpp:// 		this->lcaos = this->exx.lcaos;
module_ri/RPA_LRI.hpp:// 		this->abfs = this->exx.abfs;
module_ri/RPA_LRI.hpp:// 		this->abfs_ccp = this->exx.abfs_ccp;
module_ri/RPA_LRI.hpp:// 		exx_lri_rpa.cv = std::move(this->exx.cv);
module_ri/RPA_LRI.hpp:// 		this->lcaos = ...
module_ri/RPA_LRI.hpp:// 		this->abfs = ...
module_ri/RPA_LRI.hpp:// 		this->abfs_ccp = ...
module_ri/RPA_LRI.hpp:// 			this->lcaos, this->abfs, this->abfs_ccp,
module_ri/RPA_LRI.hpp:// 			this->info.kmesh_times, this->info.ccp_rmesh_times );
module_ri/RPA_LRI.hpp:// //	for( size_t T=0; T!=this->abfs.size(); ++T )
module_ri/RPA_LRI.hpp:// static_cast<int>(this->abfs[T].size())-1 );
module_ri/RPA_LRI.hpp:// 	// this->rpa_lri.set_parallel(this->mpi_comm, atoms_pos, latvec, period);
module_ri/RPA_LRI.hpp:// 	if(this->info == this->exx.info)
module_ri/RPA_LRI.hpp:// 		exx_lri_rpa.cv.Vws = std::move(this->exx.cv.Vws);
module_ri/RPA_LRI.hpp:// 	const std::array<Tcell,Ndim> period_Vs = LRI_CV_Tools::cal_latvec_range<Tcell>(1+this->info.ccp_rmesh_times);
module_ri/RPA_LRI.hpp:// 		list_As_Vs = RI::Distribute_Equally::distribute_atoms(this->mpi_comm, atoms, period_Vs, 2, false);
module_ri/RPA_LRI.hpp:// 	if(this->info == this->exx.info)
module_ri/RPA_LRI.hpp:// 		exx_lri_rpa.cv.Cws = std::move(this->exx.cv.Cws);
module_ri/RPA_LRI.hpp:// 		list_As_Cs = RI::Distribute_Equally::distribute_atoms_periods(this->mpi_comm, atoms, period_Cs, 2, false);
module_ri/exx_opt_orb.cpp:		lcaos = Exx_Abfs::Construct_Orbs::change_orbs( GlobalC::ORB, this->kmesh_times );
module_ri/exx_opt_orb.cpp:		abfs = Exx_Abfs::Construct_Orbs::abfs_same_atom( lcaos, this->kmesh_times, GlobalC::exx_info.info_ri.pca_threshold );
module_ri/exx_opt_orb.cpp:	jle.init_jle( this->kmesh_times );
module_ri/exx_opt_orb.cpp:		m_lcaoslcaos_lcaoslcaos.init( 1, this->kmesh_times, 1 );
module_ri/exx_opt_orb.cpp:		m_jyslcaos_lcaos.init( 1, this->kmesh_times, 1 );
module_ri/exx_opt_orb.cpp:		m_jys_jys.init( 2, this->kmesh_times, 1 );
module_ri/exx_opt_orb.cpp:		m_abfs_abfs.init( 2, this->kmesh_times, 1 );
module_ri/exx_opt_orb.cpp:		m_abfslcaos_lcaos.init( 1, this->kmesh_times, 1 );
module_ri/exx_opt_orb.cpp:		m_jys_abfs.init( 2, this->kmesh_times, 1 );
