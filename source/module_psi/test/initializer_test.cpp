#include <iostream>
#include <fstream>
#include <string>
#include <regex>

#include "../psi_initializer.h"
#include "../psi_initializer_atomic.h"
#include "../psi_initializer_nao.h"
#include "../psi_initializer_random.h"
#include "../psi_initializer_nao_random.h"
#include "../psi_initializer_atomic_random.h"
#include <gtest/gtest.h>

/*
* --------------------------
* unit test of psi_initializer
* --------------------------
*
* Description:
*   This unit test is to test the psi_initializer class.
*   The psi_initializer class is used to initialize the wavefunction.
*   calculation to test:
*
*   -----INPUT-----
*   calculation scf
*   nbands 1
*   psi_initializer 1
*   init_wfc random
*   ks_solver cg
*   lspinorb 0
*   noncolin 0
*   nspin 1
*   ecutwfc 100 # not used, because too large to get all reference values by hand
*   ecutrho 400 # not used, because too large to get all reference values by hand
*   
*   -----STRU-----
*   ATOMIC_SPECIES
*   X 1.000 X_ONCV_PBE-1.0.upf
*   NUMERICAL_ORBITAL
*   X_gga_6au100Ry_1s3p.orb
*   LATTICE_CONSTANT
*   1.234
*   LATTICE_VECTORS
*   1.0 0.0 0.0
*   0.0 1.0 0.0
*   0.0 0.0 1.0
*   ATOMIC_POSITIONS
*   X # atom label
*   0.0 # starting_magnetization
*   0.0 0.0 0.0 m 1 1 1 # tau x y z m constraint_x constraint_y constraint_z
* 
*   ------KPT------
*   K_POINTS
*   0 # nk
*   Gamma
*   1 1 1 0 0 0 # nkx nky nkz shiftx shifty shiftz
*
*   functions to test:
*     - constructor
*       - constructor of psi_initializer the base class and atomic, random, nao, atomic+random, nao+random
*     - allocate
*       - allocate memory for wavefunctions both ESolver_FP::psi and the psig, the version before subspace diagonalization
*     - stick_to_pool
*       - distribute data in sticks to processors
*   functions deprecated:
*     - psi_initializer::get_starting_nw
*     - psi_initializer_atomic::set_pseudopot_files
*     - psi_initializer_nao::set_orbital_files
*   functions tested in another way:
*     - random_t
*       - generate random wavefunction. This function can be directly tested by comparing the random wavefunction with the old one when ks_solver = "dav",
*         because the random wavefunction is generated by the same random seed and Davidson algorithm will only cut parts of random wavefunction rather than
*         diagonalize it like cg. So in practice, use the following two sets of keywords to test this function:
*         - ks_solver dav
*           init_wfc random
*           psi_initializer 1 # this newly-implemented version of psi initializer
*           wfc_dump 1 # dump the wavefunction
*         - ks_solver dav
*           init_wfc random
*           psi_initializer 0 # the old version of psi initializer
*           wfc_dump 1 # dump the wavefunction
*         and then compare the two wavefunctions.
*     - psi_initializer::cal_psig
*       - generate the initialized psi. Unfortunately, this function is quite heavy in all cases, the test will be done similarly as random_t.
*   functions not needed to test:
*     - psi_initializer_atomic::cal_ovlp_pswfcjlq
*       - calculate overlap between spherical Bessel function and pseudo wavefunction, is actually simply a wrapper of spherical bessel transformation
*     - psi_initializer_nao::cal_ovlp_flzjlq
*       - calculate overlap between spherical Bessel function and numerical orbital, is actually simply a wrapper of spherical bessel transformation
*     correctness of these two functions depend on implementation of spherical bessel transformation, which is tested in another unit test.
*   Correctness declaration:
*   1. This class is based on some basic mathematical libs, which should be tested before this class.
*   2.                             data structure classes, such as PW_Basis, PW_Basis_K, Psi, which should be tested before this class.
*   3.                             functional classes, such as Structure_Factor, which should be tested before this class.
*/

/// @brief mock the global variables describing calculation settings
void mock_GlobalV() {
    // basic calculation description
    GlobalV::CALCULATION = "scf";
    // ekb related info.
    GlobalV::NBANDS = 1;
    GlobalV::NLOCAL = 1;
    // electronic structure related info.
    GlobalV::NPOL = 1;
    GlobalV::LSPINORB = false;
    GlobalV::NONCOLIN = false;
    GlobalV::DOMAG = false;
    GlobalV::DOMAG_Z = false;
    // wavefunction initialization
    GlobalV::init_wfc = "random";
    GlobalV::psi_initializer = true;
    // ohter settings
    GlobalV::test_wf = 0;
    // diagonalization settings
    GlobalV::KS_SOLVER = "cg";
    // parallelization settings
    GlobalV::RANK_IN_POOL = 0;
    // reciprocal space related info.
    GlobalV::NQX = 1;
    GlobalV::DQ = 0.01;
}
/// @brief mock the global variables describing structure to calculate
void mock_GlobalC() {
    GlobalC::ucell.natomwfc = 1;
    GlobalC::ucell.nat = 1;
    GlobalC::ucell.ntype = 1;
    if (GlobalC::ucell.atoms != nullptr) delete[] GlobalC::ucell.atoms;
    GlobalC::ucell.atoms = new Atom[1];
    GlobalC::ucell.atoms[0].nwl = 1; // p orbital
    if (GlobalC::ucell.atoms[0].lchi != nullptr) delete[] GlobalC::ucell.atoms[0].lchi;
    GlobalC::ucell.atoms[0].l_nchi = new int[GlobalC::ucell.atoms[0].nwl + 1];
    GlobalC::ucell.atoms[0].l_nchi[0] = 1; // give s orbital 1 chi
    GlobalC::ucell.atoms[0].l_nchi[1] = 3; // give p orbital 3 chi
    if (GlobalC::ucell.atoms[0].tau != nullptr) delete[] GlobalC::ucell.atoms[0].tau;
    GlobalC::ucell.atoms[0].tau = new ModuleBase::Vector3<double>[1];
    GlobalC::ucell.atoms[0].tau[0].x = 0.0;
    GlobalC::ucell.atoms[0].tau[0].y = 0.0;
    GlobalC::ucell.atoms[0].tau[0].z = 0.0;
    if (GlobalC::ucell.atoms[0].taud != nullptr) delete[] GlobalC::ucell.atoms[0].taud;
    GlobalC::ucell.atoms[0].taud = new ModuleBase::Vector3<double>[1];
    GlobalC::ucell.atoms[0].taud[0].x = 0.0;
    GlobalC::ucell.atoms[0].taud[0].y = 0.0;
    GlobalC::ucell.atoms[0].taud[0].z = 0.0;
    // pseudopotential information
    GlobalC::ucell.atoms[0].ncpp.nbeta = 1; // projector
    GlobalC::ucell.atoms[0].ncpp.nchi = 1; // pswfc
    // real and reciprocal lattice definition
    GlobalC::ucell.lat0 = 1.234; // a.u.
    GlobalC::ucell.tpiba = 2.0 * M_PI / GlobalC::ucell.lat0;
    GlobalC::ucell.tpiba2 = GlobalC::ucell.tpiba * GlobalC::ucell.tpiba;
        // we mock a simple cubic lattice
    GlobalC::ucell.a1.x = 1.0; GlobalC::ucell.a1.y = 0.0; GlobalC::ucell.a1.z = 0.0;
    GlobalC::ucell.a2.x = 0.0; GlobalC::ucell.a2.y = 1.0; GlobalC::ucell.a2.z = 0.0;
    GlobalC::ucell.a3.x = 0.0; GlobalC::ucell.a3.y = 0.0; GlobalC::ucell.a3.z = 1.0;
    GlobalC::ucell.latvec.e11 = 1.0; GlobalC::ucell.latvec.e12 = 0.0; GlobalC::ucell.latvec.e13 = 0.0;
    GlobalC::ucell.latvec.e21 = 0.0; GlobalC::ucell.latvec.e22 = 1.0; GlobalC::ucell.latvec.e23 = 0.0;
    GlobalC::ucell.latvec.e31 = 0.0; GlobalC::ucell.latvec.e32 = 0.0; GlobalC::ucell.latvec.e33 = 1.0;
        // therefore the reciprocal lattice is also simple cubic, and note the unit, is 2pi/a
    GlobalC::ucell.GT = GlobalC::ucell.latvec.Inverse();
    GlobalC::ucell.G = GlobalC::ucell.GT.Transpose();
    GlobalC::ucell.GGT = GlobalC::ucell.G * GlobalC::ucell.GT;
}

class InitializerTest : public ::testing::Test {
protected:
    // ESolver::Init()
    ModulePW::PW_Basis* pw_rho;
    ModulePW::PW_Basis_K* pw_wfc;
    Structure_Factor* sf;
    psi::Psi<std::complex<double>>* psi;

    psi_initializer* psi_init;
    // for test, we only set one point in reciprocal space
    void mock_PW_Basis() {
        assert(this->pw_rho != nullptr);
        // grids
        this->pw_rho->fftnx = 1;
        this->pw_rho->fftny = 1;
        this->pw_rho->fftnz = 1;
        this->pw_rho->fftnxy = this->pw_rho->fftnx * this->pw_rho->fftny;
        this->pw_rho->fftnxyz = this->pw_rho->fftnx * this->pw_rho->fftny * this->pw_rho->fftnz;
        this->pw_rho->nx = 1;
        this->pw_rho->ny = 1;
        this->pw_rho->nz = 1;
        this->pw_rho->nxyz = this->pw_rho->nx * this->pw_rho->ny * this->pw_rho->nz;
        this->pw_rho->nxy = this->pw_rho->nx * this->pw_rho->ny;
    }
    void mock_Structure_Factor() {
        assert(this->sf != nullptr);
        this->sf->set(0);
        this->sf->setup_structure_factor(&(GlobalC::ucell), this->pw_rho);
    }
    void mock_PW_Basis_K() {
        assert(this->pw_wfc != nullptr);
        // grids
        this->pw_wfc->fftnx = this->pw_rho->fftnx;
        this->pw_wfc->fftny = this->pw_rho->fftny;
        this->pw_wfc->fftnz = this->pw_rho->fftnz;
        this->pw_wfc->fftnxy = this->pw_rho->fftnxy;
        this->pw_wfc->fftnxyz = this->pw_rho->fftnxyz;
        this->pw_wfc->nx = this->pw_rho->nx;
        this->pw_wfc->ny = this->pw_rho->ny;
        this->pw_wfc->nz = this->pw_rho->nz;
        this->pw_wfc->nxyz = this->pw_rho->nxyz;
        this->pw_wfc->nxy = this->pw_rho->nxy;
        // k points (k vectors)
        this->pw_wfc->nks = 1;
        if (this->pw_wfc->kvec_c != nullptr) delete[] this->pw_wfc->kvec_c;
        this->pw_wfc->kvec_c = new ModuleBase::Vector3<double>[this->pw_wfc->nks];
        this->pw_wfc->kvec_c[0].x = 0.0;
        this->pw_wfc->kvec_c[0].y = 0.0;
        this->pw_wfc->kvec_c[0].z = 0.0;
        if (this->pw_wfc->kvec_d != nullptr) delete[] this->pw_wfc->kvec_d;
        this->pw_wfc->kvec_d = new ModuleBase::Vector3<double>[this->pw_wfc->nks];
        this->pw_wfc->kvec_d[0].x = 0.0;
        this->pw_wfc->kvec_d[0].y = 0.0;
        this->pw_wfc->kvec_d[0].z = 0.0;
            // the kpoint (0, 0, 0) is on present processor
        // distribution of G vectors
        this->pw_wfc->nst = 1; // number of sticks
        if (this->pw_wfc->fftixy2ip != nullptr) delete[] this->pw_wfc->fftixy2ip;
        this->pw_wfc->fftixy2ip = new int[this->pw_wfc->fftnxy];
        this->pw_wfc->fftixy2ip[0] = 0; // so expect to have only one stick whose ixy is 0
        if (this->pw_wfc->is2fftixy != nullptr) delete[] this->pw_wfc->is2fftixy;
        this->pw_wfc->is2fftixy = new int[this->pw_wfc->nst];
        this->pw_wfc->is2fftixy[0] = 0; // so expect to have only one stick whose ixy is 0
        // planewave on kpoints, first divide processors into pools, each pool parallelize on kpoints, then divide planewave on kpoints into processors
        if (this->pw_wfc->npwk != nullptr) delete[] this->pw_wfc->npwk;
        this->pw_wfc->npwk = new int[this->pw_wfc->nks]; // on different kpoints in present pool
        this->pw_wfc->npwk[0] = 1;  // so expect to have only one planewave on kpoint 0
        this->pw_wfc->npw = 1; // for present processor, 1 planewave
        this->pw_wfc->npwk_max = 1; // and it is certainly the maximal number of planewave on kpoints
        // prepare for function getgpluskcar, k+G in Cartesian coordinates
        if (this->pw_wfc->gdirect != nullptr) delete[] this->pw_wfc->gdirect;
        this->pw_wfc->gdirect = new ModuleBase::Vector3<double>[this->pw_wfc->npwk_max];
        if (this->pw_wfc->gcar != nullptr) delete[] this->pw_wfc->gcar;
        this->pw_wfc->gcar = new ModuleBase::Vector3<double>[this->pw_wfc->npwk_max];
        double tpiba = 2.0 * M_PI / GlobalC::ucell.lat0;
        this->pw_wfc->gdirect[0].x = 0.0; this->pw_wfc->gdirect[0].y = 0.0; this->pw_wfc->gdirect[0].z = 0.0;
        this->pw_wfc->gcar[0].x = 0.0 * tpiba; this->pw_wfc->gcar[0].y = 0.0 * tpiba; this->pw_wfc->gcar[0].z = 0.0 * tpiba;
    }
    void status_report() {
        std::cout << "--------------------------------" << std::endl;
        std::cout << "Google Test: psi_initializer_test" << std::endl;
        std::cout << "--------------------------------" << std::endl;
        std::cout << "GlobalV::CALCULATION = " << GlobalV::CALCULATION << std::endl;
        std::cout << "GlobalV::NBANDS = " << GlobalV::NBANDS << std::endl;
        std::cout << "GlobalV::NLOCAL = " << GlobalV::NLOCAL << std::endl;
        std::cout << "GlobalV::NPOL = " << GlobalV::NPOL << std::endl;
        std::cout << "GlobalV::LSPINORB = " << GlobalV::LSPINORB << std::endl;
        std::cout << "GlobalV::NONCOLIN = " << GlobalV::NONCOLIN << std::endl;
        std::cout << "GlobalV::DOMAG = " << GlobalV::DOMAG << std::endl;
        std::cout << "GlobalV::DOMAG_Z = " << GlobalV::DOMAG_Z << std::endl;
        std::cout << "GlobalV::init_wfc = " << GlobalV::init_wfc << std::endl;
        std::cout << "GlobalV::psi_initializer = " << GlobalV::psi_initializer << std::endl;
        std::cout << "GlobalV::test_wf = " << GlobalV::test_wf << std::endl;
        std::cout << "GlobalV::KS_SOLVER = " << GlobalV::KS_SOLVER << std::endl;
        std::cout << "GlobalV::RANK_IN_POOL = " << GlobalV::RANK_IN_POOL << std::endl;
        std::cout << "GlobalV::NQX = " << GlobalV::NQX << std::endl;
        std::cout << "GlobalV::DQ = " << GlobalV::DQ << std::endl;
        std::cout << "GlobalC::ucell.natomwfc = " << GlobalC::ucell.natomwfc << std::endl;
        std::cout << "GlobalC::ucell.nat = " << GlobalC::ucell.nat << std::endl;
        std::cout << "GlobalC::ucell.ntype = " << GlobalC::ucell.ntype << std::endl;
        std::cout << "GlobalC::ucell.atoms[0].nwl = " << GlobalC::ucell.atoms[0].nwl << std::endl;
        std::cout << "GlobalC::ucell.atoms[0].l_nchi[0] = " << GlobalC::ucell.atoms[0].l_nchi[0] << std::endl;
        std::cout << "GlobalC::ucell.atoms[0].l_nchi[1] = " << GlobalC::ucell.atoms[0].l_nchi[1] << std::endl;
        std::cout << "GlobalC::ucell.atoms[0].tau[0] = " << GlobalC::ucell.atoms[0].tau[0].x << " " << GlobalC::ucell.atoms[0].tau[0].y << " " << GlobalC::ucell.atoms[0].tau[0].z << std::endl;
        std::cout << "GlobalC::ucell.atoms[0].taud[0] = " << GlobalC::ucell.atoms[0].taud[0].x << " " << GlobalC::ucell.atoms[0].taud[0].y << " " << GlobalC::ucell.atoms[0].taud[0].z << std::endl;
        std::cout << "GlobalC::ucell.lat0 = " << GlobalC::ucell.lat0 << std::endl;
        std::cout << "GlobalC::ucell.tpiba = " << GlobalC::ucell.tpiba << std::endl;
        std::cout << "GlobalC::ucell.tpiba2 = " << GlobalC::ucell.tpiba2 << std::endl;
        std::cout << "GlobalC::ucell.a1 = " << GlobalC::ucell.a1.x << " " << GlobalC::ucell.a1.y << " " << GlobalC::ucell.a1.z << std::endl;
        std::cout << "GlobalC::ucell.a2 = " << GlobalC::ucell.a2.x << " " << GlobalC::ucell.a2.y << " " << GlobalC::ucell.a2.z << std::endl;
        std::cout << "GlobalC::ucell.a3 = " << GlobalC::ucell.a3.x << " " << GlobalC::ucell.a3.y << " " << GlobalC::ucell.a3.z << std::endl;
        std::cout << "GlobalC::ucell.latvec = " << std::endl;
        std::cout << GlobalC::ucell.latvec.e11 << " " << GlobalC::ucell.latvec.e12 << " " << GlobalC::ucell.latvec.e13 << std::endl;
        std::cout << GlobalC::ucell.latvec.e21 << " " << GlobalC::ucell.latvec.e22 << " " << GlobalC::ucell.latvec.e23 << std::endl;
        std::cout << GlobalC::ucell.latvec.e31 << " " << GlobalC::ucell.latvec.e32 << " " << GlobalC::ucell.latvec.e33 << std::endl;
        std::cout << "GlobalC::ucell.GT = " << std::endl;
        std::cout << GlobalC::ucell.GT.e11 << " " << GlobalC::ucell.GT.e12 << " " << GlobalC::ucell.GT.e13 << std::endl;
        std::cout << GlobalC::ucell.GT.e21 << " " << GlobalC::ucell.GT.e22 << " " << GlobalC::ucell.GT.e23 << std::endl;
        std::cout << GlobalC::ucell.GT.e31 << " " << GlobalC::ucell.GT.e32 << " " << GlobalC::ucell.GT.e33 << std::endl;
        std::cout << "GlobalC::ucell.G = " << std::endl;
        std::cout << GlobalC::ucell.G.e11 << " " << GlobalC::ucell.G.e12 << " " << GlobalC::ucell.G.e13 << std::endl;
        std::cout << GlobalC::ucell.G.e21 << " " << GlobalC::ucell.G.e22 << " " << GlobalC::ucell.G.e23 << std::endl;
        std::cout << GlobalC::ucell.G.e31 << " " << GlobalC::ucell.G.e32 << " " << GlobalC::ucell.G.e33 << std::endl;
        std::cout << "GlobalC::ucell.GGT = " << std::endl;
        std::cout << GlobalC::ucell.GGT.e11 << " " << GlobalC::ucell.GGT.e12 << " " << GlobalC::ucell.GGT.e13 << std::endl;
        std::cout << GlobalC::ucell.GGT.e21 << " " << GlobalC::ucell.GGT.e22 << " " << GlobalC::ucell.GGT.e23 << std::endl;
        std::cout << GlobalC::ucell.GGT.e31 << " " << GlobalC::ucell.GGT.e32 << " " << GlobalC::ucell.GGT.e33 << std::endl;
        std::cout << "--------------------------------" << std::endl;
        std::cout << "PW_Basis initialization" << std::endl;
        std::cout << "--------------------------------" << std::endl;
        std::cout << "pw_rho->fftnx = " << this->pw_rho->fftnx << std::endl;
        std::cout << "pw_rho->fftny = " << this->pw_rho->fftny << std::endl;
        std::cout << "pw_rho->fftnz = " << this->pw_rho->fftnz << std::endl;
        std::cout << "pw_rho->fftnxy = " << this->pw_rho->fftnxy << std::endl;
        std::cout << "pw_rho->fftnxyz = " << this->pw_rho->fftnxyz << std::endl;
    }
    void SetUp() override {
        mock_GlobalV();
        mock_GlobalC();
        if (this->pw_rho != nullptr) delete this->pw_rho;
        this->pw_rho = new ModulePW::PW_Basis();
        this->mock_PW_Basis();
        if (this->pw_wfc != nullptr) delete this->pw_wfc;
        this->pw_wfc = new ModulePW::PW_Basis_K();
        this->mock_PW_Basis_K();
        if (this->sf != nullptr) delete this->sf;
        this->sf = new Structure_Factor();
        this->mock_Structure_Factor();
        if (this->psi != nullptr) delete this->psi;
        this->psi = nullptr;
    }
    void TearDown() override {
        if (this->sf != nullptr) delete this->sf;
        if (this->pw_wfc != nullptr) delete this->pw_wfc;
        if (this->psi != nullptr) delete this->psi;
        if (this->pw_rho != nullptr) delete this->pw_rho;

        if (this->psi_init != nullptr) delete this->psi_init;
    }
};

TEST_F(InitializerTest, Constructor) {

    this->psi_init = new psi_initializer_atomic(sf, pw_wfc);
    EXPECT_EQ(psi_init->get_method(), "atomic");
    EXPECT_NE(psi_init->get_ixy2is(), nullptr);
    EXPECT_EQ(psi_init->get_ixy2is()[0], 0);
    EXPECT_EQ(psi_init->get_random_mix(), 0.0);
    delete this->psi_init;
    this->psi_init = new psi_initializer_random(sf, pw_wfc);
    EXPECT_EQ(psi_init->get_method(), "random");
    EXPECT_NE(psi_init->get_ixy2is(), nullptr);
    EXPECT_EQ(psi_init->get_ixy2is()[0], 0);
    EXPECT_EQ(psi_init->get_random_mix(), 0.0);
    delete this->psi_init;
    this->psi_init = new psi_initializer_nao(sf, pw_wfc);
    EXPECT_EQ(psi_init->get_method(), "nao");
    EXPECT_NE(psi_init->get_ixy2is(), nullptr);
    EXPECT_EQ(psi_init->get_ixy2is()[0], 0);
    EXPECT_EQ(psi_init->get_random_mix(), 0.0);
    delete this->psi_init;
    this->psi_init = new psi_initializer_atomic_random(sf, pw_wfc);
    EXPECT_EQ(psi_init->get_method(), "atomic+random");
    EXPECT_NE(psi_init->get_ixy2is(), nullptr);
    EXPECT_EQ(psi_init->get_ixy2is()[0], 0);
    EXPECT_EQ(psi_init->get_random_mix(), 0.05);
    delete this->psi_init;
    this->psi_init = new psi_initializer_nao_random(sf, pw_wfc);
    EXPECT_EQ(psi_init->get_method(), "nao+random");
    EXPECT_NE(psi_init->get_ixy2is(), nullptr);
    EXPECT_EQ(psi_init->get_ixy2is()[0], 0);
    EXPECT_EQ(psi_init->get_random_mix(), 0.05);
    delete this->psi_init;
}

TEST_F(InitializerTest, GetStartingNw) {
    // mimic the behavior of init_wfc = "atomic"
    GlobalV::psi_initializer = true;
    GlobalV::init_wfc = "atomic";
    GlobalC::ucell.natomwfc = 2;
    GlobalV::NBANDS = 1;
    this->psi_init = new psi_initializer_atomic(sf, pw_wfc);
    EXPECT_EQ(psi_init->get_starting_nw(), GlobalC::ucell.natomwfc);
    GlobalC::ucell.natomwfc = 1;
    GlobalV::NBANDS = 3;
    EXPECT_EQ(psi_init->get_starting_nw(), GlobalV::NBANDS);
    delete this->psi_init;
    // mimic the behavior of init_wfc = "random"
    GlobalV::psi_initializer = true;
    GlobalV::init_wfc = "random";
    GlobalV::NBANDS = 2;
    this->psi_init = new psi_initializer_random(sf, pw_wfc);
    EXPECT_EQ(psi_init->get_starting_nw(), GlobalV::NBANDS);
    delete this->psi_init;
}

TEST_F(InitializerTest, Allocate) {

    GlobalV::psi_initializer = true;
    GlobalV::init_wfc = "random";
    GlobalV::CALCULATION = "scf";

    GlobalV::NBANDS = 3;
    GlobalV::NLOCAL = 4; // 1s + 3p
    GlobalC::ucell.natomwfc = 5;
    // so psi_initializer::nbands_files should be 5

    psi_initializer* psi_init = new psi_initializer_random(sf, pw_wfc);
    psi::Psi<std::complex<double>>* psi = psi_init->allocate();
    EXPECT_NE(psi, nullptr);
    EXPECT_EQ(psi->get_nk(), 1);
    EXPECT_EQ(psi->get_nbands(), GlobalV::NBANDS);
    EXPECT_EQ(psi->get_nbasis(), 1);
    EXPECT_EQ(psi_init->get_nbands_complem(), 0);
    EXPECT_EQ(psi_init->psig->get_nk(), 1);
    EXPECT_EQ(psi_init->psig->get_nbands(), 3);
    EXPECT_EQ(psi_init->psig->get_nbasis(), 1);
    delete psi;
    delete psi_init;

    GlobalV::init_wfc = "atomic";
    psi_init = new psi_initializer_atomic(sf, pw_wfc);
    psi = psi_init->allocate();
    EXPECT_NE(psi, nullptr);
    EXPECT_EQ(psi->get_nk(), 1);
    EXPECT_EQ(psi->get_nbands(), GlobalV::NBANDS);
    EXPECT_EQ(psi->get_nbasis(), 1);
    EXPECT_EQ(psi_init->get_nbands_complem(), 0);
    EXPECT_EQ(psi_init->psig->get_nk(), 1);
    EXPECT_EQ(psi_init->psig->get_nbands(), 5);
    EXPECT_EQ(psi_init->psig->get_nbasis(), 1);
    delete psi;
    delete psi_init;

    // for nao, it is the same, so now test NBANDS = 20
    GlobalV::init_wfc = "nao";
    GlobalV::NBANDS = 20;
    psi_init = new psi_initializer_nao(sf, pw_wfc);
    psi = psi_init->allocate();
    EXPECT_NE(psi, nullptr);
    EXPECT_EQ(psi->get_nk(), 1);
    EXPECT_EQ(psi->get_nbands(), GlobalV::NBANDS);
    EXPECT_EQ(psi->get_nbasis(), 1);
    EXPECT_EQ(psi_init->get_nbands_complem(), 15);
    EXPECT_EQ(psi_init->psig->get_nk(), 1);
    EXPECT_EQ(psi_init->psig->get_nbands(), GlobalV::NBANDS);
    EXPECT_EQ(psi_init->psig->get_nbasis(), 1);
    delete psi;
    delete psi_init;
}

#ifdef __MPI
TEST_F(InitializerTest, StickToPool) {

    GlobalV::psi_initializer = true;
    GlobalV::init_wfc = "random"
    GlobalV::CALCULATION = "scf";
    GlobalV::RANK_IN_POOL = 0;

    psi_initializer* psi_init = new psi_initializer_random(sf, pw_wfc);

    double* stick = new double[1];
    stick[0] = 1.234;
    double* out = new double[1];

    psi_init->stick_to_pool(stick, 0, out, this->pw_wfc);
    EXPECT_EQ(out[0], stick[0]);
}
#endif

TEST_F(InitializerTest, CalPsiG) {
    system("cp ./support/KPT ./KPT");
    system("cp ./support/STRU ./STRU");
    // init_wfc = "random"
    system("cp ./support/random_new ./INPUT");
    system("../../../build/abacus");
    system("rm INPUT");
    system("cp ./support/random_old ./INPUT");
    system("../../../build/abacus");
    system("rm INPUT");
    // compare wavefunctions
    std::ifstream ifs_new("psig_0_kpt.out");
    std::ifstream ifs_old("psig_0_kpt_old.out");
    std::string line_new, line_old;
    std::regex pattern("\\((-?[0-9]+\\.[0-9]*),(-?[0-9]+\\.[0-9]*)\\)");
    std::smatch match_new, match_old;
    int n_match_max = 10;
    int n_match = 0;
    while (ifs_new >> line_new && ifs_old >> line_old) {
        if (std::regex_search(line_new, match_new, pattern) && std::regex_search(line_old, match_old, pattern)) {
            EXPECT_EQ(match_new.size(), match_old.size());
            double real_new = std::stod(match_new[1]);
            double imag_new = std::stod(match_new[2]);
            double real_old = std::stod(match_old[1]);
            double imag_old = std::stod(match_old[2]);
            EXPECT_NEAR(real_new, real_old, 1e-10);
            EXPECT_NEAR(imag_new, imag_old, 1e-10);
            n_match++;
            if (n_match == n_match_max) break;
        }
    }
    ifs_new.close();
    ifs_old.close();
    system("rm psig_0_kpt.out");
    system("rm psig_0_kpt_old.out");
    // init_wfc = "atomic"
    system("cp ./support/atomic_new ./INPUT");
    system("../../../build/abacus");
    system("rm INPUT");
    // compare wavefunctions with reference value
    std::vector<double> reals_ref = {
        -6.00042e-06, 1.70688e-05, 5.37252e-05, -0.000649742, -0.00500944,
        -0.0129274, 0.112567, 0.919317, 0.112567, -0.0129274
    };
    std::vector<double> imags_ref = {
        0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, -0.0, -0.0, -0.0
    };
    std::vector<double> reals_read;
    std::vector<double> imags_read;
    ifs_new.open("psig_0_kpt.out");
    n_match = 0;
    while (ifs_new >> line_new) {
        if (regex_search(line_new, match_new, pattern)) { //check if the line contains a complex number tuple
            double real = stod(match_new[1]); //extract the real part of the complex number
            double imag = stod(match_new[2]); //extract the imaginary part of the complex number
            reals_read.push_back(real);
            imags_read.push_back(imag);
            n_match++;
            if (n_match == n_match_max) break;
        }
    }
    ifs_new.close();
    EXPECT_EQ(reals_read.size(), reals_ref.size());
    EXPECT_EQ(imags_read.size(), imags_ref.size());
    for (int i = 0; i < reals_ref.size(); i++) {
        EXPECT_NEAR(reals_read[i], reals_ref[i], 1e-5);
        EXPECT_NEAR(imags_read[i], imags_ref[i], 1e-5);
    }
    system("rm psig_0_kpt.out");
    // init_wfc = "nao"
    system("cp ./support/nao_new ./INPUT");
    system("../../../build/abacus");
    system("rm INPUT");
    reals_ref.clear();
    imags_ref.clear();
    reals_read.clear();
    imags_read.clear();
    // compare wavefunctions with reference value
    reals_ref = {
        -1.25534e-06, -7.1728e-05, 0.000112783, -0.000599359, -0.00603285,
        -0.0164273, 0.14776, 1.16658, 0.14776, -0.0164273
    };
    imags_ref = {
        0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, -0.0, -0.0, -0.0, -0.0
    };
    ifs_new.open("psig_0_kpt.out");
    n_match = 0;
    while (ifs_new >> line_new) {
        if (regex_search(line_new, match_new, pattern)) { //check if the line contains a complex number tuple
            double real = stod(match_new[1]); //extract the real part of the complex number
            double imag = stod(match_new[2]); //extract the imaginary part of the complex number
            reals_read.push_back(real);
            imags_read.push_back(imag);
            n_match++;
            if (n_match == n_match_max) break;
        }
    }
    ifs_new.close();
    EXPECT_EQ(reals_read.size(), reals_ref.size());
    EXPECT_EQ(imags_read.size(), imags_ref.size());
    for (int i = 0; i < reals_ref.size(); i++) {
        EXPECT_NEAR(reals_read[i], reals_ref[i], 1e-5);
        EXPECT_NEAR(imags_read[i], imags_ref[i], 1e-5);
    }
    system("rm psig_0_kpt.out");

    // finalize
    system("rm KPT");
    system("rm STRU");
    system("rm -rf OUT*");
}